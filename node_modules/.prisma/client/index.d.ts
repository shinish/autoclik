
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Automation
 * 
 */
export type Automation = $Result.DefaultSelection<Prisma.$AutomationPayload>
/**
 * Model Run
 * 
 */
export type Run = $Result.DefaultSelection<Prisma.$RunPayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ConnectivityCheck
 * 
 */
export type ConnectivityCheck = $Result.DefaultSelection<Prisma.$ConnectivityCheckPayload>
/**
 * Model Namespace
 * 
 */
export type Namespace = $Result.DefaultSelection<Prisma.$NamespacePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model GroupMember
 * 
 */
export type GroupMember = $Result.DefaultSelection<Prisma.$GroupMemberPayload>
/**
 * Model NamespacePermission
 * 
 */
export type NamespacePermission = $Result.DefaultSelection<Prisma.$NamespacePermissionPayload>
/**
 * Model ModulePermission
 * 
 */
export type ModulePermission = $Result.DefaultSelection<Prisma.$ModulePermissionPayload>
/**
 * Model Credential
 * 
 */
export type Credential = $Result.DefaultSelection<Prisma.$CredentialPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model RunCounter
 * 
 */
export type RunCounter = $Result.DefaultSelection<Prisma.$RunCounterPayload>
/**
 * Model InstanceGroup
 * 
 */
export type InstanceGroup = $Result.DefaultSelection<Prisma.$InstanceGroupPayload>
/**
 * Model AwxEnvironment
 * 
 */
export type AwxEnvironment = $Result.DefaultSelection<Prisma.$AwxEnvironmentPayload>
/**
 * Model Catalog
 * 
 */
export type Catalog = $Result.DefaultSelection<Prisma.$CatalogPayload>
/**
 * Model CatalogExecution
 * 
 */
export type CatalogExecution = $Result.DefaultSelection<Prisma.$CatalogExecutionPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Automations
 * const automations = await prisma.automation.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Automations
   * const automations = await prisma.automation.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.automation`: Exposes CRUD operations for the **Automation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Automations
    * const automations = await prisma.automation.findMany()
    * ```
    */
  get automation(): Prisma.AutomationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.run`: Exposes CRUD operations for the **Run** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Runs
    * const runs = await prisma.run.findMany()
    * ```
    */
  get run(): Prisma.RunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.connectivityCheck`: Exposes CRUD operations for the **ConnectivityCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConnectivityChecks
    * const connectivityChecks = await prisma.connectivityCheck.findMany()
    * ```
    */
  get connectivityCheck(): Prisma.ConnectivityCheckDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.namespace`: Exposes CRUD operations for the **Namespace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Namespaces
    * const namespaces = await prisma.namespace.findMany()
    * ```
    */
  get namespace(): Prisma.NamespaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupMember`: Exposes CRUD operations for the **GroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMembers
    * const groupMembers = await prisma.groupMember.findMany()
    * ```
    */
  get groupMember(): Prisma.GroupMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.namespacePermission`: Exposes CRUD operations for the **NamespacePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NamespacePermissions
    * const namespacePermissions = await prisma.namespacePermission.findMany()
    * ```
    */
  get namespacePermission(): Prisma.NamespacePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modulePermission`: Exposes CRUD operations for the **ModulePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModulePermissions
    * const modulePermissions = await prisma.modulePermission.findMany()
    * ```
    */
  get modulePermission(): Prisma.ModulePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.credential`: Exposes CRUD operations for the **Credential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credentials
    * const credentials = await prisma.credential.findMany()
    * ```
    */
  get credential(): Prisma.CredentialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.runCounter`: Exposes CRUD operations for the **RunCounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RunCounters
    * const runCounters = await prisma.runCounter.findMany()
    * ```
    */
  get runCounter(): Prisma.RunCounterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instanceGroup`: Exposes CRUD operations for the **InstanceGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstanceGroups
    * const instanceGroups = await prisma.instanceGroup.findMany()
    * ```
    */
  get instanceGroup(): Prisma.InstanceGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.awxEnvironment`: Exposes CRUD operations for the **AwxEnvironment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AwxEnvironments
    * const awxEnvironments = await prisma.awxEnvironment.findMany()
    * ```
    */
  get awxEnvironment(): Prisma.AwxEnvironmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.catalog`: Exposes CRUD operations for the **Catalog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Catalogs
    * const catalogs = await prisma.catalog.findMany()
    * ```
    */
  get catalog(): Prisma.CatalogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.catalogExecution`: Exposes CRUD operations for the **CatalogExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogExecutions
    * const catalogExecutions = await prisma.catalogExecution.findMany()
    * ```
    */
  get catalogExecution(): Prisma.CatalogExecutionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Automation: 'Automation',
    Run: 'Run',
    Schedule: 'Schedule',
    Notification: 'Notification',
    ConnectivityCheck: 'ConnectivityCheck',
    Namespace: 'Namespace',
    User: 'User',
    Group: 'Group',
    GroupMember: 'GroupMember',
    NamespacePermission: 'NamespacePermission',
    ModulePermission: 'ModulePermission',
    Credential: 'Credential',
    Setting: 'Setting',
    Activity: 'Activity',
    RunCounter: 'RunCounter',
    InstanceGroup: 'InstanceGroup',
    AwxEnvironment: 'AwxEnvironment',
    Catalog: 'Catalog',
    CatalogExecution: 'CatalogExecution'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "automation" | "run" | "schedule" | "notification" | "connectivityCheck" | "namespace" | "user" | "group" | "groupMember" | "namespacePermission" | "modulePermission" | "credential" | "setting" | "activity" | "runCounter" | "instanceGroup" | "awxEnvironment" | "catalog" | "catalogExecution"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Automation: {
        payload: Prisma.$AutomationPayload<ExtArgs>
        fields: Prisma.AutomationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          findFirst: {
            args: Prisma.AutomationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          findMany: {
            args: Prisma.AutomationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>[]
          }
          create: {
            args: Prisma.AutomationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          createMany: {
            args: Prisma.AutomationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>[]
          }
          delete: {
            args: Prisma.AutomationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          update: {
            args: Prisma.AutomationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          deleteMany: {
            args: Prisma.AutomationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutomationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>[]
          }
          upsert: {
            args: Prisma.AutomationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          aggregate: {
            args: Prisma.AutomationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomation>
          }
          groupBy: {
            args: Prisma.AutomationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationCountAggregateOutputType> | number
          }
        }
      }
      Run: {
        payload: Prisma.$RunPayload<ExtArgs>
        fields: Prisma.RunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunPayload>
          }
          findFirst: {
            args: Prisma.RunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunPayload>
          }
          findMany: {
            args: Prisma.RunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunPayload>[]
          }
          create: {
            args: Prisma.RunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunPayload>
          }
          createMany: {
            args: Prisma.RunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunPayload>[]
          }
          delete: {
            args: Prisma.RunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunPayload>
          }
          update: {
            args: Prisma.RunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunPayload>
          }
          deleteMany: {
            args: Prisma.RunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunPayload>[]
          }
          upsert: {
            args: Prisma.RunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunPayload>
          }
          aggregate: {
            args: Prisma.RunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRun>
          }
          groupBy: {
            args: Prisma.RunGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCountArgs<ExtArgs>
            result: $Utils.Optional<RunCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ConnectivityCheck: {
        payload: Prisma.$ConnectivityCheckPayload<ExtArgs>
        fields: Prisma.ConnectivityCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConnectivityCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConnectivityCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityCheckPayload>
          }
          findFirst: {
            args: Prisma.ConnectivityCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConnectivityCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityCheckPayload>
          }
          findMany: {
            args: Prisma.ConnectivityCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityCheckPayload>[]
          }
          create: {
            args: Prisma.ConnectivityCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityCheckPayload>
          }
          createMany: {
            args: Prisma.ConnectivityCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConnectivityCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityCheckPayload>[]
          }
          delete: {
            args: Prisma.ConnectivityCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityCheckPayload>
          }
          update: {
            args: Prisma.ConnectivityCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityCheckPayload>
          }
          deleteMany: {
            args: Prisma.ConnectivityCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConnectivityCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConnectivityCheckUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityCheckPayload>[]
          }
          upsert: {
            args: Prisma.ConnectivityCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectivityCheckPayload>
          }
          aggregate: {
            args: Prisma.ConnectivityCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConnectivityCheck>
          }
          groupBy: {
            args: Prisma.ConnectivityCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConnectivityCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConnectivityCheckCountArgs<ExtArgs>
            result: $Utils.Optional<ConnectivityCheckCountAggregateOutputType> | number
          }
        }
      }
      Namespace: {
        payload: Prisma.$NamespacePayload<ExtArgs>
        fields: Prisma.NamespaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NamespaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NamespaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePayload>
          }
          findFirst: {
            args: Prisma.NamespaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NamespaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePayload>
          }
          findMany: {
            args: Prisma.NamespaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePayload>[]
          }
          create: {
            args: Prisma.NamespaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePayload>
          }
          createMany: {
            args: Prisma.NamespaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NamespaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePayload>[]
          }
          delete: {
            args: Prisma.NamespaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePayload>
          }
          update: {
            args: Prisma.NamespaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePayload>
          }
          deleteMany: {
            args: Prisma.NamespaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NamespaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NamespaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePayload>[]
          }
          upsert: {
            args: Prisma.NamespaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePayload>
          }
          aggregate: {
            args: Prisma.NamespaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNamespace>
          }
          groupBy: {
            args: Prisma.NamespaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NamespaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NamespaceCountArgs<ExtArgs>
            result: $Utils.Optional<NamespaceCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      GroupMember: {
        payload: Prisma.$GroupMemberPayload<ExtArgs>
        fields: Prisma.GroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findFirst: {
            args: Prisma.GroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findMany: {
            args: Prisma.GroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          create: {
            args: Prisma.GroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          createMany: {
            args: Prisma.GroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          delete: {
            args: Prisma.GroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          update: {
            args: Prisma.GroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.GroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          upsert: {
            args: Prisma.GroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          aggregate: {
            args: Prisma.GroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMember>
          }
          groupBy: {
            args: Prisma.GroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberCountAggregateOutputType> | number
          }
        }
      }
      NamespacePermission: {
        payload: Prisma.$NamespacePermissionPayload<ExtArgs>
        fields: Prisma.NamespacePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NamespacePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NamespacePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePermissionPayload>
          }
          findFirst: {
            args: Prisma.NamespacePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NamespacePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePermissionPayload>
          }
          findMany: {
            args: Prisma.NamespacePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePermissionPayload>[]
          }
          create: {
            args: Prisma.NamespacePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePermissionPayload>
          }
          createMany: {
            args: Prisma.NamespacePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NamespacePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePermissionPayload>[]
          }
          delete: {
            args: Prisma.NamespacePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePermissionPayload>
          }
          update: {
            args: Prisma.NamespacePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePermissionPayload>
          }
          deleteMany: {
            args: Prisma.NamespacePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NamespacePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NamespacePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePermissionPayload>[]
          }
          upsert: {
            args: Prisma.NamespacePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NamespacePermissionPayload>
          }
          aggregate: {
            args: Prisma.NamespacePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNamespacePermission>
          }
          groupBy: {
            args: Prisma.NamespacePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NamespacePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NamespacePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<NamespacePermissionCountAggregateOutputType> | number
          }
        }
      }
      ModulePermission: {
        payload: Prisma.$ModulePermissionPayload<ExtArgs>
        fields: Prisma.ModulePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModulePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModulePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePermissionPayload>
          }
          findFirst: {
            args: Prisma.ModulePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModulePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePermissionPayload>
          }
          findMany: {
            args: Prisma.ModulePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePermissionPayload>[]
          }
          create: {
            args: Prisma.ModulePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePermissionPayload>
          }
          createMany: {
            args: Prisma.ModulePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModulePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePermissionPayload>[]
          }
          delete: {
            args: Prisma.ModulePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePermissionPayload>
          }
          update: {
            args: Prisma.ModulePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePermissionPayload>
          }
          deleteMany: {
            args: Prisma.ModulePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModulePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModulePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePermissionPayload>[]
          }
          upsert: {
            args: Prisma.ModulePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePermissionPayload>
          }
          aggregate: {
            args: Prisma.ModulePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModulePermission>
          }
          groupBy: {
            args: Prisma.ModulePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModulePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModulePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<ModulePermissionCountAggregateOutputType> | number
          }
        }
      }
      Credential: {
        payload: Prisma.$CredentialPayload<ExtArgs>
        fields: Prisma.CredentialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CredentialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CredentialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          findFirst: {
            args: Prisma.CredentialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CredentialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          findMany: {
            args: Prisma.CredentialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          create: {
            args: Prisma.CredentialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          createMany: {
            args: Prisma.CredentialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CredentialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          delete: {
            args: Prisma.CredentialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          update: {
            args: Prisma.CredentialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          deleteMany: {
            args: Prisma.CredentialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CredentialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CredentialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          upsert: {
            args: Prisma.CredentialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          aggregate: {
            args: Prisma.CredentialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredential>
          }
          groupBy: {
            args: Prisma.CredentialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.CredentialCountArgs<ExtArgs>
            result: $Utils.Optional<CredentialCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      RunCounter: {
        payload: Prisma.$RunCounterPayload<ExtArgs>
        fields: Prisma.RunCounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RunCounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RunCounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCounterPayload>
          }
          findFirst: {
            args: Prisma.RunCounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RunCounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCounterPayload>
          }
          findMany: {
            args: Prisma.RunCounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCounterPayload>[]
          }
          create: {
            args: Prisma.RunCounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCounterPayload>
          }
          createMany: {
            args: Prisma.RunCounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RunCounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCounterPayload>[]
          }
          delete: {
            args: Prisma.RunCounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCounterPayload>
          }
          update: {
            args: Prisma.RunCounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCounterPayload>
          }
          deleteMany: {
            args: Prisma.RunCounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RunCounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RunCounterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCounterPayload>[]
          }
          upsert: {
            args: Prisma.RunCounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RunCounterPayload>
          }
          aggregate: {
            args: Prisma.RunCounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRunCounter>
          }
          groupBy: {
            args: Prisma.RunCounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<RunCounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.RunCounterCountArgs<ExtArgs>
            result: $Utils.Optional<RunCounterCountAggregateOutputType> | number
          }
        }
      }
      InstanceGroup: {
        payload: Prisma.$InstanceGroupPayload<ExtArgs>
        fields: Prisma.InstanceGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstanceGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstanceGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstanceGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstanceGroupPayload>
          }
          findFirst: {
            args: Prisma.InstanceGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstanceGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstanceGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstanceGroupPayload>
          }
          findMany: {
            args: Prisma.InstanceGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstanceGroupPayload>[]
          }
          create: {
            args: Prisma.InstanceGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstanceGroupPayload>
          }
          createMany: {
            args: Prisma.InstanceGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstanceGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstanceGroupPayload>[]
          }
          delete: {
            args: Prisma.InstanceGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstanceGroupPayload>
          }
          update: {
            args: Prisma.InstanceGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstanceGroupPayload>
          }
          deleteMany: {
            args: Prisma.InstanceGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstanceGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstanceGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstanceGroupPayload>[]
          }
          upsert: {
            args: Prisma.InstanceGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstanceGroupPayload>
          }
          aggregate: {
            args: Prisma.InstanceGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstanceGroup>
          }
          groupBy: {
            args: Prisma.InstanceGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstanceGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstanceGroupCountArgs<ExtArgs>
            result: $Utils.Optional<InstanceGroupCountAggregateOutputType> | number
          }
        }
      }
      AwxEnvironment: {
        payload: Prisma.$AwxEnvironmentPayload<ExtArgs>
        fields: Prisma.AwxEnvironmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AwxEnvironmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwxEnvironmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AwxEnvironmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwxEnvironmentPayload>
          }
          findFirst: {
            args: Prisma.AwxEnvironmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwxEnvironmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AwxEnvironmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwxEnvironmentPayload>
          }
          findMany: {
            args: Prisma.AwxEnvironmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwxEnvironmentPayload>[]
          }
          create: {
            args: Prisma.AwxEnvironmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwxEnvironmentPayload>
          }
          createMany: {
            args: Prisma.AwxEnvironmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AwxEnvironmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwxEnvironmentPayload>[]
          }
          delete: {
            args: Prisma.AwxEnvironmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwxEnvironmentPayload>
          }
          update: {
            args: Prisma.AwxEnvironmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwxEnvironmentPayload>
          }
          deleteMany: {
            args: Prisma.AwxEnvironmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AwxEnvironmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AwxEnvironmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwxEnvironmentPayload>[]
          }
          upsert: {
            args: Prisma.AwxEnvironmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwxEnvironmentPayload>
          }
          aggregate: {
            args: Prisma.AwxEnvironmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAwxEnvironment>
          }
          groupBy: {
            args: Prisma.AwxEnvironmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AwxEnvironmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AwxEnvironmentCountArgs<ExtArgs>
            result: $Utils.Optional<AwxEnvironmentCountAggregateOutputType> | number
          }
        }
      }
      Catalog: {
        payload: Prisma.$CatalogPayload<ExtArgs>
        fields: Prisma.CatalogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>
          }
          findFirst: {
            args: Prisma.CatalogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>
          }
          findMany: {
            args: Prisma.CatalogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>[]
          }
          create: {
            args: Prisma.CatalogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>
          }
          createMany: {
            args: Prisma.CatalogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>[]
          }
          delete: {
            args: Prisma.CatalogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>
          }
          update: {
            args: Prisma.CatalogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>
          }
          deleteMany: {
            args: Prisma.CatalogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CatalogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>[]
          }
          upsert: {
            args: Prisma.CatalogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogPayload>
          }
          aggregate: {
            args: Prisma.CatalogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalog>
          }
          groupBy: {
            args: Prisma.CatalogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogCountAggregateOutputType> | number
          }
        }
      }
      CatalogExecution: {
        payload: Prisma.$CatalogExecutionPayload<ExtArgs>
        fields: Prisma.CatalogExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogExecutionPayload>
          }
          findFirst: {
            args: Prisma.CatalogExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogExecutionPayload>
          }
          findMany: {
            args: Prisma.CatalogExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogExecutionPayload>[]
          }
          create: {
            args: Prisma.CatalogExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogExecutionPayload>
          }
          createMany: {
            args: Prisma.CatalogExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogExecutionPayload>[]
          }
          delete: {
            args: Prisma.CatalogExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogExecutionPayload>
          }
          update: {
            args: Prisma.CatalogExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogExecutionPayload>
          }
          deleteMany: {
            args: Prisma.CatalogExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CatalogExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogExecutionPayload>[]
          }
          upsert: {
            args: Prisma.CatalogExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogExecutionPayload>
          }
          aggregate: {
            args: Prisma.CatalogExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalogExecution>
          }
          groupBy: {
            args: Prisma.CatalogExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogExecutionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    automation?: AutomationOmit
    run?: RunOmit
    schedule?: ScheduleOmit
    notification?: NotificationOmit
    connectivityCheck?: ConnectivityCheckOmit
    namespace?: NamespaceOmit
    user?: UserOmit
    group?: GroupOmit
    groupMember?: GroupMemberOmit
    namespacePermission?: NamespacePermissionOmit
    modulePermission?: ModulePermissionOmit
    credential?: CredentialOmit
    setting?: SettingOmit
    activity?: ActivityOmit
    runCounter?: RunCounterOmit
    instanceGroup?: InstanceGroupOmit
    awxEnvironment?: AwxEnvironmentOmit
    catalog?: CatalogOmit
    catalogExecution?: CatalogExecutionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AutomationCountOutputType
   */

  export type AutomationCountOutputType = {
    runs_history: number
    schedules: number
  }

  export type AutomationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runs_history?: boolean | AutomationCountOutputTypeCountRuns_historyArgs
    schedules?: boolean | AutomationCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes
  /**
   * AutomationCountOutputType without action
   */
  export type AutomationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationCountOutputType
     */
    select?: AutomationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AutomationCountOutputType without action
   */
  export type AutomationCountOutputTypeCountRuns_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunWhereInput
  }

  /**
   * AutomationCountOutputType without action
   */
  export type AutomationCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }


  /**
   * Count Type NamespaceCountOutputType
   */

  export type NamespaceCountOutputType = {
    permissions: number
  }

  export type NamespaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | NamespaceCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * NamespaceCountOutputType without action
   */
  export type NamespaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespaceCountOutputType
     */
    select?: NamespaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NamespaceCountOutputType without action
   */
  export type NamespaceCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NamespacePermissionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    subordinates: number
    groupMemberships: number
    permissions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subordinates?: boolean | UserCountOutputTypeCountSubordinatesArgs
    groupMemberships?: boolean | UserCountOutputTypeCountGroupMembershipsArgs
    permissions?: boolean | UserCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NamespacePermissionWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    members: number
    permissions: number
    modulePermissions: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | GroupCountOutputTypeCountMembersArgs
    permissions?: boolean | GroupCountOutputTypeCountPermissionsArgs
    modulePermissions?: boolean | GroupCountOutputTypeCountModulePermissionsArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NamespacePermissionWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountModulePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModulePermissionWhereInput
  }


  /**
   * Count Type AwxEnvironmentCountOutputType
   */

  export type AwxEnvironmentCountOutputType = {
    catalogs: number
  }

  export type AwxEnvironmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catalogs?: boolean | AwxEnvironmentCountOutputTypeCountCatalogsArgs
  }

  // Custom InputTypes
  /**
   * AwxEnvironmentCountOutputType without action
   */
  export type AwxEnvironmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwxEnvironmentCountOutputType
     */
    select?: AwxEnvironmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AwxEnvironmentCountOutputType without action
   */
  export type AwxEnvironmentCountOutputTypeCountCatalogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogWhereInput
  }


  /**
   * Count Type CatalogCountOutputType
   */

  export type CatalogCountOutputType = {
    executions: number
  }

  export type CatalogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | CatalogCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * CatalogCountOutputType without action
   */
  export type CatalogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogCountOutputType
     */
    select?: CatalogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatalogCountOutputType without action
   */
  export type CatalogCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogExecutionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Automation
   */

  export type AggregateAutomation = {
    _count: AutomationCountAggregateOutputType | null
    _avg: AutomationAvgAggregateOutputType | null
    _sum: AutomationSumAggregateOutputType | null
    _min: AutomationMinAggregateOutputType | null
    _max: AutomationMaxAggregateOutputType | null
  }

  export type AutomationAvgAggregateOutputType = {
    runs: number | null
  }

  export type AutomationSumAggregateOutputType = {
    runs: number | null
  }

  export type AutomationMinAggregateOutputType = {
    id: string | null
    name: string | null
    namespace: string | null
    description: string | null
    keywords: string | null
    tags: string | null
    formSchema: string | null
    apiEndpoint: string | null
    templateId: string | null
    inventoryId: string | null
    instanceGroupId: string | null
    extraVars: string | null
    customBody: string | null
    pinned: boolean | null
    featured: boolean | null
    runs: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    namespace: string | null
    description: string | null
    keywords: string | null
    tags: string | null
    formSchema: string | null
    apiEndpoint: string | null
    templateId: string | null
    inventoryId: string | null
    instanceGroupId: string | null
    extraVars: string | null
    customBody: string | null
    pinned: boolean | null
    featured: boolean | null
    runs: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationCountAggregateOutputType = {
    id: number
    name: number
    namespace: number
    description: number
    keywords: number
    tags: number
    formSchema: number
    apiEndpoint: number
    templateId: number
    inventoryId: number
    instanceGroupId: number
    extraVars: number
    customBody: number
    pinned: number
    featured: number
    runs: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AutomationAvgAggregateInputType = {
    runs?: true
  }

  export type AutomationSumAggregateInputType = {
    runs?: true
  }

  export type AutomationMinAggregateInputType = {
    id?: true
    name?: true
    namespace?: true
    description?: true
    keywords?: true
    tags?: true
    formSchema?: true
    apiEndpoint?: true
    templateId?: true
    inventoryId?: true
    instanceGroupId?: true
    extraVars?: true
    customBody?: true
    pinned?: true
    featured?: true
    runs?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationMaxAggregateInputType = {
    id?: true
    name?: true
    namespace?: true
    description?: true
    keywords?: true
    tags?: true
    formSchema?: true
    apiEndpoint?: true
    templateId?: true
    inventoryId?: true
    instanceGroupId?: true
    extraVars?: true
    customBody?: true
    pinned?: true
    featured?: true
    runs?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationCountAggregateInputType = {
    id?: true
    name?: true
    namespace?: true
    description?: true
    keywords?: true
    tags?: true
    formSchema?: true
    apiEndpoint?: true
    templateId?: true
    inventoryId?: true
    instanceGroupId?: true
    extraVars?: true
    customBody?: true
    pinned?: true
    featured?: true
    runs?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AutomationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automation to aggregate.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Automations
    **/
    _count?: true | AutomationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutomationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutomationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationMaxAggregateInputType
  }

  export type GetAutomationAggregateType<T extends AutomationAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomation[P]>
      : GetScalarType<T[P], AggregateAutomation[P]>
  }




  export type AutomationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWhereInput
    orderBy?: AutomationOrderByWithAggregationInput | AutomationOrderByWithAggregationInput[]
    by: AutomationScalarFieldEnum[] | AutomationScalarFieldEnum
    having?: AutomationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationCountAggregateInputType | true
    _avg?: AutomationAvgAggregateInputType
    _sum?: AutomationSumAggregateInputType
    _min?: AutomationMinAggregateInputType
    _max?: AutomationMaxAggregateInputType
  }

  export type AutomationGroupByOutputType = {
    id: string
    name: string
    namespace: string
    description: string | null
    keywords: string | null
    tags: string | null
    formSchema: string
    apiEndpoint: string | null
    templateId: string
    inventoryId: string | null
    instanceGroupId: string | null
    extraVars: string | null
    customBody: string | null
    pinned: boolean
    featured: boolean
    runs: number
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: AutomationCountAggregateOutputType | null
    _avg: AutomationAvgAggregateOutputType | null
    _sum: AutomationSumAggregateOutputType | null
    _min: AutomationMinAggregateOutputType | null
    _max: AutomationMaxAggregateOutputType | null
  }

  type GetAutomationGroupByPayload<T extends AutomationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationGroupByOutputType[P]>
        }
      >
    >


  export type AutomationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    namespace?: boolean
    description?: boolean
    keywords?: boolean
    tags?: boolean
    formSchema?: boolean
    apiEndpoint?: boolean
    templateId?: boolean
    inventoryId?: boolean
    instanceGroupId?: boolean
    extraVars?: boolean
    customBody?: boolean
    pinned?: boolean
    featured?: boolean
    runs?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runs_history?: boolean | Automation$runs_historyArgs<ExtArgs>
    schedules?: boolean | Automation$schedulesArgs<ExtArgs>
    _count?: boolean | AutomationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automation"]>

  export type AutomationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    namespace?: boolean
    description?: boolean
    keywords?: boolean
    tags?: boolean
    formSchema?: boolean
    apiEndpoint?: boolean
    templateId?: boolean
    inventoryId?: boolean
    instanceGroupId?: boolean
    extraVars?: boolean
    customBody?: boolean
    pinned?: boolean
    featured?: boolean
    runs?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["automation"]>

  export type AutomationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    namespace?: boolean
    description?: boolean
    keywords?: boolean
    tags?: boolean
    formSchema?: boolean
    apiEndpoint?: boolean
    templateId?: boolean
    inventoryId?: boolean
    instanceGroupId?: boolean
    extraVars?: boolean
    customBody?: boolean
    pinned?: boolean
    featured?: boolean
    runs?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["automation"]>

  export type AutomationSelectScalar = {
    id?: boolean
    name?: boolean
    namespace?: boolean
    description?: boolean
    keywords?: boolean
    tags?: boolean
    formSchema?: boolean
    apiEndpoint?: boolean
    templateId?: boolean
    inventoryId?: boolean
    instanceGroupId?: boolean
    extraVars?: boolean
    customBody?: boolean
    pinned?: boolean
    featured?: boolean
    runs?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AutomationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "namespace" | "description" | "keywords" | "tags" | "formSchema" | "apiEndpoint" | "templateId" | "inventoryId" | "instanceGroupId" | "extraVars" | "customBody" | "pinned" | "featured" | "runs" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["automation"]>
  export type AutomationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runs_history?: boolean | Automation$runs_historyArgs<ExtArgs>
    schedules?: boolean | Automation$schedulesArgs<ExtArgs>
    _count?: boolean | AutomationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AutomationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AutomationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AutomationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Automation"
    objects: {
      runs_history: Prisma.$RunPayload<ExtArgs>[]
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      namespace: string
      description: string | null
      keywords: string | null
      tags: string | null
      formSchema: string
      apiEndpoint: string | null
      templateId: string
      inventoryId: string | null
      instanceGroupId: string | null
      extraVars: string | null
      customBody: string | null
      pinned: boolean
      featured: boolean
      runs: number
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["automation"]>
    composites: {}
  }

  type AutomationGetPayload<S extends boolean | null | undefined | AutomationDefaultArgs> = $Result.GetResult<Prisma.$AutomationPayload, S>

  type AutomationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutomationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutomationCountAggregateInputType | true
    }

  export interface AutomationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Automation'], meta: { name: 'Automation' } }
    /**
     * Find zero or one Automation that matches the filter.
     * @param {AutomationFindUniqueArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationFindUniqueArgs>(args: SelectSubset<T, AutomationFindUniqueArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Automation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutomationFindUniqueOrThrowArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Automation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindFirstArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationFindFirstArgs>(args?: SelectSubset<T, AutomationFindFirstArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Automation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindFirstOrThrowArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Automations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Automations
     * const automations = await prisma.automation.findMany()
     * 
     * // Get first 10 Automations
     * const automations = await prisma.automation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationWithIdOnly = await prisma.automation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationFindManyArgs>(args?: SelectSubset<T, AutomationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Automation.
     * @param {AutomationCreateArgs} args - Arguments to create a Automation.
     * @example
     * // Create one Automation
     * const Automation = await prisma.automation.create({
     *   data: {
     *     // ... data to create a Automation
     *   }
     * })
     * 
     */
    create<T extends AutomationCreateArgs>(args: SelectSubset<T, AutomationCreateArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Automations.
     * @param {AutomationCreateManyArgs} args - Arguments to create many Automations.
     * @example
     * // Create many Automations
     * const automation = await prisma.automation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationCreateManyArgs>(args?: SelectSubset<T, AutomationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Automations and returns the data saved in the database.
     * @param {AutomationCreateManyAndReturnArgs} args - Arguments to create many Automations.
     * @example
     * // Create many Automations
     * const automation = await prisma.automation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Automations and only return the `id`
     * const automationWithIdOnly = await prisma.automation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Automation.
     * @param {AutomationDeleteArgs} args - Arguments to delete one Automation.
     * @example
     * // Delete one Automation
     * const Automation = await prisma.automation.delete({
     *   where: {
     *     // ... filter to delete one Automation
     *   }
     * })
     * 
     */
    delete<T extends AutomationDeleteArgs>(args: SelectSubset<T, AutomationDeleteArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Automation.
     * @param {AutomationUpdateArgs} args - Arguments to update one Automation.
     * @example
     * // Update one Automation
     * const automation = await prisma.automation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationUpdateArgs>(args: SelectSubset<T, AutomationUpdateArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Automations.
     * @param {AutomationDeleteManyArgs} args - Arguments to filter Automations to delete.
     * @example
     * // Delete a few Automations
     * const { count } = await prisma.automation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationDeleteManyArgs>(args?: SelectSubset<T, AutomationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Automations
     * const automation = await prisma.automation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationUpdateManyArgs>(args: SelectSubset<T, AutomationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Automations and returns the data updated in the database.
     * @param {AutomationUpdateManyAndReturnArgs} args - Arguments to update many Automations.
     * @example
     * // Update many Automations
     * const automation = await prisma.automation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Automations and only return the `id`
     * const automationWithIdOnly = await prisma.automation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutomationUpdateManyAndReturnArgs>(args: SelectSubset<T, AutomationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Automation.
     * @param {AutomationUpsertArgs} args - Arguments to update or create a Automation.
     * @example
     * // Update or create a Automation
     * const automation = await prisma.automation.upsert({
     *   create: {
     *     // ... data to create a Automation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Automation we want to update
     *   }
     * })
     */
    upsert<T extends AutomationUpsertArgs>(args: SelectSubset<T, AutomationUpsertArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationCountArgs} args - Arguments to filter Automations to count.
     * @example
     * // Count the number of Automations
     * const count = await prisma.automation.count({
     *   where: {
     *     // ... the filter for the Automations we want to count
     *   }
     * })
    **/
    count<T extends AutomationCountArgs>(
      args?: Subset<T, AutomationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Automation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationAggregateArgs>(args: Subset<T, AutomationAggregateArgs>): Prisma.PrismaPromise<GetAutomationAggregateType<T>>

    /**
     * Group by Automation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationGroupByArgs['orderBy'] }
        : { orderBy?: AutomationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Automation model
   */
  readonly fields: AutomationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Automation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    runs_history<T extends Automation$runs_historyArgs<ExtArgs> = {}>(args?: Subset<T, Automation$runs_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedules<T extends Automation$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Automation$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Automation model
   */
  interface AutomationFieldRefs {
    readonly id: FieldRef<"Automation", 'String'>
    readonly name: FieldRef<"Automation", 'String'>
    readonly namespace: FieldRef<"Automation", 'String'>
    readonly description: FieldRef<"Automation", 'String'>
    readonly keywords: FieldRef<"Automation", 'String'>
    readonly tags: FieldRef<"Automation", 'String'>
    readonly formSchema: FieldRef<"Automation", 'String'>
    readonly apiEndpoint: FieldRef<"Automation", 'String'>
    readonly templateId: FieldRef<"Automation", 'String'>
    readonly inventoryId: FieldRef<"Automation", 'String'>
    readonly instanceGroupId: FieldRef<"Automation", 'String'>
    readonly extraVars: FieldRef<"Automation", 'String'>
    readonly customBody: FieldRef<"Automation", 'String'>
    readonly pinned: FieldRef<"Automation", 'Boolean'>
    readonly featured: FieldRef<"Automation", 'Boolean'>
    readonly runs: FieldRef<"Automation", 'Int'>
    readonly createdBy: FieldRef<"Automation", 'String'>
    readonly createdAt: FieldRef<"Automation", 'DateTime'>
    readonly updatedAt: FieldRef<"Automation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Automation findUnique
   */
  export type AutomationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation findUniqueOrThrow
   */
  export type AutomationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation findFirst
   */
  export type AutomationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation findFirstOrThrow
   */
  export type AutomationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation findMany
   */
  export type AutomationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automations to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation create
   */
  export type AutomationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The data needed to create a Automation.
     */
    data: XOR<AutomationCreateInput, AutomationUncheckedCreateInput>
  }

  /**
   * Automation createMany
   */
  export type AutomationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Automations.
     */
    data: AutomationCreateManyInput | AutomationCreateManyInput[]
  }

  /**
   * Automation createManyAndReturn
   */
  export type AutomationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * The data used to create many Automations.
     */
    data: AutomationCreateManyInput | AutomationCreateManyInput[]
  }

  /**
   * Automation update
   */
  export type AutomationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The data needed to update a Automation.
     */
    data: XOR<AutomationUpdateInput, AutomationUncheckedUpdateInput>
    /**
     * Choose, which Automation to update.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation updateMany
   */
  export type AutomationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Automations.
     */
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyInput>
    /**
     * Filter which Automations to update
     */
    where?: AutomationWhereInput
    /**
     * Limit how many Automations to update.
     */
    limit?: number
  }

  /**
   * Automation updateManyAndReturn
   */
  export type AutomationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * The data used to update Automations.
     */
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyInput>
    /**
     * Filter which Automations to update
     */
    where?: AutomationWhereInput
    /**
     * Limit how many Automations to update.
     */
    limit?: number
  }

  /**
   * Automation upsert
   */
  export type AutomationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The filter to search for the Automation to update in case it exists.
     */
    where: AutomationWhereUniqueInput
    /**
     * In case the Automation found by the `where` argument doesn't exist, create a new Automation with this data.
     */
    create: XOR<AutomationCreateInput, AutomationUncheckedCreateInput>
    /**
     * In case the Automation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationUpdateInput, AutomationUncheckedUpdateInput>
  }

  /**
   * Automation delete
   */
  export type AutomationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter which Automation to delete.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation deleteMany
   */
  export type AutomationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automations to delete
     */
    where?: AutomationWhereInput
    /**
     * Limit how many Automations to delete.
     */
    limit?: number
  }

  /**
   * Automation.runs_history
   */
  export type Automation$runs_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    where?: RunWhereInput
    orderBy?: RunOrderByWithRelationInput | RunOrderByWithRelationInput[]
    cursor?: RunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunScalarFieldEnum | RunScalarFieldEnum[]
  }

  /**
   * Automation.schedules
   */
  export type Automation$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Automation without action
   */
  export type AutomationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
  }


  /**
   * Model Run
   */

  export type AggregateRun = {
    _count: RunCountAggregateOutputType | null
    _min: RunMinAggregateOutputType | null
    _max: RunMaxAggregateOutputType | null
  }

  export type RunMinAggregateOutputType = {
    id: string | null
    automationId: string | null
    status: string | null
    uniqueId: string | null
    parameters: string | null
    result: string | null
    artifacts: string | null
    errorMessage: string | null
    executedBy: string | null
    startedAt: Date | null
    completedAt: Date | null
    awxJobId: string | null
  }

  export type RunMaxAggregateOutputType = {
    id: string | null
    automationId: string | null
    status: string | null
    uniqueId: string | null
    parameters: string | null
    result: string | null
    artifacts: string | null
    errorMessage: string | null
    executedBy: string | null
    startedAt: Date | null
    completedAt: Date | null
    awxJobId: string | null
  }

  export type RunCountAggregateOutputType = {
    id: number
    automationId: number
    status: number
    uniqueId: number
    parameters: number
    result: number
    artifacts: number
    errorMessage: number
    executedBy: number
    startedAt: number
    completedAt: number
    awxJobId: number
    _all: number
  }


  export type RunMinAggregateInputType = {
    id?: true
    automationId?: true
    status?: true
    uniqueId?: true
    parameters?: true
    result?: true
    artifacts?: true
    errorMessage?: true
    executedBy?: true
    startedAt?: true
    completedAt?: true
    awxJobId?: true
  }

  export type RunMaxAggregateInputType = {
    id?: true
    automationId?: true
    status?: true
    uniqueId?: true
    parameters?: true
    result?: true
    artifacts?: true
    errorMessage?: true
    executedBy?: true
    startedAt?: true
    completedAt?: true
    awxJobId?: true
  }

  export type RunCountAggregateInputType = {
    id?: true
    automationId?: true
    status?: true
    uniqueId?: true
    parameters?: true
    result?: true
    artifacts?: true
    errorMessage?: true
    executedBy?: true
    startedAt?: true
    completedAt?: true
    awxJobId?: true
    _all?: true
  }

  export type RunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Run to aggregate.
     */
    where?: RunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Runs to fetch.
     */
    orderBy?: RunOrderByWithRelationInput | RunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Runs
    **/
    _count?: true | RunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunMaxAggregateInputType
  }

  export type GetRunAggregateType<T extends RunAggregateArgs> = {
        [P in keyof T & keyof AggregateRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRun[P]>
      : GetScalarType<T[P], AggregateRun[P]>
  }




  export type RunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunWhereInput
    orderBy?: RunOrderByWithAggregationInput | RunOrderByWithAggregationInput[]
    by: RunScalarFieldEnum[] | RunScalarFieldEnum
    having?: RunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCountAggregateInputType | true
    _min?: RunMinAggregateInputType
    _max?: RunMaxAggregateInputType
  }

  export type RunGroupByOutputType = {
    id: string
    automationId: string
    status: string
    uniqueId: string | null
    parameters: string | null
    result: string | null
    artifacts: string | null
    errorMessage: string | null
    executedBy: string | null
    startedAt: Date
    completedAt: Date | null
    awxJobId: string | null
    _count: RunCountAggregateOutputType | null
    _min: RunMinAggregateOutputType | null
    _max: RunMaxAggregateOutputType | null
  }

  type GetRunGroupByPayload<T extends RunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunGroupByOutputType[P]>
            : GetScalarType<T[P], RunGroupByOutputType[P]>
        }
      >
    >


  export type RunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    automationId?: boolean
    status?: boolean
    uniqueId?: boolean
    parameters?: boolean
    result?: boolean
    artifacts?: boolean
    errorMessage?: boolean
    executedBy?: boolean
    startedAt?: boolean
    completedAt?: boolean
    awxJobId?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["run"]>

  export type RunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    automationId?: boolean
    status?: boolean
    uniqueId?: boolean
    parameters?: boolean
    result?: boolean
    artifacts?: boolean
    errorMessage?: boolean
    executedBy?: boolean
    startedAt?: boolean
    completedAt?: boolean
    awxJobId?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["run"]>

  export type RunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    automationId?: boolean
    status?: boolean
    uniqueId?: boolean
    parameters?: boolean
    result?: boolean
    artifacts?: boolean
    errorMessage?: boolean
    executedBy?: boolean
    startedAt?: boolean
    completedAt?: boolean
    awxJobId?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["run"]>

  export type RunSelectScalar = {
    id?: boolean
    automationId?: boolean
    status?: boolean
    uniqueId?: boolean
    parameters?: boolean
    result?: boolean
    artifacts?: boolean
    errorMessage?: boolean
    executedBy?: boolean
    startedAt?: boolean
    completedAt?: boolean
    awxJobId?: boolean
  }

  export type RunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "automationId" | "status" | "uniqueId" | "parameters" | "result" | "artifacts" | "errorMessage" | "executedBy" | "startedAt" | "completedAt" | "awxJobId", ExtArgs["result"]["run"]>
  export type RunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }
  export type RunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }
  export type RunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }

  export type $RunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Run"
    objects: {
      automation: Prisma.$AutomationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      automationId: string
      status: string
      uniqueId: string | null
      parameters: string | null
      result: string | null
      artifacts: string | null
      errorMessage: string | null
      executedBy: string | null
      startedAt: Date
      completedAt: Date | null
      awxJobId: string | null
    }, ExtArgs["result"]["run"]>
    composites: {}
  }

  type RunGetPayload<S extends boolean | null | undefined | RunDefaultArgs> = $Result.GetResult<Prisma.$RunPayload, S>

  type RunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCountAggregateInputType | true
    }

  export interface RunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Run'], meta: { name: 'Run' } }
    /**
     * Find zero or one Run that matches the filter.
     * @param {RunFindUniqueArgs} args - Arguments to find a Run
     * @example
     * // Get one Run
     * const run = await prisma.run.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunFindUniqueArgs>(args: SelectSubset<T, RunFindUniqueArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Run that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunFindUniqueOrThrowArgs} args - Arguments to find a Run
     * @example
     * // Get one Run
     * const run = await prisma.run.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunFindUniqueOrThrowArgs>(args: SelectSubset<T, RunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Run that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunFindFirstArgs} args - Arguments to find a Run
     * @example
     * // Get one Run
     * const run = await prisma.run.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunFindFirstArgs>(args?: SelectSubset<T, RunFindFirstArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Run that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunFindFirstOrThrowArgs} args - Arguments to find a Run
     * @example
     * // Get one Run
     * const run = await prisma.run.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunFindFirstOrThrowArgs>(args?: SelectSubset<T, RunFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Runs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Runs
     * const runs = await prisma.run.findMany()
     * 
     * // Get first 10 Runs
     * const runs = await prisma.run.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runWithIdOnly = await prisma.run.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunFindManyArgs>(args?: SelectSubset<T, RunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Run.
     * @param {RunCreateArgs} args - Arguments to create a Run.
     * @example
     * // Create one Run
     * const Run = await prisma.run.create({
     *   data: {
     *     // ... data to create a Run
     *   }
     * })
     * 
     */
    create<T extends RunCreateArgs>(args: SelectSubset<T, RunCreateArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Runs.
     * @param {RunCreateManyArgs} args - Arguments to create many Runs.
     * @example
     * // Create many Runs
     * const run = await prisma.run.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCreateManyArgs>(args?: SelectSubset<T, RunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Runs and returns the data saved in the database.
     * @param {RunCreateManyAndReturnArgs} args - Arguments to create many Runs.
     * @example
     * // Create many Runs
     * const run = await prisma.run.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Runs and only return the `id`
     * const runWithIdOnly = await prisma.run.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Run.
     * @param {RunDeleteArgs} args - Arguments to delete one Run.
     * @example
     * // Delete one Run
     * const Run = await prisma.run.delete({
     *   where: {
     *     // ... filter to delete one Run
     *   }
     * })
     * 
     */
    delete<T extends RunDeleteArgs>(args: SelectSubset<T, RunDeleteArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Run.
     * @param {RunUpdateArgs} args - Arguments to update one Run.
     * @example
     * // Update one Run
     * const run = await prisma.run.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunUpdateArgs>(args: SelectSubset<T, RunUpdateArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Runs.
     * @param {RunDeleteManyArgs} args - Arguments to filter Runs to delete.
     * @example
     * // Delete a few Runs
     * const { count } = await prisma.run.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunDeleteManyArgs>(args?: SelectSubset<T, RunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Runs
     * const run = await prisma.run.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunUpdateManyArgs>(args: SelectSubset<T, RunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Runs and returns the data updated in the database.
     * @param {RunUpdateManyAndReturnArgs} args - Arguments to update many Runs.
     * @example
     * // Update many Runs
     * const run = await prisma.run.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Runs and only return the `id`
     * const runWithIdOnly = await prisma.run.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunUpdateManyAndReturnArgs>(args: SelectSubset<T, RunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Run.
     * @param {RunUpsertArgs} args - Arguments to update or create a Run.
     * @example
     * // Update or create a Run
     * const run = await prisma.run.upsert({
     *   create: {
     *     // ... data to create a Run
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Run we want to update
     *   }
     * })
     */
    upsert<T extends RunUpsertArgs>(args: SelectSubset<T, RunUpsertArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCountArgs} args - Arguments to filter Runs to count.
     * @example
     * // Count the number of Runs
     * const count = await prisma.run.count({
     *   where: {
     *     // ... the filter for the Runs we want to count
     *   }
     * })
    **/
    count<T extends RunCountArgs>(
      args?: Subset<T, RunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Run.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunAggregateArgs>(args: Subset<T, RunAggregateArgs>): Prisma.PrismaPromise<GetRunAggregateType<T>>

    /**
     * Group by Run.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunGroupByArgs['orderBy'] }
        : { orderBy?: RunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Run model
   */
  readonly fields: RunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Run.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    automation<T extends AutomationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationDefaultArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Run model
   */
  interface RunFieldRefs {
    readonly id: FieldRef<"Run", 'String'>
    readonly automationId: FieldRef<"Run", 'String'>
    readonly status: FieldRef<"Run", 'String'>
    readonly uniqueId: FieldRef<"Run", 'String'>
    readonly parameters: FieldRef<"Run", 'String'>
    readonly result: FieldRef<"Run", 'String'>
    readonly artifacts: FieldRef<"Run", 'String'>
    readonly errorMessage: FieldRef<"Run", 'String'>
    readonly executedBy: FieldRef<"Run", 'String'>
    readonly startedAt: FieldRef<"Run", 'DateTime'>
    readonly completedAt: FieldRef<"Run", 'DateTime'>
    readonly awxJobId: FieldRef<"Run", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Run findUnique
   */
  export type RunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * Filter, which Run to fetch.
     */
    where: RunWhereUniqueInput
  }

  /**
   * Run findUniqueOrThrow
   */
  export type RunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * Filter, which Run to fetch.
     */
    where: RunWhereUniqueInput
  }

  /**
   * Run findFirst
   */
  export type RunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * Filter, which Run to fetch.
     */
    where?: RunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Runs to fetch.
     */
    orderBy?: RunOrderByWithRelationInput | RunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Runs.
     */
    cursor?: RunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Runs.
     */
    distinct?: RunScalarFieldEnum | RunScalarFieldEnum[]
  }

  /**
   * Run findFirstOrThrow
   */
  export type RunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * Filter, which Run to fetch.
     */
    where?: RunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Runs to fetch.
     */
    orderBy?: RunOrderByWithRelationInput | RunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Runs.
     */
    cursor?: RunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Runs.
     */
    distinct?: RunScalarFieldEnum | RunScalarFieldEnum[]
  }

  /**
   * Run findMany
   */
  export type RunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * Filter, which Runs to fetch.
     */
    where?: RunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Runs to fetch.
     */
    orderBy?: RunOrderByWithRelationInput | RunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Runs.
     */
    cursor?: RunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Runs.
     */
    skip?: number
    distinct?: RunScalarFieldEnum | RunScalarFieldEnum[]
  }

  /**
   * Run create
   */
  export type RunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * The data needed to create a Run.
     */
    data: XOR<RunCreateInput, RunUncheckedCreateInput>
  }

  /**
   * Run createMany
   */
  export type RunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Runs.
     */
    data: RunCreateManyInput | RunCreateManyInput[]
  }

  /**
   * Run createManyAndReturn
   */
  export type RunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * The data used to create many Runs.
     */
    data: RunCreateManyInput | RunCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Run update
   */
  export type RunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * The data needed to update a Run.
     */
    data: XOR<RunUpdateInput, RunUncheckedUpdateInput>
    /**
     * Choose, which Run to update.
     */
    where: RunWhereUniqueInput
  }

  /**
   * Run updateMany
   */
  export type RunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Runs.
     */
    data: XOR<RunUpdateManyMutationInput, RunUncheckedUpdateManyInput>
    /**
     * Filter which Runs to update
     */
    where?: RunWhereInput
    /**
     * Limit how many Runs to update.
     */
    limit?: number
  }

  /**
   * Run updateManyAndReturn
   */
  export type RunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * The data used to update Runs.
     */
    data: XOR<RunUpdateManyMutationInput, RunUncheckedUpdateManyInput>
    /**
     * Filter which Runs to update
     */
    where?: RunWhereInput
    /**
     * Limit how many Runs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Run upsert
   */
  export type RunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * The filter to search for the Run to update in case it exists.
     */
    where: RunWhereUniqueInput
    /**
     * In case the Run found by the `where` argument doesn't exist, create a new Run with this data.
     */
    create: XOR<RunCreateInput, RunUncheckedCreateInput>
    /**
     * In case the Run was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunUpdateInput, RunUncheckedUpdateInput>
  }

  /**
   * Run delete
   */
  export type RunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * Filter which Run to delete.
     */
    where: RunWhereUniqueInput
  }

  /**
   * Run deleteMany
   */
  export type RunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Runs to delete
     */
    where?: RunWhereInput
    /**
     * Limit how many Runs to delete.
     */
    limit?: number
  }

  /**
   * Run without action
   */
  export type RunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: string | null
    name: string | null
    automationId: string | null
    frequency: string | null
    cron: string | null
    parameters: string | null
    status: string | null
    nextRun: Date | null
    lastRun: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    automationId: string | null
    frequency: string | null
    cron: string | null
    parameters: string | null
    status: string | null
    nextRun: Date | null
    lastRun: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    name: number
    automationId: number
    frequency: number
    cron: number
    parameters: number
    status: number
    nextRun: number
    lastRun: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleMinAggregateInputType = {
    id?: true
    name?: true
    automationId?: true
    frequency?: true
    cron?: true
    parameters?: true
    status?: true
    nextRun?: true
    lastRun?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    name?: true
    automationId?: true
    frequency?: true
    cron?: true
    parameters?: true
    status?: true
    nextRun?: true
    lastRun?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    name?: true
    automationId?: true
    frequency?: true
    cron?: true
    parameters?: true
    status?: true
    nextRun?: true
    lastRun?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: string
    name: string
    automationId: string
    frequency: string
    cron: string
    parameters: string | null
    status: string
    nextRun: Date | null
    lastRun: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    automationId?: boolean
    frequency?: boolean
    cron?: boolean
    parameters?: boolean
    status?: boolean
    nextRun?: boolean
    lastRun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    automationId?: boolean
    frequency?: boolean
    cron?: boolean
    parameters?: boolean
    status?: boolean
    nextRun?: boolean
    lastRun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    automationId?: boolean
    frequency?: boolean
    cron?: boolean
    parameters?: boolean
    status?: boolean
    nextRun?: boolean
    lastRun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectScalar = {
    id?: boolean
    name?: boolean
    automationId?: boolean
    frequency?: boolean
    cron?: boolean
    parameters?: boolean
    status?: boolean
    nextRun?: boolean
    lastRun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "automationId" | "frequency" | "cron" | "parameters" | "status" | "nextRun" | "lastRun" | "createdAt" | "updatedAt", ExtArgs["result"]["schedule"]>
  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      automation: Prisma.$AutomationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      automationId: string
      frequency: string
      cron: string
      parameters: string | null
      status: string
      nextRun: Date | null
      lastRun: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {ScheduleCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules and returns the data updated in the database.
     * @param {ScheduleUpdateManyAndReturnArgs} args - Arguments to update many Schedules.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    automation<T extends AutomationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationDefaultArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'String'>
    readonly name: FieldRef<"Schedule", 'String'>
    readonly automationId: FieldRef<"Schedule", 'String'>
    readonly frequency: FieldRef<"Schedule", 'String'>
    readonly cron: FieldRef<"Schedule", 'String'>
    readonly parameters: FieldRef<"Schedule", 'String'>
    readonly status: FieldRef<"Schedule", 'String'>
    readonly nextRun: FieldRef<"Schedule", 'DateTime'>
    readonly lastRun: FieldRef<"Schedule", 'DateTime'>
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
  }

  /**
   * Schedule createManyAndReturn
   */
  export type ScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedule updateManyAndReturn
   */
  export type ScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    title: number
    message: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: string
    title: string
    message: string
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "message" | "read" | "createdAt", ExtArgs["result"]["notification"]>

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      title: string
      message: string
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
  }


  /**
   * Model ConnectivityCheck
   */

  export type AggregateConnectivityCheck = {
    _count: ConnectivityCheckCountAggregateOutputType | null
    _min: ConnectivityCheckMinAggregateOutputType | null
    _max: ConnectivityCheckMaxAggregateOutputType | null
  }

  export type ConnectivityCheckMinAggregateOutputType = {
    id: string | null
    servers: string | null
    ports: string | null
    email: string | null
    status: string | null
    results: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type ConnectivityCheckMaxAggregateOutputType = {
    id: string | null
    servers: string | null
    ports: string | null
    email: string | null
    status: string | null
    results: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type ConnectivityCheckCountAggregateOutputType = {
    id: number
    servers: number
    ports: number
    email: number
    status: number
    results: number
    createdAt: number
    completedAt: number
    _all: number
  }


  export type ConnectivityCheckMinAggregateInputType = {
    id?: true
    servers?: true
    ports?: true
    email?: true
    status?: true
    results?: true
    createdAt?: true
    completedAt?: true
  }

  export type ConnectivityCheckMaxAggregateInputType = {
    id?: true
    servers?: true
    ports?: true
    email?: true
    status?: true
    results?: true
    createdAt?: true
    completedAt?: true
  }

  export type ConnectivityCheckCountAggregateInputType = {
    id?: true
    servers?: true
    ports?: true
    email?: true
    status?: true
    results?: true
    createdAt?: true
    completedAt?: true
    _all?: true
  }

  export type ConnectivityCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConnectivityCheck to aggregate.
     */
    where?: ConnectivityCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectivityChecks to fetch.
     */
    orderBy?: ConnectivityCheckOrderByWithRelationInput | ConnectivityCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConnectivityCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectivityChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectivityChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConnectivityChecks
    **/
    _count?: true | ConnectivityCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConnectivityCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConnectivityCheckMaxAggregateInputType
  }

  export type GetConnectivityCheckAggregateType<T extends ConnectivityCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateConnectivityCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConnectivityCheck[P]>
      : GetScalarType<T[P], AggregateConnectivityCheck[P]>
  }




  export type ConnectivityCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectivityCheckWhereInput
    orderBy?: ConnectivityCheckOrderByWithAggregationInput | ConnectivityCheckOrderByWithAggregationInput[]
    by: ConnectivityCheckScalarFieldEnum[] | ConnectivityCheckScalarFieldEnum
    having?: ConnectivityCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConnectivityCheckCountAggregateInputType | true
    _min?: ConnectivityCheckMinAggregateInputType
    _max?: ConnectivityCheckMaxAggregateInputType
  }

  export type ConnectivityCheckGroupByOutputType = {
    id: string
    servers: string
    ports: string
    email: string
    status: string
    results: string | null
    createdAt: Date
    completedAt: Date | null
    _count: ConnectivityCheckCountAggregateOutputType | null
    _min: ConnectivityCheckMinAggregateOutputType | null
    _max: ConnectivityCheckMaxAggregateOutputType | null
  }

  type GetConnectivityCheckGroupByPayload<T extends ConnectivityCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConnectivityCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConnectivityCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConnectivityCheckGroupByOutputType[P]>
            : GetScalarType<T[P], ConnectivityCheckGroupByOutputType[P]>
        }
      >
    >


  export type ConnectivityCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servers?: boolean
    ports?: boolean
    email?: boolean
    status?: boolean
    results?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["connectivityCheck"]>

  export type ConnectivityCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servers?: boolean
    ports?: boolean
    email?: boolean
    status?: boolean
    results?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["connectivityCheck"]>

  export type ConnectivityCheckSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servers?: boolean
    ports?: boolean
    email?: boolean
    status?: boolean
    results?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["connectivityCheck"]>

  export type ConnectivityCheckSelectScalar = {
    id?: boolean
    servers?: boolean
    ports?: boolean
    email?: boolean
    status?: boolean
    results?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }

  export type ConnectivityCheckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "servers" | "ports" | "email" | "status" | "results" | "createdAt" | "completedAt", ExtArgs["result"]["connectivityCheck"]>

  export type $ConnectivityCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConnectivityCheck"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      servers: string
      ports: string
      email: string
      status: string
      results: string | null
      createdAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["connectivityCheck"]>
    composites: {}
  }

  type ConnectivityCheckGetPayload<S extends boolean | null | undefined | ConnectivityCheckDefaultArgs> = $Result.GetResult<Prisma.$ConnectivityCheckPayload, S>

  type ConnectivityCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConnectivityCheckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConnectivityCheckCountAggregateInputType | true
    }

  export interface ConnectivityCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConnectivityCheck'], meta: { name: 'ConnectivityCheck' } }
    /**
     * Find zero or one ConnectivityCheck that matches the filter.
     * @param {ConnectivityCheckFindUniqueArgs} args - Arguments to find a ConnectivityCheck
     * @example
     * // Get one ConnectivityCheck
     * const connectivityCheck = await prisma.connectivityCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConnectivityCheckFindUniqueArgs>(args: SelectSubset<T, ConnectivityCheckFindUniqueArgs<ExtArgs>>): Prisma__ConnectivityCheckClient<$Result.GetResult<Prisma.$ConnectivityCheckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConnectivityCheck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConnectivityCheckFindUniqueOrThrowArgs} args - Arguments to find a ConnectivityCheck
     * @example
     * // Get one ConnectivityCheck
     * const connectivityCheck = await prisma.connectivityCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConnectivityCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, ConnectivityCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConnectivityCheckClient<$Result.GetResult<Prisma.$ConnectivityCheckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConnectivityCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectivityCheckFindFirstArgs} args - Arguments to find a ConnectivityCheck
     * @example
     * // Get one ConnectivityCheck
     * const connectivityCheck = await prisma.connectivityCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConnectivityCheckFindFirstArgs>(args?: SelectSubset<T, ConnectivityCheckFindFirstArgs<ExtArgs>>): Prisma__ConnectivityCheckClient<$Result.GetResult<Prisma.$ConnectivityCheckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConnectivityCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectivityCheckFindFirstOrThrowArgs} args - Arguments to find a ConnectivityCheck
     * @example
     * // Get one ConnectivityCheck
     * const connectivityCheck = await prisma.connectivityCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConnectivityCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, ConnectivityCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConnectivityCheckClient<$Result.GetResult<Prisma.$ConnectivityCheckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConnectivityChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectivityCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConnectivityChecks
     * const connectivityChecks = await prisma.connectivityCheck.findMany()
     * 
     * // Get first 10 ConnectivityChecks
     * const connectivityChecks = await prisma.connectivityCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const connectivityCheckWithIdOnly = await prisma.connectivityCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConnectivityCheckFindManyArgs>(args?: SelectSubset<T, ConnectivityCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectivityCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConnectivityCheck.
     * @param {ConnectivityCheckCreateArgs} args - Arguments to create a ConnectivityCheck.
     * @example
     * // Create one ConnectivityCheck
     * const ConnectivityCheck = await prisma.connectivityCheck.create({
     *   data: {
     *     // ... data to create a ConnectivityCheck
     *   }
     * })
     * 
     */
    create<T extends ConnectivityCheckCreateArgs>(args: SelectSubset<T, ConnectivityCheckCreateArgs<ExtArgs>>): Prisma__ConnectivityCheckClient<$Result.GetResult<Prisma.$ConnectivityCheckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConnectivityChecks.
     * @param {ConnectivityCheckCreateManyArgs} args - Arguments to create many ConnectivityChecks.
     * @example
     * // Create many ConnectivityChecks
     * const connectivityCheck = await prisma.connectivityCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConnectivityCheckCreateManyArgs>(args?: SelectSubset<T, ConnectivityCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConnectivityChecks and returns the data saved in the database.
     * @param {ConnectivityCheckCreateManyAndReturnArgs} args - Arguments to create many ConnectivityChecks.
     * @example
     * // Create many ConnectivityChecks
     * const connectivityCheck = await prisma.connectivityCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConnectivityChecks and only return the `id`
     * const connectivityCheckWithIdOnly = await prisma.connectivityCheck.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConnectivityCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, ConnectivityCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectivityCheckPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConnectivityCheck.
     * @param {ConnectivityCheckDeleteArgs} args - Arguments to delete one ConnectivityCheck.
     * @example
     * // Delete one ConnectivityCheck
     * const ConnectivityCheck = await prisma.connectivityCheck.delete({
     *   where: {
     *     // ... filter to delete one ConnectivityCheck
     *   }
     * })
     * 
     */
    delete<T extends ConnectivityCheckDeleteArgs>(args: SelectSubset<T, ConnectivityCheckDeleteArgs<ExtArgs>>): Prisma__ConnectivityCheckClient<$Result.GetResult<Prisma.$ConnectivityCheckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConnectivityCheck.
     * @param {ConnectivityCheckUpdateArgs} args - Arguments to update one ConnectivityCheck.
     * @example
     * // Update one ConnectivityCheck
     * const connectivityCheck = await prisma.connectivityCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConnectivityCheckUpdateArgs>(args: SelectSubset<T, ConnectivityCheckUpdateArgs<ExtArgs>>): Prisma__ConnectivityCheckClient<$Result.GetResult<Prisma.$ConnectivityCheckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConnectivityChecks.
     * @param {ConnectivityCheckDeleteManyArgs} args - Arguments to filter ConnectivityChecks to delete.
     * @example
     * // Delete a few ConnectivityChecks
     * const { count } = await prisma.connectivityCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConnectivityCheckDeleteManyArgs>(args?: SelectSubset<T, ConnectivityCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConnectivityChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectivityCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConnectivityChecks
     * const connectivityCheck = await prisma.connectivityCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConnectivityCheckUpdateManyArgs>(args: SelectSubset<T, ConnectivityCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConnectivityChecks and returns the data updated in the database.
     * @param {ConnectivityCheckUpdateManyAndReturnArgs} args - Arguments to update many ConnectivityChecks.
     * @example
     * // Update many ConnectivityChecks
     * const connectivityCheck = await prisma.connectivityCheck.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConnectivityChecks and only return the `id`
     * const connectivityCheckWithIdOnly = await prisma.connectivityCheck.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConnectivityCheckUpdateManyAndReturnArgs>(args: SelectSubset<T, ConnectivityCheckUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectivityCheckPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConnectivityCheck.
     * @param {ConnectivityCheckUpsertArgs} args - Arguments to update or create a ConnectivityCheck.
     * @example
     * // Update or create a ConnectivityCheck
     * const connectivityCheck = await prisma.connectivityCheck.upsert({
     *   create: {
     *     // ... data to create a ConnectivityCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConnectivityCheck we want to update
     *   }
     * })
     */
    upsert<T extends ConnectivityCheckUpsertArgs>(args: SelectSubset<T, ConnectivityCheckUpsertArgs<ExtArgs>>): Prisma__ConnectivityCheckClient<$Result.GetResult<Prisma.$ConnectivityCheckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConnectivityChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectivityCheckCountArgs} args - Arguments to filter ConnectivityChecks to count.
     * @example
     * // Count the number of ConnectivityChecks
     * const count = await prisma.connectivityCheck.count({
     *   where: {
     *     // ... the filter for the ConnectivityChecks we want to count
     *   }
     * })
    **/
    count<T extends ConnectivityCheckCountArgs>(
      args?: Subset<T, ConnectivityCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConnectivityCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConnectivityCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectivityCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConnectivityCheckAggregateArgs>(args: Subset<T, ConnectivityCheckAggregateArgs>): Prisma.PrismaPromise<GetConnectivityCheckAggregateType<T>>

    /**
     * Group by ConnectivityCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectivityCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConnectivityCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConnectivityCheckGroupByArgs['orderBy'] }
        : { orderBy?: ConnectivityCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConnectivityCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConnectivityCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConnectivityCheck model
   */
  readonly fields: ConnectivityCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConnectivityCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConnectivityCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConnectivityCheck model
   */
  interface ConnectivityCheckFieldRefs {
    readonly id: FieldRef<"ConnectivityCheck", 'String'>
    readonly servers: FieldRef<"ConnectivityCheck", 'String'>
    readonly ports: FieldRef<"ConnectivityCheck", 'String'>
    readonly email: FieldRef<"ConnectivityCheck", 'String'>
    readonly status: FieldRef<"ConnectivityCheck", 'String'>
    readonly results: FieldRef<"ConnectivityCheck", 'String'>
    readonly createdAt: FieldRef<"ConnectivityCheck", 'DateTime'>
    readonly completedAt: FieldRef<"ConnectivityCheck", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConnectivityCheck findUnique
   */
  export type ConnectivityCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityCheck
     */
    select?: ConnectivityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityCheck
     */
    omit?: ConnectivityCheckOmit<ExtArgs> | null
    /**
     * Filter, which ConnectivityCheck to fetch.
     */
    where: ConnectivityCheckWhereUniqueInput
  }

  /**
   * ConnectivityCheck findUniqueOrThrow
   */
  export type ConnectivityCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityCheck
     */
    select?: ConnectivityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityCheck
     */
    omit?: ConnectivityCheckOmit<ExtArgs> | null
    /**
     * Filter, which ConnectivityCheck to fetch.
     */
    where: ConnectivityCheckWhereUniqueInput
  }

  /**
   * ConnectivityCheck findFirst
   */
  export type ConnectivityCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityCheck
     */
    select?: ConnectivityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityCheck
     */
    omit?: ConnectivityCheckOmit<ExtArgs> | null
    /**
     * Filter, which ConnectivityCheck to fetch.
     */
    where?: ConnectivityCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectivityChecks to fetch.
     */
    orderBy?: ConnectivityCheckOrderByWithRelationInput | ConnectivityCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConnectivityChecks.
     */
    cursor?: ConnectivityCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectivityChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectivityChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConnectivityChecks.
     */
    distinct?: ConnectivityCheckScalarFieldEnum | ConnectivityCheckScalarFieldEnum[]
  }

  /**
   * ConnectivityCheck findFirstOrThrow
   */
  export type ConnectivityCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityCheck
     */
    select?: ConnectivityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityCheck
     */
    omit?: ConnectivityCheckOmit<ExtArgs> | null
    /**
     * Filter, which ConnectivityCheck to fetch.
     */
    where?: ConnectivityCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectivityChecks to fetch.
     */
    orderBy?: ConnectivityCheckOrderByWithRelationInput | ConnectivityCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConnectivityChecks.
     */
    cursor?: ConnectivityCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectivityChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectivityChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConnectivityChecks.
     */
    distinct?: ConnectivityCheckScalarFieldEnum | ConnectivityCheckScalarFieldEnum[]
  }

  /**
   * ConnectivityCheck findMany
   */
  export type ConnectivityCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityCheck
     */
    select?: ConnectivityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityCheck
     */
    omit?: ConnectivityCheckOmit<ExtArgs> | null
    /**
     * Filter, which ConnectivityChecks to fetch.
     */
    where?: ConnectivityCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectivityChecks to fetch.
     */
    orderBy?: ConnectivityCheckOrderByWithRelationInput | ConnectivityCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConnectivityChecks.
     */
    cursor?: ConnectivityCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectivityChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectivityChecks.
     */
    skip?: number
    distinct?: ConnectivityCheckScalarFieldEnum | ConnectivityCheckScalarFieldEnum[]
  }

  /**
   * ConnectivityCheck create
   */
  export type ConnectivityCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityCheck
     */
    select?: ConnectivityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityCheck
     */
    omit?: ConnectivityCheckOmit<ExtArgs> | null
    /**
     * The data needed to create a ConnectivityCheck.
     */
    data: XOR<ConnectivityCheckCreateInput, ConnectivityCheckUncheckedCreateInput>
  }

  /**
   * ConnectivityCheck createMany
   */
  export type ConnectivityCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConnectivityChecks.
     */
    data: ConnectivityCheckCreateManyInput | ConnectivityCheckCreateManyInput[]
  }

  /**
   * ConnectivityCheck createManyAndReturn
   */
  export type ConnectivityCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityCheck
     */
    select?: ConnectivityCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityCheck
     */
    omit?: ConnectivityCheckOmit<ExtArgs> | null
    /**
     * The data used to create many ConnectivityChecks.
     */
    data: ConnectivityCheckCreateManyInput | ConnectivityCheckCreateManyInput[]
  }

  /**
   * ConnectivityCheck update
   */
  export type ConnectivityCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityCheck
     */
    select?: ConnectivityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityCheck
     */
    omit?: ConnectivityCheckOmit<ExtArgs> | null
    /**
     * The data needed to update a ConnectivityCheck.
     */
    data: XOR<ConnectivityCheckUpdateInput, ConnectivityCheckUncheckedUpdateInput>
    /**
     * Choose, which ConnectivityCheck to update.
     */
    where: ConnectivityCheckWhereUniqueInput
  }

  /**
   * ConnectivityCheck updateMany
   */
  export type ConnectivityCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConnectivityChecks.
     */
    data: XOR<ConnectivityCheckUpdateManyMutationInput, ConnectivityCheckUncheckedUpdateManyInput>
    /**
     * Filter which ConnectivityChecks to update
     */
    where?: ConnectivityCheckWhereInput
    /**
     * Limit how many ConnectivityChecks to update.
     */
    limit?: number
  }

  /**
   * ConnectivityCheck updateManyAndReturn
   */
  export type ConnectivityCheckUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityCheck
     */
    select?: ConnectivityCheckSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityCheck
     */
    omit?: ConnectivityCheckOmit<ExtArgs> | null
    /**
     * The data used to update ConnectivityChecks.
     */
    data: XOR<ConnectivityCheckUpdateManyMutationInput, ConnectivityCheckUncheckedUpdateManyInput>
    /**
     * Filter which ConnectivityChecks to update
     */
    where?: ConnectivityCheckWhereInput
    /**
     * Limit how many ConnectivityChecks to update.
     */
    limit?: number
  }

  /**
   * ConnectivityCheck upsert
   */
  export type ConnectivityCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityCheck
     */
    select?: ConnectivityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityCheck
     */
    omit?: ConnectivityCheckOmit<ExtArgs> | null
    /**
     * The filter to search for the ConnectivityCheck to update in case it exists.
     */
    where: ConnectivityCheckWhereUniqueInput
    /**
     * In case the ConnectivityCheck found by the `where` argument doesn't exist, create a new ConnectivityCheck with this data.
     */
    create: XOR<ConnectivityCheckCreateInput, ConnectivityCheckUncheckedCreateInput>
    /**
     * In case the ConnectivityCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConnectivityCheckUpdateInput, ConnectivityCheckUncheckedUpdateInput>
  }

  /**
   * ConnectivityCheck delete
   */
  export type ConnectivityCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityCheck
     */
    select?: ConnectivityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityCheck
     */
    omit?: ConnectivityCheckOmit<ExtArgs> | null
    /**
     * Filter which ConnectivityCheck to delete.
     */
    where: ConnectivityCheckWhereUniqueInput
  }

  /**
   * ConnectivityCheck deleteMany
   */
  export type ConnectivityCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConnectivityChecks to delete
     */
    where?: ConnectivityCheckWhereInput
    /**
     * Limit how many ConnectivityChecks to delete.
     */
    limit?: number
  }

  /**
   * ConnectivityCheck without action
   */
  export type ConnectivityCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectivityCheck
     */
    select?: ConnectivityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectivityCheck
     */
    omit?: ConnectivityCheckOmit<ExtArgs> | null
  }


  /**
   * Model Namespace
   */

  export type AggregateNamespace = {
    _count: NamespaceCountAggregateOutputType | null
    _min: NamespaceMinAggregateOutputType | null
    _max: NamespaceMaxAggregateOutputType | null
  }

  export type NamespaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    color: string | null
    icon: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NamespaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    color: string | null
    icon: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NamespaceCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    color: number
    icon: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NamespaceMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    color?: true
    icon?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NamespaceMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    color?: true
    icon?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NamespaceCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    color?: true
    icon?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NamespaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Namespace to aggregate.
     */
    where?: NamespaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Namespaces to fetch.
     */
    orderBy?: NamespaceOrderByWithRelationInput | NamespaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NamespaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Namespaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Namespaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Namespaces
    **/
    _count?: true | NamespaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NamespaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NamespaceMaxAggregateInputType
  }

  export type GetNamespaceAggregateType<T extends NamespaceAggregateArgs> = {
        [P in keyof T & keyof AggregateNamespace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNamespace[P]>
      : GetScalarType<T[P], AggregateNamespace[P]>
  }




  export type NamespaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NamespaceWhereInput
    orderBy?: NamespaceOrderByWithAggregationInput | NamespaceOrderByWithAggregationInput[]
    by: NamespaceScalarFieldEnum[] | NamespaceScalarFieldEnum
    having?: NamespaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NamespaceCountAggregateInputType | true
    _min?: NamespaceMinAggregateInputType
    _max?: NamespaceMaxAggregateInputType
  }

  export type NamespaceGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    color: string
    icon: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: NamespaceCountAggregateOutputType | null
    _min: NamespaceMinAggregateOutputType | null
    _max: NamespaceMaxAggregateOutputType | null
  }

  type GetNamespaceGroupByPayload<T extends NamespaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NamespaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NamespaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NamespaceGroupByOutputType[P]>
            : GetScalarType<T[P], NamespaceGroupByOutputType[P]>
        }
      >
    >


  export type NamespaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean | Namespace$permissionsArgs<ExtArgs>
    _count?: boolean | NamespaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["namespace"]>

  export type NamespaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["namespace"]>

  export type NamespaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["namespace"]>

  export type NamespaceSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NamespaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "displayName" | "description" | "color" | "icon" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["namespace"]>
  export type NamespaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | Namespace$permissionsArgs<ExtArgs>
    _count?: boolean | NamespaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NamespaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NamespaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NamespacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Namespace"
    objects: {
      permissions: Prisma.$NamespacePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      color: string
      icon: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["namespace"]>
    composites: {}
  }

  type NamespaceGetPayload<S extends boolean | null | undefined | NamespaceDefaultArgs> = $Result.GetResult<Prisma.$NamespacePayload, S>

  type NamespaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NamespaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NamespaceCountAggregateInputType | true
    }

  export interface NamespaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Namespace'], meta: { name: 'Namespace' } }
    /**
     * Find zero or one Namespace that matches the filter.
     * @param {NamespaceFindUniqueArgs} args - Arguments to find a Namespace
     * @example
     * // Get one Namespace
     * const namespace = await prisma.namespace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NamespaceFindUniqueArgs>(args: SelectSubset<T, NamespaceFindUniqueArgs<ExtArgs>>): Prisma__NamespaceClient<$Result.GetResult<Prisma.$NamespacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Namespace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NamespaceFindUniqueOrThrowArgs} args - Arguments to find a Namespace
     * @example
     * // Get one Namespace
     * const namespace = await prisma.namespace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NamespaceFindUniqueOrThrowArgs>(args: SelectSubset<T, NamespaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NamespaceClient<$Result.GetResult<Prisma.$NamespacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Namespace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespaceFindFirstArgs} args - Arguments to find a Namespace
     * @example
     * // Get one Namespace
     * const namespace = await prisma.namespace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NamespaceFindFirstArgs>(args?: SelectSubset<T, NamespaceFindFirstArgs<ExtArgs>>): Prisma__NamespaceClient<$Result.GetResult<Prisma.$NamespacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Namespace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespaceFindFirstOrThrowArgs} args - Arguments to find a Namespace
     * @example
     * // Get one Namespace
     * const namespace = await prisma.namespace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NamespaceFindFirstOrThrowArgs>(args?: SelectSubset<T, NamespaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NamespaceClient<$Result.GetResult<Prisma.$NamespacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Namespaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Namespaces
     * const namespaces = await prisma.namespace.findMany()
     * 
     * // Get first 10 Namespaces
     * const namespaces = await prisma.namespace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const namespaceWithIdOnly = await prisma.namespace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NamespaceFindManyArgs>(args?: SelectSubset<T, NamespaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NamespacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Namespace.
     * @param {NamespaceCreateArgs} args - Arguments to create a Namespace.
     * @example
     * // Create one Namespace
     * const Namespace = await prisma.namespace.create({
     *   data: {
     *     // ... data to create a Namespace
     *   }
     * })
     * 
     */
    create<T extends NamespaceCreateArgs>(args: SelectSubset<T, NamespaceCreateArgs<ExtArgs>>): Prisma__NamespaceClient<$Result.GetResult<Prisma.$NamespacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Namespaces.
     * @param {NamespaceCreateManyArgs} args - Arguments to create many Namespaces.
     * @example
     * // Create many Namespaces
     * const namespace = await prisma.namespace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NamespaceCreateManyArgs>(args?: SelectSubset<T, NamespaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Namespaces and returns the data saved in the database.
     * @param {NamespaceCreateManyAndReturnArgs} args - Arguments to create many Namespaces.
     * @example
     * // Create many Namespaces
     * const namespace = await prisma.namespace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Namespaces and only return the `id`
     * const namespaceWithIdOnly = await prisma.namespace.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NamespaceCreateManyAndReturnArgs>(args?: SelectSubset<T, NamespaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NamespacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Namespace.
     * @param {NamespaceDeleteArgs} args - Arguments to delete one Namespace.
     * @example
     * // Delete one Namespace
     * const Namespace = await prisma.namespace.delete({
     *   where: {
     *     // ... filter to delete one Namespace
     *   }
     * })
     * 
     */
    delete<T extends NamespaceDeleteArgs>(args: SelectSubset<T, NamespaceDeleteArgs<ExtArgs>>): Prisma__NamespaceClient<$Result.GetResult<Prisma.$NamespacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Namespace.
     * @param {NamespaceUpdateArgs} args - Arguments to update one Namespace.
     * @example
     * // Update one Namespace
     * const namespace = await prisma.namespace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NamespaceUpdateArgs>(args: SelectSubset<T, NamespaceUpdateArgs<ExtArgs>>): Prisma__NamespaceClient<$Result.GetResult<Prisma.$NamespacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Namespaces.
     * @param {NamespaceDeleteManyArgs} args - Arguments to filter Namespaces to delete.
     * @example
     * // Delete a few Namespaces
     * const { count } = await prisma.namespace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NamespaceDeleteManyArgs>(args?: SelectSubset<T, NamespaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Namespaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Namespaces
     * const namespace = await prisma.namespace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NamespaceUpdateManyArgs>(args: SelectSubset<T, NamespaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Namespaces and returns the data updated in the database.
     * @param {NamespaceUpdateManyAndReturnArgs} args - Arguments to update many Namespaces.
     * @example
     * // Update many Namespaces
     * const namespace = await prisma.namespace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Namespaces and only return the `id`
     * const namespaceWithIdOnly = await prisma.namespace.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NamespaceUpdateManyAndReturnArgs>(args: SelectSubset<T, NamespaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NamespacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Namespace.
     * @param {NamespaceUpsertArgs} args - Arguments to update or create a Namespace.
     * @example
     * // Update or create a Namespace
     * const namespace = await prisma.namespace.upsert({
     *   create: {
     *     // ... data to create a Namespace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Namespace we want to update
     *   }
     * })
     */
    upsert<T extends NamespaceUpsertArgs>(args: SelectSubset<T, NamespaceUpsertArgs<ExtArgs>>): Prisma__NamespaceClient<$Result.GetResult<Prisma.$NamespacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Namespaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespaceCountArgs} args - Arguments to filter Namespaces to count.
     * @example
     * // Count the number of Namespaces
     * const count = await prisma.namespace.count({
     *   where: {
     *     // ... the filter for the Namespaces we want to count
     *   }
     * })
    **/
    count<T extends NamespaceCountArgs>(
      args?: Subset<T, NamespaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NamespaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Namespace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NamespaceAggregateArgs>(args: Subset<T, NamespaceAggregateArgs>): Prisma.PrismaPromise<GetNamespaceAggregateType<T>>

    /**
     * Group by Namespace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NamespaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NamespaceGroupByArgs['orderBy'] }
        : { orderBy?: NamespaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NamespaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNamespaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Namespace model
   */
  readonly fields: NamespaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Namespace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NamespaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends Namespace$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Namespace$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NamespacePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Namespace model
   */
  interface NamespaceFieldRefs {
    readonly id: FieldRef<"Namespace", 'String'>
    readonly name: FieldRef<"Namespace", 'String'>
    readonly displayName: FieldRef<"Namespace", 'String'>
    readonly description: FieldRef<"Namespace", 'String'>
    readonly color: FieldRef<"Namespace", 'String'>
    readonly icon: FieldRef<"Namespace", 'String'>
    readonly createdBy: FieldRef<"Namespace", 'String'>
    readonly createdAt: FieldRef<"Namespace", 'DateTime'>
    readonly updatedAt: FieldRef<"Namespace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Namespace findUnique
   */
  export type NamespaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Namespace
     */
    select?: NamespaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Namespace
     */
    omit?: NamespaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespaceInclude<ExtArgs> | null
    /**
     * Filter, which Namespace to fetch.
     */
    where: NamespaceWhereUniqueInput
  }

  /**
   * Namespace findUniqueOrThrow
   */
  export type NamespaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Namespace
     */
    select?: NamespaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Namespace
     */
    omit?: NamespaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespaceInclude<ExtArgs> | null
    /**
     * Filter, which Namespace to fetch.
     */
    where: NamespaceWhereUniqueInput
  }

  /**
   * Namespace findFirst
   */
  export type NamespaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Namespace
     */
    select?: NamespaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Namespace
     */
    omit?: NamespaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespaceInclude<ExtArgs> | null
    /**
     * Filter, which Namespace to fetch.
     */
    where?: NamespaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Namespaces to fetch.
     */
    orderBy?: NamespaceOrderByWithRelationInput | NamespaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Namespaces.
     */
    cursor?: NamespaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Namespaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Namespaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Namespaces.
     */
    distinct?: NamespaceScalarFieldEnum | NamespaceScalarFieldEnum[]
  }

  /**
   * Namespace findFirstOrThrow
   */
  export type NamespaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Namespace
     */
    select?: NamespaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Namespace
     */
    omit?: NamespaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespaceInclude<ExtArgs> | null
    /**
     * Filter, which Namespace to fetch.
     */
    where?: NamespaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Namespaces to fetch.
     */
    orderBy?: NamespaceOrderByWithRelationInput | NamespaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Namespaces.
     */
    cursor?: NamespaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Namespaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Namespaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Namespaces.
     */
    distinct?: NamespaceScalarFieldEnum | NamespaceScalarFieldEnum[]
  }

  /**
   * Namespace findMany
   */
  export type NamespaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Namespace
     */
    select?: NamespaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Namespace
     */
    omit?: NamespaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespaceInclude<ExtArgs> | null
    /**
     * Filter, which Namespaces to fetch.
     */
    where?: NamespaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Namespaces to fetch.
     */
    orderBy?: NamespaceOrderByWithRelationInput | NamespaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Namespaces.
     */
    cursor?: NamespaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Namespaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Namespaces.
     */
    skip?: number
    distinct?: NamespaceScalarFieldEnum | NamespaceScalarFieldEnum[]
  }

  /**
   * Namespace create
   */
  export type NamespaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Namespace
     */
    select?: NamespaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Namespace
     */
    omit?: NamespaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Namespace.
     */
    data: XOR<NamespaceCreateInput, NamespaceUncheckedCreateInput>
  }

  /**
   * Namespace createMany
   */
  export type NamespaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Namespaces.
     */
    data: NamespaceCreateManyInput | NamespaceCreateManyInput[]
  }

  /**
   * Namespace createManyAndReturn
   */
  export type NamespaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Namespace
     */
    select?: NamespaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Namespace
     */
    omit?: NamespaceOmit<ExtArgs> | null
    /**
     * The data used to create many Namespaces.
     */
    data: NamespaceCreateManyInput | NamespaceCreateManyInput[]
  }

  /**
   * Namespace update
   */
  export type NamespaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Namespace
     */
    select?: NamespaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Namespace
     */
    omit?: NamespaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Namespace.
     */
    data: XOR<NamespaceUpdateInput, NamespaceUncheckedUpdateInput>
    /**
     * Choose, which Namespace to update.
     */
    where: NamespaceWhereUniqueInput
  }

  /**
   * Namespace updateMany
   */
  export type NamespaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Namespaces.
     */
    data: XOR<NamespaceUpdateManyMutationInput, NamespaceUncheckedUpdateManyInput>
    /**
     * Filter which Namespaces to update
     */
    where?: NamespaceWhereInput
    /**
     * Limit how many Namespaces to update.
     */
    limit?: number
  }

  /**
   * Namespace updateManyAndReturn
   */
  export type NamespaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Namespace
     */
    select?: NamespaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Namespace
     */
    omit?: NamespaceOmit<ExtArgs> | null
    /**
     * The data used to update Namespaces.
     */
    data: XOR<NamespaceUpdateManyMutationInput, NamespaceUncheckedUpdateManyInput>
    /**
     * Filter which Namespaces to update
     */
    where?: NamespaceWhereInput
    /**
     * Limit how many Namespaces to update.
     */
    limit?: number
  }

  /**
   * Namespace upsert
   */
  export type NamespaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Namespace
     */
    select?: NamespaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Namespace
     */
    omit?: NamespaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Namespace to update in case it exists.
     */
    where: NamespaceWhereUniqueInput
    /**
     * In case the Namespace found by the `where` argument doesn't exist, create a new Namespace with this data.
     */
    create: XOR<NamespaceCreateInput, NamespaceUncheckedCreateInput>
    /**
     * In case the Namespace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NamespaceUpdateInput, NamespaceUncheckedUpdateInput>
  }

  /**
   * Namespace delete
   */
  export type NamespaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Namespace
     */
    select?: NamespaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Namespace
     */
    omit?: NamespaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespaceInclude<ExtArgs> | null
    /**
     * Filter which Namespace to delete.
     */
    where: NamespaceWhereUniqueInput
  }

  /**
   * Namespace deleteMany
   */
  export type NamespaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Namespaces to delete
     */
    where?: NamespaceWhereInput
    /**
     * Limit how many Namespaces to delete.
     */
    limit?: number
  }

  /**
   * Namespace.permissions
   */
  export type Namespace$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionInclude<ExtArgs> | null
    where?: NamespacePermissionWhereInput
    orderBy?: NamespacePermissionOrderByWithRelationInput | NamespacePermissionOrderByWithRelationInput[]
    cursor?: NamespacePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NamespacePermissionScalarFieldEnum | NamespacePermissionScalarFieldEnum[]
  }

  /**
   * Namespace without action
   */
  export type NamespaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Namespace
     */
    select?: NamespaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Namespace
     */
    omit?: NamespaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespaceInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    name: string | null
    samAccountName: string | null
    email: string | null
    password: string | null
    role: string | null
    enabled: boolean | null
    locked: boolean | null
    approved: boolean | null
    approvedBy: string | null
    approvedAt: Date | null
    location: string | null
    department: string | null
    profilePhoto: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    name: string | null
    samAccountName: string | null
    email: string | null
    password: string | null
    role: string | null
    enabled: boolean | null
    locked: boolean | null
    approved: boolean | null
    approvedBy: string | null
    approvedAt: Date | null
    location: string | null
    department: string | null
    profilePhoto: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    name: number
    samAccountName: number
    email: number
    password: number
    role: number
    enabled: number
    locked: number
    approved: number
    approvedBy: number
    approvedAt: number
    location: number
    department: number
    profilePhoto: number
    managerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    name?: true
    samAccountName?: true
    email?: true
    password?: true
    role?: true
    enabled?: true
    locked?: true
    approved?: true
    approvedBy?: true
    approvedAt?: true
    location?: true
    department?: true
    profilePhoto?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    name?: true
    samAccountName?: true
    email?: true
    password?: true
    role?: true
    enabled?: true
    locked?: true
    approved?: true
    approvedBy?: true
    approvedAt?: true
    location?: true
    department?: true
    profilePhoto?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    name?: true
    samAccountName?: true
    email?: true
    password?: true
    role?: true
    enabled?: true
    locked?: true
    approved?: true
    approvedBy?: true
    approvedAt?: true
    location?: true
    department?: true
    profilePhoto?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    name: string
    samAccountName: string | null
    email: string
    password: string
    role: string
    enabled: boolean
    locked: boolean
    approved: boolean
    approvedBy: string | null
    approvedAt: Date | null
    location: string | null
    department: string | null
    profilePhoto: string | null
    managerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    samAccountName?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    location?: boolean
    department?: boolean
    profilePhoto?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    manager?: boolean | User$managerArgs<ExtArgs>
    subordinates?: boolean | User$subordinatesArgs<ExtArgs>
    groupMemberships?: boolean | User$groupMembershipsArgs<ExtArgs>
    permissions?: boolean | User$permissionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    samAccountName?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    location?: boolean
    department?: boolean
    profilePhoto?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    manager?: boolean | User$managerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    samAccountName?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    location?: boolean
    department?: boolean
    profilePhoto?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    manager?: boolean | User$managerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    samAccountName?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    location?: boolean
    department?: boolean
    profilePhoto?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "name" | "samAccountName" | "email" | "password" | "role" | "enabled" | "locked" | "approved" | "approvedBy" | "approvedAt" | "location" | "department" | "profilePhoto" | "managerId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | User$managerArgs<ExtArgs>
    subordinates?: boolean | User$subordinatesArgs<ExtArgs>
    groupMemberships?: boolean | User$groupMembershipsArgs<ExtArgs>
    permissions?: boolean | User$permissionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | User$managerArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | User$managerArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      manager: Prisma.$UserPayload<ExtArgs> | null
      subordinates: Prisma.$UserPayload<ExtArgs>[]
      groupMemberships: Prisma.$GroupMemberPayload<ExtArgs>[]
      permissions: Prisma.$NamespacePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      name: string
      samAccountName: string | null
      email: string
      password: string
      role: string
      enabled: boolean
      locked: boolean
      approved: boolean
      approvedBy: string | null
      approvedAt: Date | null
      location: string | null
      department: string | null
      profilePhoto: string | null
      managerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    manager<T extends User$managerArgs<ExtArgs> = {}>(args?: Subset<T, User$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subordinates<T extends User$subordinatesArgs<ExtArgs> = {}>(args?: Subset<T, User$subordinatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupMemberships<T extends User$groupMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends User$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NamespacePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly samAccountName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly enabled: FieldRef<"User", 'Boolean'>
    readonly locked: FieldRef<"User", 'Boolean'>
    readonly approved: FieldRef<"User", 'Boolean'>
    readonly approvedBy: FieldRef<"User", 'String'>
    readonly approvedAt: FieldRef<"User", 'DateTime'>
    readonly location: FieldRef<"User", 'String'>
    readonly department: FieldRef<"User", 'String'>
    readonly profilePhoto: FieldRef<"User", 'String'>
    readonly managerId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.manager
   */
  export type User$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.subordinates
   */
  export type User$subordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.groupMemberships
   */
  export type User$groupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * User.permissions
   */
  export type User$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionInclude<ExtArgs> | null
    where?: NamespacePermissionWhereInput
    orderBy?: NamespacePermissionOrderByWithRelationInput | NamespacePermissionOrderByWithRelationInput[]
    cursor?: NamespacePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NamespacePermissionScalarFieldEnum | NamespacePermissionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isPredefined: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isPredefined: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isPredefined: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isPredefined?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isPredefined?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isPredefined?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isPredefined: boolean
    createdAt: Date
    updatedAt: Date
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isPredefined?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Group$membersArgs<ExtArgs>
    permissions?: boolean | Group$permissionsArgs<ExtArgs>
    modulePermissions?: boolean | Group$modulePermissionsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isPredefined?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["group"]>

  export type GroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isPredefined?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isPredefined?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isPredefined" | "createdAt" | "updatedAt", ExtArgs["result"]["group"]>
  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Group$membersArgs<ExtArgs>
    permissions?: boolean | Group$permissionsArgs<ExtArgs>
    modulePermissions?: boolean | Group$modulePermissionsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      members: Prisma.$GroupMemberPayload<ExtArgs>[]
      permissions: Prisma.$NamespacePermissionPayload<ExtArgs>[]
      modulePermissions: Prisma.$ModulePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isPredefined: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {GroupUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Group$membersArgs<ExtArgs> = {}>(args?: Subset<T, Group$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends Group$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Group$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NamespacePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modulePermissions<T extends Group$modulePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Group$modulePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'String'>
    readonly name: FieldRef<"Group", 'String'>
    readonly description: FieldRef<"Group", 'String'>
    readonly isPredefined: FieldRef<"Group", 'Boolean'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group updateManyAndReturn
   */
  export type GroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Group.members
   */
  export type Group$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * Group.permissions
   */
  export type Group$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionInclude<ExtArgs> | null
    where?: NamespacePermissionWhereInput
    orderBy?: NamespacePermissionOrderByWithRelationInput | NamespacePermissionOrderByWithRelationInput[]
    cursor?: NamespacePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NamespacePermissionScalarFieldEnum | NamespacePermissionScalarFieldEnum[]
  }

  /**
   * Group.modulePermissions
   */
  export type Group$modulePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePermission
     */
    select?: ModulePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePermission
     */
    omit?: ModulePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePermissionInclude<ExtArgs> | null
    where?: ModulePermissionWhereInput
    orderBy?: ModulePermissionOrderByWithRelationInput | ModulePermissionOrderByWithRelationInput[]
    cursor?: ModulePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModulePermissionScalarFieldEnum | ModulePermissionScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model GroupMember
   */

  export type AggregateGroupMember = {
    _count: GroupMemberCountAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  export type GroupMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    groupId: string | null
    createdAt: Date | null
  }

  export type GroupMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    groupId: string | null
    createdAt: Date | null
  }

  export type GroupMemberCountAggregateOutputType = {
    id: number
    userId: number
    groupId: number
    createdAt: number
    _all: number
  }


  export type GroupMemberMinAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    createdAt?: true
  }

  export type GroupMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    createdAt?: true
  }

  export type GroupMemberCountAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    createdAt?: true
    _all?: true
  }

  export type GroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMember to aggregate.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMembers
    **/
    _count?: true | GroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GetGroupMemberAggregateType<T extends GroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMember[P]>
      : GetScalarType<T[P], AggregateGroupMember[P]>
  }




  export type GroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithAggregationInput | GroupMemberOrderByWithAggregationInput[]
    by: GroupMemberScalarFieldEnum[] | GroupMemberScalarFieldEnum
    having?: GroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMemberCountAggregateInputType | true
    _min?: GroupMemberMinAggregateInputType
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GroupMemberGroupByOutputType = {
    id: string
    userId: string
    groupId: string
    createdAt: Date
    _count: GroupMemberCountAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  type GetGroupMemberGroupByPayload<T extends GroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type GroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    groupId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    groupId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    groupId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    groupId?: boolean
    createdAt?: boolean
  }

  export type GroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "groupId" | "createdAt", ExtArgs["result"]["groupMember"]>
  export type GroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type GroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type GroupMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $GroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      group: Prisma.$GroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      groupId: string
      createdAt: Date
    }, ExtArgs["result"]["groupMember"]>
    composites: {}
  }

  type GroupMemberGetPayload<S extends boolean | null | undefined | GroupMemberDefaultArgs> = $Result.GetResult<Prisma.$GroupMemberPayload, S>

  type GroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupMemberCountAggregateInputType | true
    }

  export interface GroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMember'], meta: { name: 'GroupMember' } }
    /**
     * Find zero or one GroupMember that matches the filter.
     * @param {GroupMemberFindUniqueArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMemberFindUniqueArgs>(args: SelectSubset<T, GroupMemberFindUniqueArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupMemberFindUniqueOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMemberFindFirstArgs>(args?: SelectSubset<T, GroupMemberFindFirstArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMembers
     * const groupMembers = await prisma.groupMember.findMany()
     * 
     * // Get first 10 GroupMembers
     * const groupMembers = await prisma.groupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupMemberFindManyArgs>(args?: SelectSubset<T, GroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupMember.
     * @param {GroupMemberCreateArgs} args - Arguments to create a GroupMember.
     * @example
     * // Create one GroupMember
     * const GroupMember = await prisma.groupMember.create({
     *   data: {
     *     // ... data to create a GroupMember
     *   }
     * })
     * 
     */
    create<T extends GroupMemberCreateArgs>(args: SelectSubset<T, GroupMemberCreateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupMembers.
     * @param {GroupMemberCreateManyArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMemberCreateManyArgs>(args?: SelectSubset<T, GroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMembers and returns the data saved in the database.
     * @param {GroupMemberCreateManyAndReturnArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupMember.
     * @param {GroupMemberDeleteArgs} args - Arguments to delete one GroupMember.
     * @example
     * // Delete one GroupMember
     * const GroupMember = await prisma.groupMember.delete({
     *   where: {
     *     // ... filter to delete one GroupMember
     *   }
     * })
     * 
     */
    delete<T extends GroupMemberDeleteArgs>(args: SelectSubset<T, GroupMemberDeleteArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupMember.
     * @param {GroupMemberUpdateArgs} args - Arguments to update one GroupMember.
     * @example
     * // Update one GroupMember
     * const groupMember = await prisma.groupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMemberUpdateArgs>(args: SelectSubset<T, GroupMemberUpdateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupMembers.
     * @param {GroupMemberDeleteManyArgs} args - Arguments to filter GroupMembers to delete.
     * @example
     * // Delete a few GroupMembers
     * const { count } = await prisma.groupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMemberDeleteManyArgs>(args?: SelectSubset<T, GroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMemberUpdateManyArgs>(args: SelectSubset<T, GroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers and returns the data updated in the database.
     * @param {GroupMemberUpdateManyAndReturnArgs} args - Arguments to update many GroupMembers.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupMember.
     * @param {GroupMemberUpsertArgs} args - Arguments to update or create a GroupMember.
     * @example
     * // Update or create a GroupMember
     * const groupMember = await prisma.groupMember.upsert({
     *   create: {
     *     // ... data to create a GroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMember we want to update
     *   }
     * })
     */
    upsert<T extends GroupMemberUpsertArgs>(args: SelectSubset<T, GroupMemberUpsertArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberCountArgs} args - Arguments to filter GroupMembers to count.
     * @example
     * // Count the number of GroupMembers
     * const count = await prisma.groupMember.count({
     *   where: {
     *     // ... the filter for the GroupMembers we want to count
     *   }
     * })
    **/
    count<T extends GroupMemberCountArgs>(
      args?: Subset<T, GroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMemberAggregateArgs>(args: Subset<T, GroupMemberAggregateArgs>): Prisma.PrismaPromise<GetGroupMemberAggregateType<T>>

    /**
     * Group by GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: GroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMember model
   */
  readonly fields: GroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMember model
   */
  interface GroupMemberFieldRefs {
    readonly id: FieldRef<"GroupMember", 'String'>
    readonly userId: FieldRef<"GroupMember", 'String'>
    readonly groupId: FieldRef<"GroupMember", 'String'>
    readonly createdAt: FieldRef<"GroupMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupMember findUnique
   */
  export type GroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findUniqueOrThrow
   */
  export type GroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findFirst
   */
  export type GroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findFirstOrThrow
   */
  export type GroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findMany
   */
  export type GroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembers to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember create
   */
  export type GroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMember.
     */
    data: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
  }

  /**
   * GroupMember createMany
   */
  export type GroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
  }

  /**
   * GroupMember createManyAndReturn
   */
  export type GroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember update
   */
  export type GroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMember.
     */
    data: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
    /**
     * Choose, which GroupMember to update.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember updateMany
   */
  export type GroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to update.
     */
    limit?: number
  }

  /**
   * GroupMember updateManyAndReturn
   */
  export type GroupMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember upsert
   */
  export type GroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMember to update in case it exists.
     */
    where: GroupMemberWhereUniqueInput
    /**
     * In case the GroupMember found by the `where` argument doesn't exist, create a new GroupMember with this data.
     */
    create: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
    /**
     * In case the GroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
  }

  /**
   * GroupMember delete
   */
  export type GroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter which GroupMember to delete.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember deleteMany
   */
  export type GroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMembers to delete
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to delete.
     */
    limit?: number
  }

  /**
   * GroupMember without action
   */
  export type GroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model NamespacePermission
   */

  export type AggregateNamespacePermission = {
    _count: NamespacePermissionCountAggregateOutputType | null
    _min: NamespacePermissionMinAggregateOutputType | null
    _max: NamespacePermissionMaxAggregateOutputType | null
  }

  export type NamespacePermissionMinAggregateOutputType = {
    id: string | null
    namespaceId: string | null
    userId: string | null
    groupId: string | null
    canRead: boolean | null
    canWrite: boolean | null
    canExecute: boolean | null
    canAdmin: boolean | null
    createdAt: Date | null
  }

  export type NamespacePermissionMaxAggregateOutputType = {
    id: string | null
    namespaceId: string | null
    userId: string | null
    groupId: string | null
    canRead: boolean | null
    canWrite: boolean | null
    canExecute: boolean | null
    canAdmin: boolean | null
    createdAt: Date | null
  }

  export type NamespacePermissionCountAggregateOutputType = {
    id: number
    namespaceId: number
    userId: number
    groupId: number
    canRead: number
    canWrite: number
    canExecute: number
    canAdmin: number
    createdAt: number
    _all: number
  }


  export type NamespacePermissionMinAggregateInputType = {
    id?: true
    namespaceId?: true
    userId?: true
    groupId?: true
    canRead?: true
    canWrite?: true
    canExecute?: true
    canAdmin?: true
    createdAt?: true
  }

  export type NamespacePermissionMaxAggregateInputType = {
    id?: true
    namespaceId?: true
    userId?: true
    groupId?: true
    canRead?: true
    canWrite?: true
    canExecute?: true
    canAdmin?: true
    createdAt?: true
  }

  export type NamespacePermissionCountAggregateInputType = {
    id?: true
    namespaceId?: true
    userId?: true
    groupId?: true
    canRead?: true
    canWrite?: true
    canExecute?: true
    canAdmin?: true
    createdAt?: true
    _all?: true
  }

  export type NamespacePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NamespacePermission to aggregate.
     */
    where?: NamespacePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NamespacePermissions to fetch.
     */
    orderBy?: NamespacePermissionOrderByWithRelationInput | NamespacePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NamespacePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NamespacePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NamespacePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NamespacePermissions
    **/
    _count?: true | NamespacePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NamespacePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NamespacePermissionMaxAggregateInputType
  }

  export type GetNamespacePermissionAggregateType<T extends NamespacePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateNamespacePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNamespacePermission[P]>
      : GetScalarType<T[P], AggregateNamespacePermission[P]>
  }




  export type NamespacePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NamespacePermissionWhereInput
    orderBy?: NamespacePermissionOrderByWithAggregationInput | NamespacePermissionOrderByWithAggregationInput[]
    by: NamespacePermissionScalarFieldEnum[] | NamespacePermissionScalarFieldEnum
    having?: NamespacePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NamespacePermissionCountAggregateInputType | true
    _min?: NamespacePermissionMinAggregateInputType
    _max?: NamespacePermissionMaxAggregateInputType
  }

  export type NamespacePermissionGroupByOutputType = {
    id: string
    namespaceId: string
    userId: string | null
    groupId: string | null
    canRead: boolean
    canWrite: boolean
    canExecute: boolean
    canAdmin: boolean
    createdAt: Date
    _count: NamespacePermissionCountAggregateOutputType | null
    _min: NamespacePermissionMinAggregateOutputType | null
    _max: NamespacePermissionMaxAggregateOutputType | null
  }

  type GetNamespacePermissionGroupByPayload<T extends NamespacePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NamespacePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NamespacePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NamespacePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], NamespacePermissionGroupByOutputType[P]>
        }
      >
    >


  export type NamespacePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    namespaceId?: boolean
    userId?: boolean
    groupId?: boolean
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: boolean
    namespace?: boolean | NamespaceDefaultArgs<ExtArgs>
    user?: boolean | NamespacePermission$userArgs<ExtArgs>
    group?: boolean | NamespacePermission$groupArgs<ExtArgs>
  }, ExtArgs["result"]["namespacePermission"]>

  export type NamespacePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    namespaceId?: boolean
    userId?: boolean
    groupId?: boolean
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: boolean
    namespace?: boolean | NamespaceDefaultArgs<ExtArgs>
    user?: boolean | NamespacePermission$userArgs<ExtArgs>
    group?: boolean | NamespacePermission$groupArgs<ExtArgs>
  }, ExtArgs["result"]["namespacePermission"]>

  export type NamespacePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    namespaceId?: boolean
    userId?: boolean
    groupId?: boolean
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: boolean
    namespace?: boolean | NamespaceDefaultArgs<ExtArgs>
    user?: boolean | NamespacePermission$userArgs<ExtArgs>
    group?: boolean | NamespacePermission$groupArgs<ExtArgs>
  }, ExtArgs["result"]["namespacePermission"]>

  export type NamespacePermissionSelectScalar = {
    id?: boolean
    namespaceId?: boolean
    userId?: boolean
    groupId?: boolean
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: boolean
  }

  export type NamespacePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "namespaceId" | "userId" | "groupId" | "canRead" | "canWrite" | "canExecute" | "canAdmin" | "createdAt", ExtArgs["result"]["namespacePermission"]>
  export type NamespacePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    namespace?: boolean | NamespaceDefaultArgs<ExtArgs>
    user?: boolean | NamespacePermission$userArgs<ExtArgs>
    group?: boolean | NamespacePermission$groupArgs<ExtArgs>
  }
  export type NamespacePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    namespace?: boolean | NamespaceDefaultArgs<ExtArgs>
    user?: boolean | NamespacePermission$userArgs<ExtArgs>
    group?: boolean | NamespacePermission$groupArgs<ExtArgs>
  }
  export type NamespacePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    namespace?: boolean | NamespaceDefaultArgs<ExtArgs>
    user?: boolean | NamespacePermission$userArgs<ExtArgs>
    group?: boolean | NamespacePermission$groupArgs<ExtArgs>
  }

  export type $NamespacePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NamespacePermission"
    objects: {
      namespace: Prisma.$NamespacePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      group: Prisma.$GroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      namespaceId: string
      userId: string | null
      groupId: string | null
      canRead: boolean
      canWrite: boolean
      canExecute: boolean
      canAdmin: boolean
      createdAt: Date
    }, ExtArgs["result"]["namespacePermission"]>
    composites: {}
  }

  type NamespacePermissionGetPayload<S extends boolean | null | undefined | NamespacePermissionDefaultArgs> = $Result.GetResult<Prisma.$NamespacePermissionPayload, S>

  type NamespacePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NamespacePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NamespacePermissionCountAggregateInputType | true
    }

  export interface NamespacePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NamespacePermission'], meta: { name: 'NamespacePermission' } }
    /**
     * Find zero or one NamespacePermission that matches the filter.
     * @param {NamespacePermissionFindUniqueArgs} args - Arguments to find a NamespacePermission
     * @example
     * // Get one NamespacePermission
     * const namespacePermission = await prisma.namespacePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NamespacePermissionFindUniqueArgs>(args: SelectSubset<T, NamespacePermissionFindUniqueArgs<ExtArgs>>): Prisma__NamespacePermissionClient<$Result.GetResult<Prisma.$NamespacePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NamespacePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NamespacePermissionFindUniqueOrThrowArgs} args - Arguments to find a NamespacePermission
     * @example
     * // Get one NamespacePermission
     * const namespacePermission = await prisma.namespacePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NamespacePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, NamespacePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NamespacePermissionClient<$Result.GetResult<Prisma.$NamespacePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NamespacePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespacePermissionFindFirstArgs} args - Arguments to find a NamespacePermission
     * @example
     * // Get one NamespacePermission
     * const namespacePermission = await prisma.namespacePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NamespacePermissionFindFirstArgs>(args?: SelectSubset<T, NamespacePermissionFindFirstArgs<ExtArgs>>): Prisma__NamespacePermissionClient<$Result.GetResult<Prisma.$NamespacePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NamespacePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespacePermissionFindFirstOrThrowArgs} args - Arguments to find a NamespacePermission
     * @example
     * // Get one NamespacePermission
     * const namespacePermission = await prisma.namespacePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NamespacePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, NamespacePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NamespacePermissionClient<$Result.GetResult<Prisma.$NamespacePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NamespacePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespacePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NamespacePermissions
     * const namespacePermissions = await prisma.namespacePermission.findMany()
     * 
     * // Get first 10 NamespacePermissions
     * const namespacePermissions = await prisma.namespacePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const namespacePermissionWithIdOnly = await prisma.namespacePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NamespacePermissionFindManyArgs>(args?: SelectSubset<T, NamespacePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NamespacePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NamespacePermission.
     * @param {NamespacePermissionCreateArgs} args - Arguments to create a NamespacePermission.
     * @example
     * // Create one NamespacePermission
     * const NamespacePermission = await prisma.namespacePermission.create({
     *   data: {
     *     // ... data to create a NamespacePermission
     *   }
     * })
     * 
     */
    create<T extends NamespacePermissionCreateArgs>(args: SelectSubset<T, NamespacePermissionCreateArgs<ExtArgs>>): Prisma__NamespacePermissionClient<$Result.GetResult<Prisma.$NamespacePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NamespacePermissions.
     * @param {NamespacePermissionCreateManyArgs} args - Arguments to create many NamespacePermissions.
     * @example
     * // Create many NamespacePermissions
     * const namespacePermission = await prisma.namespacePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NamespacePermissionCreateManyArgs>(args?: SelectSubset<T, NamespacePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NamespacePermissions and returns the data saved in the database.
     * @param {NamespacePermissionCreateManyAndReturnArgs} args - Arguments to create many NamespacePermissions.
     * @example
     * // Create many NamespacePermissions
     * const namespacePermission = await prisma.namespacePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NamespacePermissions and only return the `id`
     * const namespacePermissionWithIdOnly = await prisma.namespacePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NamespacePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, NamespacePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NamespacePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NamespacePermission.
     * @param {NamespacePermissionDeleteArgs} args - Arguments to delete one NamespacePermission.
     * @example
     * // Delete one NamespacePermission
     * const NamespacePermission = await prisma.namespacePermission.delete({
     *   where: {
     *     // ... filter to delete one NamespacePermission
     *   }
     * })
     * 
     */
    delete<T extends NamespacePermissionDeleteArgs>(args: SelectSubset<T, NamespacePermissionDeleteArgs<ExtArgs>>): Prisma__NamespacePermissionClient<$Result.GetResult<Prisma.$NamespacePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NamespacePermission.
     * @param {NamespacePermissionUpdateArgs} args - Arguments to update one NamespacePermission.
     * @example
     * // Update one NamespacePermission
     * const namespacePermission = await prisma.namespacePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NamespacePermissionUpdateArgs>(args: SelectSubset<T, NamespacePermissionUpdateArgs<ExtArgs>>): Prisma__NamespacePermissionClient<$Result.GetResult<Prisma.$NamespacePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NamespacePermissions.
     * @param {NamespacePermissionDeleteManyArgs} args - Arguments to filter NamespacePermissions to delete.
     * @example
     * // Delete a few NamespacePermissions
     * const { count } = await prisma.namespacePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NamespacePermissionDeleteManyArgs>(args?: SelectSubset<T, NamespacePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NamespacePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespacePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NamespacePermissions
     * const namespacePermission = await prisma.namespacePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NamespacePermissionUpdateManyArgs>(args: SelectSubset<T, NamespacePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NamespacePermissions and returns the data updated in the database.
     * @param {NamespacePermissionUpdateManyAndReturnArgs} args - Arguments to update many NamespacePermissions.
     * @example
     * // Update many NamespacePermissions
     * const namespacePermission = await prisma.namespacePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NamespacePermissions and only return the `id`
     * const namespacePermissionWithIdOnly = await prisma.namespacePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NamespacePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, NamespacePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NamespacePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NamespacePermission.
     * @param {NamespacePermissionUpsertArgs} args - Arguments to update or create a NamespacePermission.
     * @example
     * // Update or create a NamespacePermission
     * const namespacePermission = await prisma.namespacePermission.upsert({
     *   create: {
     *     // ... data to create a NamespacePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NamespacePermission we want to update
     *   }
     * })
     */
    upsert<T extends NamespacePermissionUpsertArgs>(args: SelectSubset<T, NamespacePermissionUpsertArgs<ExtArgs>>): Prisma__NamespacePermissionClient<$Result.GetResult<Prisma.$NamespacePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NamespacePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespacePermissionCountArgs} args - Arguments to filter NamespacePermissions to count.
     * @example
     * // Count the number of NamespacePermissions
     * const count = await prisma.namespacePermission.count({
     *   where: {
     *     // ... the filter for the NamespacePermissions we want to count
     *   }
     * })
    **/
    count<T extends NamespacePermissionCountArgs>(
      args?: Subset<T, NamespacePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NamespacePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NamespacePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespacePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NamespacePermissionAggregateArgs>(args: Subset<T, NamespacePermissionAggregateArgs>): Prisma.PrismaPromise<GetNamespacePermissionAggregateType<T>>

    /**
     * Group by NamespacePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespacePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NamespacePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NamespacePermissionGroupByArgs['orderBy'] }
        : { orderBy?: NamespacePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NamespacePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNamespacePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NamespacePermission model
   */
  readonly fields: NamespacePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NamespacePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NamespacePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    namespace<T extends NamespaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NamespaceDefaultArgs<ExtArgs>>): Prisma__NamespaceClient<$Result.GetResult<Prisma.$NamespacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends NamespacePermission$userArgs<ExtArgs> = {}>(args?: Subset<T, NamespacePermission$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    group<T extends NamespacePermission$groupArgs<ExtArgs> = {}>(args?: Subset<T, NamespacePermission$groupArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NamespacePermission model
   */
  interface NamespacePermissionFieldRefs {
    readonly id: FieldRef<"NamespacePermission", 'String'>
    readonly namespaceId: FieldRef<"NamespacePermission", 'String'>
    readonly userId: FieldRef<"NamespacePermission", 'String'>
    readonly groupId: FieldRef<"NamespacePermission", 'String'>
    readonly canRead: FieldRef<"NamespacePermission", 'Boolean'>
    readonly canWrite: FieldRef<"NamespacePermission", 'Boolean'>
    readonly canExecute: FieldRef<"NamespacePermission", 'Boolean'>
    readonly canAdmin: FieldRef<"NamespacePermission", 'Boolean'>
    readonly createdAt: FieldRef<"NamespacePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NamespacePermission findUnique
   */
  export type NamespacePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionInclude<ExtArgs> | null
    /**
     * Filter, which NamespacePermission to fetch.
     */
    where: NamespacePermissionWhereUniqueInput
  }

  /**
   * NamespacePermission findUniqueOrThrow
   */
  export type NamespacePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionInclude<ExtArgs> | null
    /**
     * Filter, which NamespacePermission to fetch.
     */
    where: NamespacePermissionWhereUniqueInput
  }

  /**
   * NamespacePermission findFirst
   */
  export type NamespacePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionInclude<ExtArgs> | null
    /**
     * Filter, which NamespacePermission to fetch.
     */
    where?: NamespacePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NamespacePermissions to fetch.
     */
    orderBy?: NamespacePermissionOrderByWithRelationInput | NamespacePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NamespacePermissions.
     */
    cursor?: NamespacePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NamespacePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NamespacePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NamespacePermissions.
     */
    distinct?: NamespacePermissionScalarFieldEnum | NamespacePermissionScalarFieldEnum[]
  }

  /**
   * NamespacePermission findFirstOrThrow
   */
  export type NamespacePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionInclude<ExtArgs> | null
    /**
     * Filter, which NamespacePermission to fetch.
     */
    where?: NamespacePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NamespacePermissions to fetch.
     */
    orderBy?: NamespacePermissionOrderByWithRelationInput | NamespacePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NamespacePermissions.
     */
    cursor?: NamespacePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NamespacePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NamespacePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NamespacePermissions.
     */
    distinct?: NamespacePermissionScalarFieldEnum | NamespacePermissionScalarFieldEnum[]
  }

  /**
   * NamespacePermission findMany
   */
  export type NamespacePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionInclude<ExtArgs> | null
    /**
     * Filter, which NamespacePermissions to fetch.
     */
    where?: NamespacePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NamespacePermissions to fetch.
     */
    orderBy?: NamespacePermissionOrderByWithRelationInput | NamespacePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NamespacePermissions.
     */
    cursor?: NamespacePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NamespacePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NamespacePermissions.
     */
    skip?: number
    distinct?: NamespacePermissionScalarFieldEnum | NamespacePermissionScalarFieldEnum[]
  }

  /**
   * NamespacePermission create
   */
  export type NamespacePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a NamespacePermission.
     */
    data: XOR<NamespacePermissionCreateInput, NamespacePermissionUncheckedCreateInput>
  }

  /**
   * NamespacePermission createMany
   */
  export type NamespacePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NamespacePermissions.
     */
    data: NamespacePermissionCreateManyInput | NamespacePermissionCreateManyInput[]
  }

  /**
   * NamespacePermission createManyAndReturn
   */
  export type NamespacePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many NamespacePermissions.
     */
    data: NamespacePermissionCreateManyInput | NamespacePermissionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NamespacePermission update
   */
  export type NamespacePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a NamespacePermission.
     */
    data: XOR<NamespacePermissionUpdateInput, NamespacePermissionUncheckedUpdateInput>
    /**
     * Choose, which NamespacePermission to update.
     */
    where: NamespacePermissionWhereUniqueInput
  }

  /**
   * NamespacePermission updateMany
   */
  export type NamespacePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NamespacePermissions.
     */
    data: XOR<NamespacePermissionUpdateManyMutationInput, NamespacePermissionUncheckedUpdateManyInput>
    /**
     * Filter which NamespacePermissions to update
     */
    where?: NamespacePermissionWhereInput
    /**
     * Limit how many NamespacePermissions to update.
     */
    limit?: number
  }

  /**
   * NamespacePermission updateManyAndReturn
   */
  export type NamespacePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * The data used to update NamespacePermissions.
     */
    data: XOR<NamespacePermissionUpdateManyMutationInput, NamespacePermissionUncheckedUpdateManyInput>
    /**
     * Filter which NamespacePermissions to update
     */
    where?: NamespacePermissionWhereInput
    /**
     * Limit how many NamespacePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NamespacePermission upsert
   */
  export type NamespacePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the NamespacePermission to update in case it exists.
     */
    where: NamespacePermissionWhereUniqueInput
    /**
     * In case the NamespacePermission found by the `where` argument doesn't exist, create a new NamespacePermission with this data.
     */
    create: XOR<NamespacePermissionCreateInput, NamespacePermissionUncheckedCreateInput>
    /**
     * In case the NamespacePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NamespacePermissionUpdateInput, NamespacePermissionUncheckedUpdateInput>
  }

  /**
   * NamespacePermission delete
   */
  export type NamespacePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionInclude<ExtArgs> | null
    /**
     * Filter which NamespacePermission to delete.
     */
    where: NamespacePermissionWhereUniqueInput
  }

  /**
   * NamespacePermission deleteMany
   */
  export type NamespacePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NamespacePermissions to delete
     */
    where?: NamespacePermissionWhereInput
    /**
     * Limit how many NamespacePermissions to delete.
     */
    limit?: number
  }

  /**
   * NamespacePermission.user
   */
  export type NamespacePermission$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * NamespacePermission.group
   */
  export type NamespacePermission$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
  }

  /**
   * NamespacePermission without action
   */
  export type NamespacePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamespacePermission
     */
    select?: NamespacePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NamespacePermission
     */
    omit?: NamespacePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamespacePermissionInclude<ExtArgs> | null
  }


  /**
   * Model ModulePermission
   */

  export type AggregateModulePermission = {
    _count: ModulePermissionCountAggregateOutputType | null
    _min: ModulePermissionMinAggregateOutputType | null
    _max: ModulePermissionMaxAggregateOutputType | null
  }

  export type ModulePermissionMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    module: string | null
    canRead: boolean | null
    canWrite: boolean | null
    canDelete: boolean | null
    createdAt: Date | null
  }

  export type ModulePermissionMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    module: string | null
    canRead: boolean | null
    canWrite: boolean | null
    canDelete: boolean | null
    createdAt: Date | null
  }

  export type ModulePermissionCountAggregateOutputType = {
    id: number
    groupId: number
    module: number
    canRead: number
    canWrite: number
    canDelete: number
    createdAt: number
    _all: number
  }


  export type ModulePermissionMinAggregateInputType = {
    id?: true
    groupId?: true
    module?: true
    canRead?: true
    canWrite?: true
    canDelete?: true
    createdAt?: true
  }

  export type ModulePermissionMaxAggregateInputType = {
    id?: true
    groupId?: true
    module?: true
    canRead?: true
    canWrite?: true
    canDelete?: true
    createdAt?: true
  }

  export type ModulePermissionCountAggregateInputType = {
    id?: true
    groupId?: true
    module?: true
    canRead?: true
    canWrite?: true
    canDelete?: true
    createdAt?: true
    _all?: true
  }

  export type ModulePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModulePermission to aggregate.
     */
    where?: ModulePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePermissions to fetch.
     */
    orderBy?: ModulePermissionOrderByWithRelationInput | ModulePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModulePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModulePermissions
    **/
    _count?: true | ModulePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModulePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModulePermissionMaxAggregateInputType
  }

  export type GetModulePermissionAggregateType<T extends ModulePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateModulePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModulePermission[P]>
      : GetScalarType<T[P], AggregateModulePermission[P]>
  }




  export type ModulePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModulePermissionWhereInput
    orderBy?: ModulePermissionOrderByWithAggregationInput | ModulePermissionOrderByWithAggregationInput[]
    by: ModulePermissionScalarFieldEnum[] | ModulePermissionScalarFieldEnum
    having?: ModulePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModulePermissionCountAggregateInputType | true
    _min?: ModulePermissionMinAggregateInputType
    _max?: ModulePermissionMaxAggregateInputType
  }

  export type ModulePermissionGroupByOutputType = {
    id: string
    groupId: string
    module: string
    canRead: boolean
    canWrite: boolean
    canDelete: boolean
    createdAt: Date
    _count: ModulePermissionCountAggregateOutputType | null
    _min: ModulePermissionMinAggregateOutputType | null
    _max: ModulePermissionMaxAggregateOutputType | null
  }

  type GetModulePermissionGroupByPayload<T extends ModulePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModulePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModulePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModulePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], ModulePermissionGroupByOutputType[P]>
        }
      >
    >


  export type ModulePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    module?: boolean
    canRead?: boolean
    canWrite?: boolean
    canDelete?: boolean
    createdAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulePermission"]>

  export type ModulePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    module?: boolean
    canRead?: boolean
    canWrite?: boolean
    canDelete?: boolean
    createdAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulePermission"]>

  export type ModulePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    module?: boolean
    canRead?: boolean
    canWrite?: boolean
    canDelete?: boolean
    createdAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulePermission"]>

  export type ModulePermissionSelectScalar = {
    id?: boolean
    groupId?: boolean
    module?: boolean
    canRead?: boolean
    canWrite?: boolean
    canDelete?: boolean
    createdAt?: boolean
  }

  export type ModulePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "module" | "canRead" | "canWrite" | "canDelete" | "createdAt", ExtArgs["result"]["modulePermission"]>
  export type ModulePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type ModulePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type ModulePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $ModulePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModulePermission"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      module: string
      canRead: boolean
      canWrite: boolean
      canDelete: boolean
      createdAt: Date
    }, ExtArgs["result"]["modulePermission"]>
    composites: {}
  }

  type ModulePermissionGetPayload<S extends boolean | null | undefined | ModulePermissionDefaultArgs> = $Result.GetResult<Prisma.$ModulePermissionPayload, S>

  type ModulePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModulePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModulePermissionCountAggregateInputType | true
    }

  export interface ModulePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModulePermission'], meta: { name: 'ModulePermission' } }
    /**
     * Find zero or one ModulePermission that matches the filter.
     * @param {ModulePermissionFindUniqueArgs} args - Arguments to find a ModulePermission
     * @example
     * // Get one ModulePermission
     * const modulePermission = await prisma.modulePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModulePermissionFindUniqueArgs>(args: SelectSubset<T, ModulePermissionFindUniqueArgs<ExtArgs>>): Prisma__ModulePermissionClient<$Result.GetResult<Prisma.$ModulePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModulePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModulePermissionFindUniqueOrThrowArgs} args - Arguments to find a ModulePermission
     * @example
     * // Get one ModulePermission
     * const modulePermission = await prisma.modulePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModulePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ModulePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModulePermissionClient<$Result.GetResult<Prisma.$ModulePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModulePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePermissionFindFirstArgs} args - Arguments to find a ModulePermission
     * @example
     * // Get one ModulePermission
     * const modulePermission = await prisma.modulePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModulePermissionFindFirstArgs>(args?: SelectSubset<T, ModulePermissionFindFirstArgs<ExtArgs>>): Prisma__ModulePermissionClient<$Result.GetResult<Prisma.$ModulePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModulePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePermissionFindFirstOrThrowArgs} args - Arguments to find a ModulePermission
     * @example
     * // Get one ModulePermission
     * const modulePermission = await prisma.modulePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModulePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ModulePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModulePermissionClient<$Result.GetResult<Prisma.$ModulePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModulePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModulePermissions
     * const modulePermissions = await prisma.modulePermission.findMany()
     * 
     * // Get first 10 ModulePermissions
     * const modulePermissions = await prisma.modulePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modulePermissionWithIdOnly = await prisma.modulePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModulePermissionFindManyArgs>(args?: SelectSubset<T, ModulePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModulePermission.
     * @param {ModulePermissionCreateArgs} args - Arguments to create a ModulePermission.
     * @example
     * // Create one ModulePermission
     * const ModulePermission = await prisma.modulePermission.create({
     *   data: {
     *     // ... data to create a ModulePermission
     *   }
     * })
     * 
     */
    create<T extends ModulePermissionCreateArgs>(args: SelectSubset<T, ModulePermissionCreateArgs<ExtArgs>>): Prisma__ModulePermissionClient<$Result.GetResult<Prisma.$ModulePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModulePermissions.
     * @param {ModulePermissionCreateManyArgs} args - Arguments to create many ModulePermissions.
     * @example
     * // Create many ModulePermissions
     * const modulePermission = await prisma.modulePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModulePermissionCreateManyArgs>(args?: SelectSubset<T, ModulePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModulePermissions and returns the data saved in the database.
     * @param {ModulePermissionCreateManyAndReturnArgs} args - Arguments to create many ModulePermissions.
     * @example
     * // Create many ModulePermissions
     * const modulePermission = await prisma.modulePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModulePermissions and only return the `id`
     * const modulePermissionWithIdOnly = await prisma.modulePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModulePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ModulePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModulePermission.
     * @param {ModulePermissionDeleteArgs} args - Arguments to delete one ModulePermission.
     * @example
     * // Delete one ModulePermission
     * const ModulePermission = await prisma.modulePermission.delete({
     *   where: {
     *     // ... filter to delete one ModulePermission
     *   }
     * })
     * 
     */
    delete<T extends ModulePermissionDeleteArgs>(args: SelectSubset<T, ModulePermissionDeleteArgs<ExtArgs>>): Prisma__ModulePermissionClient<$Result.GetResult<Prisma.$ModulePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModulePermission.
     * @param {ModulePermissionUpdateArgs} args - Arguments to update one ModulePermission.
     * @example
     * // Update one ModulePermission
     * const modulePermission = await prisma.modulePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModulePermissionUpdateArgs>(args: SelectSubset<T, ModulePermissionUpdateArgs<ExtArgs>>): Prisma__ModulePermissionClient<$Result.GetResult<Prisma.$ModulePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModulePermissions.
     * @param {ModulePermissionDeleteManyArgs} args - Arguments to filter ModulePermissions to delete.
     * @example
     * // Delete a few ModulePermissions
     * const { count } = await prisma.modulePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModulePermissionDeleteManyArgs>(args?: SelectSubset<T, ModulePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModulePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModulePermissions
     * const modulePermission = await prisma.modulePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModulePermissionUpdateManyArgs>(args: SelectSubset<T, ModulePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModulePermissions and returns the data updated in the database.
     * @param {ModulePermissionUpdateManyAndReturnArgs} args - Arguments to update many ModulePermissions.
     * @example
     * // Update many ModulePermissions
     * const modulePermission = await prisma.modulePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModulePermissions and only return the `id`
     * const modulePermissionWithIdOnly = await prisma.modulePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModulePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, ModulePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModulePermission.
     * @param {ModulePermissionUpsertArgs} args - Arguments to update or create a ModulePermission.
     * @example
     * // Update or create a ModulePermission
     * const modulePermission = await prisma.modulePermission.upsert({
     *   create: {
     *     // ... data to create a ModulePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModulePermission we want to update
     *   }
     * })
     */
    upsert<T extends ModulePermissionUpsertArgs>(args: SelectSubset<T, ModulePermissionUpsertArgs<ExtArgs>>): Prisma__ModulePermissionClient<$Result.GetResult<Prisma.$ModulePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModulePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePermissionCountArgs} args - Arguments to filter ModulePermissions to count.
     * @example
     * // Count the number of ModulePermissions
     * const count = await prisma.modulePermission.count({
     *   where: {
     *     // ... the filter for the ModulePermissions we want to count
     *   }
     * })
    **/
    count<T extends ModulePermissionCountArgs>(
      args?: Subset<T, ModulePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModulePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModulePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModulePermissionAggregateArgs>(args: Subset<T, ModulePermissionAggregateArgs>): Prisma.PrismaPromise<GetModulePermissionAggregateType<T>>

    /**
     * Group by ModulePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModulePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModulePermissionGroupByArgs['orderBy'] }
        : { orderBy?: ModulePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModulePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModulePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModulePermission model
   */
  readonly fields: ModulePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModulePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModulePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModulePermission model
   */
  interface ModulePermissionFieldRefs {
    readonly id: FieldRef<"ModulePermission", 'String'>
    readonly groupId: FieldRef<"ModulePermission", 'String'>
    readonly module: FieldRef<"ModulePermission", 'String'>
    readonly canRead: FieldRef<"ModulePermission", 'Boolean'>
    readonly canWrite: FieldRef<"ModulePermission", 'Boolean'>
    readonly canDelete: FieldRef<"ModulePermission", 'Boolean'>
    readonly createdAt: FieldRef<"ModulePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModulePermission findUnique
   */
  export type ModulePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePermission
     */
    select?: ModulePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePermission
     */
    omit?: ModulePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePermissionInclude<ExtArgs> | null
    /**
     * Filter, which ModulePermission to fetch.
     */
    where: ModulePermissionWhereUniqueInput
  }

  /**
   * ModulePermission findUniqueOrThrow
   */
  export type ModulePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePermission
     */
    select?: ModulePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePermission
     */
    omit?: ModulePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePermissionInclude<ExtArgs> | null
    /**
     * Filter, which ModulePermission to fetch.
     */
    where: ModulePermissionWhereUniqueInput
  }

  /**
   * ModulePermission findFirst
   */
  export type ModulePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePermission
     */
    select?: ModulePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePermission
     */
    omit?: ModulePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePermissionInclude<ExtArgs> | null
    /**
     * Filter, which ModulePermission to fetch.
     */
    where?: ModulePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePermissions to fetch.
     */
    orderBy?: ModulePermissionOrderByWithRelationInput | ModulePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModulePermissions.
     */
    cursor?: ModulePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModulePermissions.
     */
    distinct?: ModulePermissionScalarFieldEnum | ModulePermissionScalarFieldEnum[]
  }

  /**
   * ModulePermission findFirstOrThrow
   */
  export type ModulePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePermission
     */
    select?: ModulePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePermission
     */
    omit?: ModulePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePermissionInclude<ExtArgs> | null
    /**
     * Filter, which ModulePermission to fetch.
     */
    where?: ModulePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePermissions to fetch.
     */
    orderBy?: ModulePermissionOrderByWithRelationInput | ModulePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModulePermissions.
     */
    cursor?: ModulePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModulePermissions.
     */
    distinct?: ModulePermissionScalarFieldEnum | ModulePermissionScalarFieldEnum[]
  }

  /**
   * ModulePermission findMany
   */
  export type ModulePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePermission
     */
    select?: ModulePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePermission
     */
    omit?: ModulePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePermissionInclude<ExtArgs> | null
    /**
     * Filter, which ModulePermissions to fetch.
     */
    where?: ModulePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePermissions to fetch.
     */
    orderBy?: ModulePermissionOrderByWithRelationInput | ModulePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModulePermissions.
     */
    cursor?: ModulePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePermissions.
     */
    skip?: number
    distinct?: ModulePermissionScalarFieldEnum | ModulePermissionScalarFieldEnum[]
  }

  /**
   * ModulePermission create
   */
  export type ModulePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePermission
     */
    select?: ModulePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePermission
     */
    omit?: ModulePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a ModulePermission.
     */
    data: XOR<ModulePermissionCreateInput, ModulePermissionUncheckedCreateInput>
  }

  /**
   * ModulePermission createMany
   */
  export type ModulePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModulePermissions.
     */
    data: ModulePermissionCreateManyInput | ModulePermissionCreateManyInput[]
  }

  /**
   * ModulePermission createManyAndReturn
   */
  export type ModulePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePermission
     */
    select?: ModulePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePermission
     */
    omit?: ModulePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many ModulePermissions.
     */
    data: ModulePermissionCreateManyInput | ModulePermissionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModulePermission update
   */
  export type ModulePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePermission
     */
    select?: ModulePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePermission
     */
    omit?: ModulePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a ModulePermission.
     */
    data: XOR<ModulePermissionUpdateInput, ModulePermissionUncheckedUpdateInput>
    /**
     * Choose, which ModulePermission to update.
     */
    where: ModulePermissionWhereUniqueInput
  }

  /**
   * ModulePermission updateMany
   */
  export type ModulePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModulePermissions.
     */
    data: XOR<ModulePermissionUpdateManyMutationInput, ModulePermissionUncheckedUpdateManyInput>
    /**
     * Filter which ModulePermissions to update
     */
    where?: ModulePermissionWhereInput
    /**
     * Limit how many ModulePermissions to update.
     */
    limit?: number
  }

  /**
   * ModulePermission updateManyAndReturn
   */
  export type ModulePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePermission
     */
    select?: ModulePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePermission
     */
    omit?: ModulePermissionOmit<ExtArgs> | null
    /**
     * The data used to update ModulePermissions.
     */
    data: XOR<ModulePermissionUpdateManyMutationInput, ModulePermissionUncheckedUpdateManyInput>
    /**
     * Filter which ModulePermissions to update
     */
    where?: ModulePermissionWhereInput
    /**
     * Limit how many ModulePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModulePermission upsert
   */
  export type ModulePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePermission
     */
    select?: ModulePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePermission
     */
    omit?: ModulePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the ModulePermission to update in case it exists.
     */
    where: ModulePermissionWhereUniqueInput
    /**
     * In case the ModulePermission found by the `where` argument doesn't exist, create a new ModulePermission with this data.
     */
    create: XOR<ModulePermissionCreateInput, ModulePermissionUncheckedCreateInput>
    /**
     * In case the ModulePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModulePermissionUpdateInput, ModulePermissionUncheckedUpdateInput>
  }

  /**
   * ModulePermission delete
   */
  export type ModulePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePermission
     */
    select?: ModulePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePermission
     */
    omit?: ModulePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePermissionInclude<ExtArgs> | null
    /**
     * Filter which ModulePermission to delete.
     */
    where: ModulePermissionWhereUniqueInput
  }

  /**
   * ModulePermission deleteMany
   */
  export type ModulePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModulePermissions to delete
     */
    where?: ModulePermissionWhereInput
    /**
     * Limit how many ModulePermissions to delete.
     */
    limit?: number
  }

  /**
   * ModulePermission without action
   */
  export type ModulePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePermission
     */
    select?: ModulePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModulePermission
     */
    omit?: ModulePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePermissionInclude<ExtArgs> | null
  }


  /**
   * Model Credential
   */

  export type AggregateCredential = {
    _count: CredentialCountAggregateOutputType | null
    _min: CredentialMinAggregateOutputType | null
    _max: CredentialMaxAggregateOutputType | null
  }

  export type CredentialMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    credentialType: string | null
    username: string | null
    password: string | null
    sshPrivateKey: string | null
    vaultPassword: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CredentialMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    credentialType: string | null
    username: string | null
    password: string | null
    sshPrivateKey: string | null
    vaultPassword: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CredentialCountAggregateOutputType = {
    id: number
    name: number
    description: number
    credentialType: number
    username: number
    password: number
    sshPrivateKey: number
    vaultPassword: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CredentialMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    credentialType?: true
    username?: true
    password?: true
    sshPrivateKey?: true
    vaultPassword?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CredentialMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    credentialType?: true
    username?: true
    password?: true
    sshPrivateKey?: true
    vaultPassword?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CredentialCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    credentialType?: true
    username?: true
    password?: true
    sshPrivateKey?: true
    vaultPassword?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CredentialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credential to aggregate.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Credentials
    **/
    _count?: true | CredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CredentialMaxAggregateInputType
  }

  export type GetCredentialAggregateType<T extends CredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredential[P]>
      : GetScalarType<T[P], AggregateCredential[P]>
  }




  export type CredentialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CredentialWhereInput
    orderBy?: CredentialOrderByWithAggregationInput | CredentialOrderByWithAggregationInput[]
    by: CredentialScalarFieldEnum[] | CredentialScalarFieldEnum
    having?: CredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CredentialCountAggregateInputType | true
    _min?: CredentialMinAggregateInputType
    _max?: CredentialMaxAggregateInputType
  }

  export type CredentialGroupByOutputType = {
    id: string
    name: string
    description: string | null
    credentialType: string
    username: string | null
    password: string | null
    sshPrivateKey: string | null
    vaultPassword: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: CredentialCountAggregateOutputType | null
    _min: CredentialMinAggregateOutputType | null
    _max: CredentialMaxAggregateOutputType | null
  }

  type GetCredentialGroupByPayload<T extends CredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CredentialGroupByOutputType[P]>
            : GetScalarType<T[P], CredentialGroupByOutputType[P]>
        }
      >
    >


  export type CredentialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    credentialType?: boolean
    username?: boolean
    password?: boolean
    sshPrivateKey?: boolean
    vaultPassword?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    credentialType?: boolean
    username?: boolean
    password?: boolean
    sshPrivateKey?: boolean
    vaultPassword?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    credentialType?: boolean
    username?: boolean
    password?: boolean
    sshPrivateKey?: boolean
    vaultPassword?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    credentialType?: boolean
    username?: boolean
    password?: boolean
    sshPrivateKey?: boolean
    vaultPassword?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CredentialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "credentialType" | "username" | "password" | "sshPrivateKey" | "vaultPassword" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["credential"]>

  export type $CredentialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Credential"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      credentialType: string
      username: string | null
      password: string | null
      sshPrivateKey: string | null
      vaultPassword: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["credential"]>
    composites: {}
  }

  type CredentialGetPayload<S extends boolean | null | undefined | CredentialDefaultArgs> = $Result.GetResult<Prisma.$CredentialPayload, S>

  type CredentialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CredentialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CredentialCountAggregateInputType | true
    }

  export interface CredentialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Credential'], meta: { name: 'Credential' } }
    /**
     * Find zero or one Credential that matches the filter.
     * @param {CredentialFindUniqueArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CredentialFindUniqueArgs>(args: SelectSubset<T, CredentialFindUniqueArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Credential that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CredentialFindUniqueOrThrowArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CredentialFindUniqueOrThrowArgs>(args: SelectSubset<T, CredentialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindFirstArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CredentialFindFirstArgs>(args?: SelectSubset<T, CredentialFindFirstArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindFirstOrThrowArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CredentialFindFirstOrThrowArgs>(args?: SelectSubset<T, CredentialFindFirstOrThrowArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Credentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credentials
     * const credentials = await prisma.credential.findMany()
     * 
     * // Get first 10 Credentials
     * const credentials = await prisma.credential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const credentialWithIdOnly = await prisma.credential.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CredentialFindManyArgs>(args?: SelectSubset<T, CredentialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Credential.
     * @param {CredentialCreateArgs} args - Arguments to create a Credential.
     * @example
     * // Create one Credential
     * const Credential = await prisma.credential.create({
     *   data: {
     *     // ... data to create a Credential
     *   }
     * })
     * 
     */
    create<T extends CredentialCreateArgs>(args: SelectSubset<T, CredentialCreateArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Credentials.
     * @param {CredentialCreateManyArgs} args - Arguments to create many Credentials.
     * @example
     * // Create many Credentials
     * const credential = await prisma.credential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CredentialCreateManyArgs>(args?: SelectSubset<T, CredentialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Credentials and returns the data saved in the database.
     * @param {CredentialCreateManyAndReturnArgs} args - Arguments to create many Credentials.
     * @example
     * // Create many Credentials
     * const credential = await prisma.credential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Credentials and only return the `id`
     * const credentialWithIdOnly = await prisma.credential.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CredentialCreateManyAndReturnArgs>(args?: SelectSubset<T, CredentialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Credential.
     * @param {CredentialDeleteArgs} args - Arguments to delete one Credential.
     * @example
     * // Delete one Credential
     * const Credential = await prisma.credential.delete({
     *   where: {
     *     // ... filter to delete one Credential
     *   }
     * })
     * 
     */
    delete<T extends CredentialDeleteArgs>(args: SelectSubset<T, CredentialDeleteArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Credential.
     * @param {CredentialUpdateArgs} args - Arguments to update one Credential.
     * @example
     * // Update one Credential
     * const credential = await prisma.credential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CredentialUpdateArgs>(args: SelectSubset<T, CredentialUpdateArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Credentials.
     * @param {CredentialDeleteManyArgs} args - Arguments to filter Credentials to delete.
     * @example
     * // Delete a few Credentials
     * const { count } = await prisma.credential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CredentialDeleteManyArgs>(args?: SelectSubset<T, CredentialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credentials
     * const credential = await prisma.credential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CredentialUpdateManyArgs>(args: SelectSubset<T, CredentialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credentials and returns the data updated in the database.
     * @param {CredentialUpdateManyAndReturnArgs} args - Arguments to update many Credentials.
     * @example
     * // Update many Credentials
     * const credential = await prisma.credential.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Credentials and only return the `id`
     * const credentialWithIdOnly = await prisma.credential.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CredentialUpdateManyAndReturnArgs>(args: SelectSubset<T, CredentialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Credential.
     * @param {CredentialUpsertArgs} args - Arguments to update or create a Credential.
     * @example
     * // Update or create a Credential
     * const credential = await prisma.credential.upsert({
     *   create: {
     *     // ... data to create a Credential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credential we want to update
     *   }
     * })
     */
    upsert<T extends CredentialUpsertArgs>(args: SelectSubset<T, CredentialUpsertArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialCountArgs} args - Arguments to filter Credentials to count.
     * @example
     * // Count the number of Credentials
     * const count = await prisma.credential.count({
     *   where: {
     *     // ... the filter for the Credentials we want to count
     *   }
     * })
    **/
    count<T extends CredentialCountArgs>(
      args?: Subset<T, CredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CredentialAggregateArgs>(args: Subset<T, CredentialAggregateArgs>): Prisma.PrismaPromise<GetCredentialAggregateType<T>>

    /**
     * Group by Credential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CredentialGroupByArgs['orderBy'] }
        : { orderBy?: CredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Credential model
   */
  readonly fields: CredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Credential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CredentialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Credential model
   */
  interface CredentialFieldRefs {
    readonly id: FieldRef<"Credential", 'String'>
    readonly name: FieldRef<"Credential", 'String'>
    readonly description: FieldRef<"Credential", 'String'>
    readonly credentialType: FieldRef<"Credential", 'String'>
    readonly username: FieldRef<"Credential", 'String'>
    readonly password: FieldRef<"Credential", 'String'>
    readonly sshPrivateKey: FieldRef<"Credential", 'String'>
    readonly vaultPassword: FieldRef<"Credential", 'String'>
    readonly createdBy: FieldRef<"Credential", 'String'>
    readonly createdAt: FieldRef<"Credential", 'DateTime'>
    readonly updatedAt: FieldRef<"Credential", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Credential findUnique
   */
  export type CredentialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential findUniqueOrThrow
   */
  export type CredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential findFirst
   */
  export type CredentialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credentials.
     */
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential findFirstOrThrow
   */
  export type CredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credentials.
     */
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential findMany
   */
  export type CredentialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Filter, which Credentials to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential create
   */
  export type CredentialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * The data needed to create a Credential.
     */
    data: XOR<CredentialCreateInput, CredentialUncheckedCreateInput>
  }

  /**
   * Credential createMany
   */
  export type CredentialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Credentials.
     */
    data: CredentialCreateManyInput | CredentialCreateManyInput[]
  }

  /**
   * Credential createManyAndReturn
   */
  export type CredentialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * The data used to create many Credentials.
     */
    data: CredentialCreateManyInput | CredentialCreateManyInput[]
  }

  /**
   * Credential update
   */
  export type CredentialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * The data needed to update a Credential.
     */
    data: XOR<CredentialUpdateInput, CredentialUncheckedUpdateInput>
    /**
     * Choose, which Credential to update.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential updateMany
   */
  export type CredentialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Credentials.
     */
    data: XOR<CredentialUpdateManyMutationInput, CredentialUncheckedUpdateManyInput>
    /**
     * Filter which Credentials to update
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to update.
     */
    limit?: number
  }

  /**
   * Credential updateManyAndReturn
   */
  export type CredentialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * The data used to update Credentials.
     */
    data: XOR<CredentialUpdateManyMutationInput, CredentialUncheckedUpdateManyInput>
    /**
     * Filter which Credentials to update
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to update.
     */
    limit?: number
  }

  /**
   * Credential upsert
   */
  export type CredentialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * The filter to search for the Credential to update in case it exists.
     */
    where: CredentialWhereUniqueInput
    /**
     * In case the Credential found by the `where` argument doesn't exist, create a new Credential with this data.
     */
    create: XOR<CredentialCreateInput, CredentialUncheckedCreateInput>
    /**
     * In case the Credential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CredentialUpdateInput, CredentialUncheckedUpdateInput>
  }

  /**
   * Credential delete
   */
  export type CredentialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Filter which Credential to delete.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential deleteMany
   */
  export type CredentialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credentials to delete
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to delete.
     */
    limit?: number
  }

  /**
   * Credential without action
   */
  export type CredentialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["setting"]>

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'String'>
    readonly key: FieldRef<"Setting", 'String'>
    readonly value: FieldRef<"Setting", 'String'>
    readonly description: FieldRef<"Setting", 'String'>
    readonly createdAt: FieldRef<"Setting", 'DateTime'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
  }

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting updateManyAndReturn
   */
  export type SettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    entityName: string | null
    description: string | null
    performedBy: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    entityName: string | null
    description: string | null
    performedBy: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    action: number
    entityType: number
    entityId: number
    entityName: number
    description: number
    performedBy: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    entityName?: true
    description?: true
    performedBy?: true
    metadata?: true
    createdAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    entityName?: true
    description?: true
    performedBy?: true
    metadata?: true
    createdAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    entityName?: true
    description?: true
    performedBy?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    action: string
    entityType: string
    entityId: string
    entityName: string
    description: string | null
    performedBy: string
    metadata: string | null
    createdAt: Date
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    entityName?: boolean
    description?: boolean
    performedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    entityName?: boolean
    description?: boolean
    performedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    entityName?: boolean
    description?: boolean
    performedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    entityName?: boolean
    description?: boolean
    performedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "entityType" | "entityId" | "entityName" | "description" | "performedBy" | "metadata" | "createdAt", ExtArgs["result"]["activity"]>

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      entityType: string
      entityId: string
      entityName: string
      description: string | null
      performedBy: string
      metadata: string | null
      createdAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly action: FieldRef<"Activity", 'String'>
    readonly entityType: FieldRef<"Activity", 'String'>
    readonly entityId: FieldRef<"Activity", 'String'>
    readonly entityName: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly performedBy: FieldRef<"Activity", 'String'>
    readonly metadata: FieldRef<"Activity", 'String'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
  }


  /**
   * Model RunCounter
   */

  export type AggregateRunCounter = {
    _count: RunCounterCountAggregateOutputType | null
    _avg: RunCounterAvgAggregateOutputType | null
    _sum: RunCounterSumAggregateOutputType | null
    _min: RunCounterMinAggregateOutputType | null
    _max: RunCounterMaxAggregateOutputType | null
  }

  export type RunCounterAvgAggregateOutputType = {
    year: number | null
    sequence: number | null
  }

  export type RunCounterSumAggregateOutputType = {
    year: number | null
    sequence: number | null
  }

  export type RunCounterMinAggregateOutputType = {
    id: string | null
    year: number | null
    pool: string | null
    sequence: number | null
    lastUsed: Date | null
  }

  export type RunCounterMaxAggregateOutputType = {
    id: string | null
    year: number | null
    pool: string | null
    sequence: number | null
    lastUsed: Date | null
  }

  export type RunCounterCountAggregateOutputType = {
    id: number
    year: number
    pool: number
    sequence: number
    lastUsed: number
    _all: number
  }


  export type RunCounterAvgAggregateInputType = {
    year?: true
    sequence?: true
  }

  export type RunCounterSumAggregateInputType = {
    year?: true
    sequence?: true
  }

  export type RunCounterMinAggregateInputType = {
    id?: true
    year?: true
    pool?: true
    sequence?: true
    lastUsed?: true
  }

  export type RunCounterMaxAggregateInputType = {
    id?: true
    year?: true
    pool?: true
    sequence?: true
    lastUsed?: true
  }

  export type RunCounterCountAggregateInputType = {
    id?: true
    year?: true
    pool?: true
    sequence?: true
    lastUsed?: true
    _all?: true
  }

  export type RunCounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCounter to aggregate.
     */
    where?: RunCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCounters to fetch.
     */
    orderBy?: RunCounterOrderByWithRelationInput | RunCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RunCounters
    **/
    _count?: true | RunCounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RunCounterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RunCounterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunCounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunCounterMaxAggregateInputType
  }

  export type GetRunCounterAggregateType<T extends RunCounterAggregateArgs> = {
        [P in keyof T & keyof AggregateRunCounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRunCounter[P]>
      : GetScalarType<T[P], AggregateRunCounter[P]>
  }




  export type RunCounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunCounterWhereInput
    orderBy?: RunCounterOrderByWithAggregationInput | RunCounterOrderByWithAggregationInput[]
    by: RunCounterScalarFieldEnum[] | RunCounterScalarFieldEnum
    having?: RunCounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCounterCountAggregateInputType | true
    _avg?: RunCounterAvgAggregateInputType
    _sum?: RunCounterSumAggregateInputType
    _min?: RunCounterMinAggregateInputType
    _max?: RunCounterMaxAggregateInputType
  }

  export type RunCounterGroupByOutputType = {
    id: string
    year: number
    pool: string
    sequence: number
    lastUsed: Date
    _count: RunCounterCountAggregateOutputType | null
    _avg: RunCounterAvgAggregateOutputType | null
    _sum: RunCounterSumAggregateOutputType | null
    _min: RunCounterMinAggregateOutputType | null
    _max: RunCounterMaxAggregateOutputType | null
  }

  type GetRunCounterGroupByPayload<T extends RunCounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunCounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunCounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunCounterGroupByOutputType[P]>
            : GetScalarType<T[P], RunCounterGroupByOutputType[P]>
        }
      >
    >


  export type RunCounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    pool?: boolean
    sequence?: boolean
    lastUsed?: boolean
  }, ExtArgs["result"]["runCounter"]>

  export type RunCounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    pool?: boolean
    sequence?: boolean
    lastUsed?: boolean
  }, ExtArgs["result"]["runCounter"]>

  export type RunCounterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    pool?: boolean
    sequence?: boolean
    lastUsed?: boolean
  }, ExtArgs["result"]["runCounter"]>

  export type RunCounterSelectScalar = {
    id?: boolean
    year?: boolean
    pool?: boolean
    sequence?: boolean
    lastUsed?: boolean
  }

  export type RunCounterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "pool" | "sequence" | "lastUsed", ExtArgs["result"]["runCounter"]>

  export type $RunCounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RunCounter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: number
      pool: string
      sequence: number
      lastUsed: Date
    }, ExtArgs["result"]["runCounter"]>
    composites: {}
  }

  type RunCounterGetPayload<S extends boolean | null | undefined | RunCounterDefaultArgs> = $Result.GetResult<Prisma.$RunCounterPayload, S>

  type RunCounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunCounterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCounterCountAggregateInputType | true
    }

  export interface RunCounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RunCounter'], meta: { name: 'RunCounter' } }
    /**
     * Find zero or one RunCounter that matches the filter.
     * @param {RunCounterFindUniqueArgs} args - Arguments to find a RunCounter
     * @example
     * // Get one RunCounter
     * const runCounter = await prisma.runCounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunCounterFindUniqueArgs>(args: SelectSubset<T, RunCounterFindUniqueArgs<ExtArgs>>): Prisma__RunCounterClient<$Result.GetResult<Prisma.$RunCounterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RunCounter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunCounterFindUniqueOrThrowArgs} args - Arguments to find a RunCounter
     * @example
     * // Get one RunCounter
     * const runCounter = await prisma.runCounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunCounterFindUniqueOrThrowArgs>(args: SelectSubset<T, RunCounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunCounterClient<$Result.GetResult<Prisma.$RunCounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCounterFindFirstArgs} args - Arguments to find a RunCounter
     * @example
     * // Get one RunCounter
     * const runCounter = await prisma.runCounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunCounterFindFirstArgs>(args?: SelectSubset<T, RunCounterFindFirstArgs<ExtArgs>>): Prisma__RunCounterClient<$Result.GetResult<Prisma.$RunCounterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RunCounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCounterFindFirstOrThrowArgs} args - Arguments to find a RunCounter
     * @example
     * // Get one RunCounter
     * const runCounter = await prisma.runCounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunCounterFindFirstOrThrowArgs>(args?: SelectSubset<T, RunCounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunCounterClient<$Result.GetResult<Prisma.$RunCounterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RunCounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RunCounters
     * const runCounters = await prisma.runCounter.findMany()
     * 
     * // Get first 10 RunCounters
     * const runCounters = await prisma.runCounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runCounterWithIdOnly = await prisma.runCounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunCounterFindManyArgs>(args?: SelectSubset<T, RunCounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RunCounter.
     * @param {RunCounterCreateArgs} args - Arguments to create a RunCounter.
     * @example
     * // Create one RunCounter
     * const RunCounter = await prisma.runCounter.create({
     *   data: {
     *     // ... data to create a RunCounter
     *   }
     * })
     * 
     */
    create<T extends RunCounterCreateArgs>(args: SelectSubset<T, RunCounterCreateArgs<ExtArgs>>): Prisma__RunCounterClient<$Result.GetResult<Prisma.$RunCounterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RunCounters.
     * @param {RunCounterCreateManyArgs} args - Arguments to create many RunCounters.
     * @example
     * // Create many RunCounters
     * const runCounter = await prisma.runCounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCounterCreateManyArgs>(args?: SelectSubset<T, RunCounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RunCounters and returns the data saved in the database.
     * @param {RunCounterCreateManyAndReturnArgs} args - Arguments to create many RunCounters.
     * @example
     * // Create many RunCounters
     * const runCounter = await prisma.runCounter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RunCounters and only return the `id`
     * const runCounterWithIdOnly = await prisma.runCounter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCounterCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCounterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RunCounter.
     * @param {RunCounterDeleteArgs} args - Arguments to delete one RunCounter.
     * @example
     * // Delete one RunCounter
     * const RunCounter = await prisma.runCounter.delete({
     *   where: {
     *     // ... filter to delete one RunCounter
     *   }
     * })
     * 
     */
    delete<T extends RunCounterDeleteArgs>(args: SelectSubset<T, RunCounterDeleteArgs<ExtArgs>>): Prisma__RunCounterClient<$Result.GetResult<Prisma.$RunCounterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RunCounter.
     * @param {RunCounterUpdateArgs} args - Arguments to update one RunCounter.
     * @example
     * // Update one RunCounter
     * const runCounter = await prisma.runCounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunCounterUpdateArgs>(args: SelectSubset<T, RunCounterUpdateArgs<ExtArgs>>): Prisma__RunCounterClient<$Result.GetResult<Prisma.$RunCounterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RunCounters.
     * @param {RunCounterDeleteManyArgs} args - Arguments to filter RunCounters to delete.
     * @example
     * // Delete a few RunCounters
     * const { count } = await prisma.runCounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunCounterDeleteManyArgs>(args?: SelectSubset<T, RunCounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RunCounters
     * const runCounter = await prisma.runCounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunCounterUpdateManyArgs>(args: SelectSubset<T, RunCounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RunCounters and returns the data updated in the database.
     * @param {RunCounterUpdateManyAndReturnArgs} args - Arguments to update many RunCounters.
     * @example
     * // Update many RunCounters
     * const runCounter = await prisma.runCounter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RunCounters and only return the `id`
     * const runCounterWithIdOnly = await prisma.runCounter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunCounterUpdateManyAndReturnArgs>(args: SelectSubset<T, RunCounterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunCounterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RunCounter.
     * @param {RunCounterUpsertArgs} args - Arguments to update or create a RunCounter.
     * @example
     * // Update or create a RunCounter
     * const runCounter = await prisma.runCounter.upsert({
     *   create: {
     *     // ... data to create a RunCounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RunCounter we want to update
     *   }
     * })
     */
    upsert<T extends RunCounterUpsertArgs>(args: SelectSubset<T, RunCounterUpsertArgs<ExtArgs>>): Prisma__RunCounterClient<$Result.GetResult<Prisma.$RunCounterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RunCounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCounterCountArgs} args - Arguments to filter RunCounters to count.
     * @example
     * // Count the number of RunCounters
     * const count = await prisma.runCounter.count({
     *   where: {
     *     // ... the filter for the RunCounters we want to count
     *   }
     * })
    **/
    count<T extends RunCounterCountArgs>(
      args?: Subset<T, RunCounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RunCounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunCounterAggregateArgs>(args: Subset<T, RunCounterAggregateArgs>): Prisma.PrismaPromise<GetRunCounterAggregateType<T>>

    /**
     * Group by RunCounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunCounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunCounterGroupByArgs['orderBy'] }
        : { orderBy?: RunCounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunCounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunCounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RunCounter model
   */
  readonly fields: RunCounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RunCounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunCounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RunCounter model
   */
  interface RunCounterFieldRefs {
    readonly id: FieldRef<"RunCounter", 'String'>
    readonly year: FieldRef<"RunCounter", 'Int'>
    readonly pool: FieldRef<"RunCounter", 'String'>
    readonly sequence: FieldRef<"RunCounter", 'Int'>
    readonly lastUsed: FieldRef<"RunCounter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RunCounter findUnique
   */
  export type RunCounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCounter
     */
    select?: RunCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCounter
     */
    omit?: RunCounterOmit<ExtArgs> | null
    /**
     * Filter, which RunCounter to fetch.
     */
    where: RunCounterWhereUniqueInput
  }

  /**
   * RunCounter findUniqueOrThrow
   */
  export type RunCounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCounter
     */
    select?: RunCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCounter
     */
    omit?: RunCounterOmit<ExtArgs> | null
    /**
     * Filter, which RunCounter to fetch.
     */
    where: RunCounterWhereUniqueInput
  }

  /**
   * RunCounter findFirst
   */
  export type RunCounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCounter
     */
    select?: RunCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCounter
     */
    omit?: RunCounterOmit<ExtArgs> | null
    /**
     * Filter, which RunCounter to fetch.
     */
    where?: RunCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCounters to fetch.
     */
    orderBy?: RunCounterOrderByWithRelationInput | RunCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCounters.
     */
    cursor?: RunCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCounters.
     */
    distinct?: RunCounterScalarFieldEnum | RunCounterScalarFieldEnum[]
  }

  /**
   * RunCounter findFirstOrThrow
   */
  export type RunCounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCounter
     */
    select?: RunCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCounter
     */
    omit?: RunCounterOmit<ExtArgs> | null
    /**
     * Filter, which RunCounter to fetch.
     */
    where?: RunCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCounters to fetch.
     */
    orderBy?: RunCounterOrderByWithRelationInput | RunCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RunCounters.
     */
    cursor?: RunCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RunCounters.
     */
    distinct?: RunCounterScalarFieldEnum | RunCounterScalarFieldEnum[]
  }

  /**
   * RunCounter findMany
   */
  export type RunCounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCounter
     */
    select?: RunCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCounter
     */
    omit?: RunCounterOmit<ExtArgs> | null
    /**
     * Filter, which RunCounters to fetch.
     */
    where?: RunCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RunCounters to fetch.
     */
    orderBy?: RunCounterOrderByWithRelationInput | RunCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RunCounters.
     */
    cursor?: RunCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RunCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RunCounters.
     */
    skip?: number
    distinct?: RunCounterScalarFieldEnum | RunCounterScalarFieldEnum[]
  }

  /**
   * RunCounter create
   */
  export type RunCounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCounter
     */
    select?: RunCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCounter
     */
    omit?: RunCounterOmit<ExtArgs> | null
    /**
     * The data needed to create a RunCounter.
     */
    data: XOR<RunCounterCreateInput, RunCounterUncheckedCreateInput>
  }

  /**
   * RunCounter createMany
   */
  export type RunCounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RunCounters.
     */
    data: RunCounterCreateManyInput | RunCounterCreateManyInput[]
  }

  /**
   * RunCounter createManyAndReturn
   */
  export type RunCounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCounter
     */
    select?: RunCounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCounter
     */
    omit?: RunCounterOmit<ExtArgs> | null
    /**
     * The data used to create many RunCounters.
     */
    data: RunCounterCreateManyInput | RunCounterCreateManyInput[]
  }

  /**
   * RunCounter update
   */
  export type RunCounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCounter
     */
    select?: RunCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCounter
     */
    omit?: RunCounterOmit<ExtArgs> | null
    /**
     * The data needed to update a RunCounter.
     */
    data: XOR<RunCounterUpdateInput, RunCounterUncheckedUpdateInput>
    /**
     * Choose, which RunCounter to update.
     */
    where: RunCounterWhereUniqueInput
  }

  /**
   * RunCounter updateMany
   */
  export type RunCounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RunCounters.
     */
    data: XOR<RunCounterUpdateManyMutationInput, RunCounterUncheckedUpdateManyInput>
    /**
     * Filter which RunCounters to update
     */
    where?: RunCounterWhereInput
    /**
     * Limit how many RunCounters to update.
     */
    limit?: number
  }

  /**
   * RunCounter updateManyAndReturn
   */
  export type RunCounterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCounter
     */
    select?: RunCounterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RunCounter
     */
    omit?: RunCounterOmit<ExtArgs> | null
    /**
     * The data used to update RunCounters.
     */
    data: XOR<RunCounterUpdateManyMutationInput, RunCounterUncheckedUpdateManyInput>
    /**
     * Filter which RunCounters to update
     */
    where?: RunCounterWhereInput
    /**
     * Limit how many RunCounters to update.
     */
    limit?: number
  }

  /**
   * RunCounter upsert
   */
  export type RunCounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCounter
     */
    select?: RunCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCounter
     */
    omit?: RunCounterOmit<ExtArgs> | null
    /**
     * The filter to search for the RunCounter to update in case it exists.
     */
    where: RunCounterWhereUniqueInput
    /**
     * In case the RunCounter found by the `where` argument doesn't exist, create a new RunCounter with this data.
     */
    create: XOR<RunCounterCreateInput, RunCounterUncheckedCreateInput>
    /**
     * In case the RunCounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunCounterUpdateInput, RunCounterUncheckedUpdateInput>
  }

  /**
   * RunCounter delete
   */
  export type RunCounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCounter
     */
    select?: RunCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCounter
     */
    omit?: RunCounterOmit<ExtArgs> | null
    /**
     * Filter which RunCounter to delete.
     */
    where: RunCounterWhereUniqueInput
  }

  /**
   * RunCounter deleteMany
   */
  export type RunCounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RunCounters to delete
     */
    where?: RunCounterWhereInput
    /**
     * Limit how many RunCounters to delete.
     */
    limit?: number
  }

  /**
   * RunCounter without action
   */
  export type RunCounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCounter
     */
    select?: RunCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RunCounter
     */
    omit?: RunCounterOmit<ExtArgs> | null
  }


  /**
   * Model InstanceGroup
   */

  export type AggregateInstanceGroup = {
    _count: InstanceGroupCountAggregateOutputType | null
    _min: InstanceGroupMinAggregateOutputType | null
    _max: InstanceGroupMaxAggregateOutputType | null
  }

  export type InstanceGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    awxId: string | null
    description: string | null
    enabled: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstanceGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    awxId: string | null
    description: string | null
    enabled: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstanceGroupCountAggregateOutputType = {
    id: number
    name: number
    awxId: number
    description: number
    enabled: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstanceGroupMinAggregateInputType = {
    id?: true
    name?: true
    awxId?: true
    description?: true
    enabled?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstanceGroupMaxAggregateInputType = {
    id?: true
    name?: true
    awxId?: true
    description?: true
    enabled?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstanceGroupCountAggregateInputType = {
    id?: true
    name?: true
    awxId?: true
    description?: true
    enabled?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstanceGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstanceGroup to aggregate.
     */
    where?: InstanceGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstanceGroups to fetch.
     */
    orderBy?: InstanceGroupOrderByWithRelationInput | InstanceGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstanceGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstanceGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstanceGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstanceGroups
    **/
    _count?: true | InstanceGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstanceGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstanceGroupMaxAggregateInputType
  }

  export type GetInstanceGroupAggregateType<T extends InstanceGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateInstanceGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstanceGroup[P]>
      : GetScalarType<T[P], AggregateInstanceGroup[P]>
  }




  export type InstanceGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstanceGroupWhereInput
    orderBy?: InstanceGroupOrderByWithAggregationInput | InstanceGroupOrderByWithAggregationInput[]
    by: InstanceGroupScalarFieldEnum[] | InstanceGroupScalarFieldEnum
    having?: InstanceGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstanceGroupCountAggregateInputType | true
    _min?: InstanceGroupMinAggregateInputType
    _max?: InstanceGroupMaxAggregateInputType
  }

  export type InstanceGroupGroupByOutputType = {
    id: string
    name: string
    awxId: string | null
    description: string | null
    enabled: boolean
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: InstanceGroupCountAggregateOutputType | null
    _min: InstanceGroupMinAggregateOutputType | null
    _max: InstanceGroupMaxAggregateOutputType | null
  }

  type GetInstanceGroupGroupByPayload<T extends InstanceGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstanceGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstanceGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstanceGroupGroupByOutputType[P]>
            : GetScalarType<T[P], InstanceGroupGroupByOutputType[P]>
        }
      >
    >


  export type InstanceGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    awxId?: boolean
    description?: boolean
    enabled?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["instanceGroup"]>

  export type InstanceGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    awxId?: boolean
    description?: boolean
    enabled?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["instanceGroup"]>

  export type InstanceGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    awxId?: boolean
    description?: boolean
    enabled?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["instanceGroup"]>

  export type InstanceGroupSelectScalar = {
    id?: boolean
    name?: boolean
    awxId?: boolean
    description?: boolean
    enabled?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstanceGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "awxId" | "description" | "enabled" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["instanceGroup"]>

  export type $InstanceGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstanceGroup"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      awxId: string | null
      description: string | null
      enabled: boolean
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["instanceGroup"]>
    composites: {}
  }

  type InstanceGroupGetPayload<S extends boolean | null | undefined | InstanceGroupDefaultArgs> = $Result.GetResult<Prisma.$InstanceGroupPayload, S>

  type InstanceGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstanceGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstanceGroupCountAggregateInputType | true
    }

  export interface InstanceGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstanceGroup'], meta: { name: 'InstanceGroup' } }
    /**
     * Find zero or one InstanceGroup that matches the filter.
     * @param {InstanceGroupFindUniqueArgs} args - Arguments to find a InstanceGroup
     * @example
     * // Get one InstanceGroup
     * const instanceGroup = await prisma.instanceGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstanceGroupFindUniqueArgs>(args: SelectSubset<T, InstanceGroupFindUniqueArgs<ExtArgs>>): Prisma__InstanceGroupClient<$Result.GetResult<Prisma.$InstanceGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstanceGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstanceGroupFindUniqueOrThrowArgs} args - Arguments to find a InstanceGroup
     * @example
     * // Get one InstanceGroup
     * const instanceGroup = await prisma.instanceGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstanceGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, InstanceGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstanceGroupClient<$Result.GetResult<Prisma.$InstanceGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstanceGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceGroupFindFirstArgs} args - Arguments to find a InstanceGroup
     * @example
     * // Get one InstanceGroup
     * const instanceGroup = await prisma.instanceGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstanceGroupFindFirstArgs>(args?: SelectSubset<T, InstanceGroupFindFirstArgs<ExtArgs>>): Prisma__InstanceGroupClient<$Result.GetResult<Prisma.$InstanceGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstanceGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceGroupFindFirstOrThrowArgs} args - Arguments to find a InstanceGroup
     * @example
     * // Get one InstanceGroup
     * const instanceGroup = await prisma.instanceGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstanceGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, InstanceGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstanceGroupClient<$Result.GetResult<Prisma.$InstanceGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstanceGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstanceGroups
     * const instanceGroups = await prisma.instanceGroup.findMany()
     * 
     * // Get first 10 InstanceGroups
     * const instanceGroups = await prisma.instanceGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instanceGroupWithIdOnly = await prisma.instanceGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstanceGroupFindManyArgs>(args?: SelectSubset<T, InstanceGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstanceGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstanceGroup.
     * @param {InstanceGroupCreateArgs} args - Arguments to create a InstanceGroup.
     * @example
     * // Create one InstanceGroup
     * const InstanceGroup = await prisma.instanceGroup.create({
     *   data: {
     *     // ... data to create a InstanceGroup
     *   }
     * })
     * 
     */
    create<T extends InstanceGroupCreateArgs>(args: SelectSubset<T, InstanceGroupCreateArgs<ExtArgs>>): Prisma__InstanceGroupClient<$Result.GetResult<Prisma.$InstanceGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstanceGroups.
     * @param {InstanceGroupCreateManyArgs} args - Arguments to create many InstanceGroups.
     * @example
     * // Create many InstanceGroups
     * const instanceGroup = await prisma.instanceGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstanceGroupCreateManyArgs>(args?: SelectSubset<T, InstanceGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstanceGroups and returns the data saved in the database.
     * @param {InstanceGroupCreateManyAndReturnArgs} args - Arguments to create many InstanceGroups.
     * @example
     * // Create many InstanceGroups
     * const instanceGroup = await prisma.instanceGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstanceGroups and only return the `id`
     * const instanceGroupWithIdOnly = await prisma.instanceGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstanceGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, InstanceGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstanceGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstanceGroup.
     * @param {InstanceGroupDeleteArgs} args - Arguments to delete one InstanceGroup.
     * @example
     * // Delete one InstanceGroup
     * const InstanceGroup = await prisma.instanceGroup.delete({
     *   where: {
     *     // ... filter to delete one InstanceGroup
     *   }
     * })
     * 
     */
    delete<T extends InstanceGroupDeleteArgs>(args: SelectSubset<T, InstanceGroupDeleteArgs<ExtArgs>>): Prisma__InstanceGroupClient<$Result.GetResult<Prisma.$InstanceGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstanceGroup.
     * @param {InstanceGroupUpdateArgs} args - Arguments to update one InstanceGroup.
     * @example
     * // Update one InstanceGroup
     * const instanceGroup = await prisma.instanceGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstanceGroupUpdateArgs>(args: SelectSubset<T, InstanceGroupUpdateArgs<ExtArgs>>): Prisma__InstanceGroupClient<$Result.GetResult<Prisma.$InstanceGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstanceGroups.
     * @param {InstanceGroupDeleteManyArgs} args - Arguments to filter InstanceGroups to delete.
     * @example
     * // Delete a few InstanceGroups
     * const { count } = await prisma.instanceGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstanceGroupDeleteManyArgs>(args?: SelectSubset<T, InstanceGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstanceGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstanceGroups
     * const instanceGroup = await prisma.instanceGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstanceGroupUpdateManyArgs>(args: SelectSubset<T, InstanceGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstanceGroups and returns the data updated in the database.
     * @param {InstanceGroupUpdateManyAndReturnArgs} args - Arguments to update many InstanceGroups.
     * @example
     * // Update many InstanceGroups
     * const instanceGroup = await prisma.instanceGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstanceGroups and only return the `id`
     * const instanceGroupWithIdOnly = await prisma.instanceGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstanceGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, InstanceGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstanceGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstanceGroup.
     * @param {InstanceGroupUpsertArgs} args - Arguments to update or create a InstanceGroup.
     * @example
     * // Update or create a InstanceGroup
     * const instanceGroup = await prisma.instanceGroup.upsert({
     *   create: {
     *     // ... data to create a InstanceGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstanceGroup we want to update
     *   }
     * })
     */
    upsert<T extends InstanceGroupUpsertArgs>(args: SelectSubset<T, InstanceGroupUpsertArgs<ExtArgs>>): Prisma__InstanceGroupClient<$Result.GetResult<Prisma.$InstanceGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstanceGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceGroupCountArgs} args - Arguments to filter InstanceGroups to count.
     * @example
     * // Count the number of InstanceGroups
     * const count = await prisma.instanceGroup.count({
     *   where: {
     *     // ... the filter for the InstanceGroups we want to count
     *   }
     * })
    **/
    count<T extends InstanceGroupCountArgs>(
      args?: Subset<T, InstanceGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstanceGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstanceGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstanceGroupAggregateArgs>(args: Subset<T, InstanceGroupAggregateArgs>): Prisma.PrismaPromise<GetInstanceGroupAggregateType<T>>

    /**
     * Group by InstanceGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstanceGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstanceGroupGroupByArgs['orderBy'] }
        : { orderBy?: InstanceGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstanceGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstanceGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstanceGroup model
   */
  readonly fields: InstanceGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstanceGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstanceGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstanceGroup model
   */
  interface InstanceGroupFieldRefs {
    readonly id: FieldRef<"InstanceGroup", 'String'>
    readonly name: FieldRef<"InstanceGroup", 'String'>
    readonly awxId: FieldRef<"InstanceGroup", 'String'>
    readonly description: FieldRef<"InstanceGroup", 'String'>
    readonly enabled: FieldRef<"InstanceGroup", 'Boolean'>
    readonly createdBy: FieldRef<"InstanceGroup", 'String'>
    readonly createdAt: FieldRef<"InstanceGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"InstanceGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InstanceGroup findUnique
   */
  export type InstanceGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceGroup
     */
    select?: InstanceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstanceGroup
     */
    omit?: InstanceGroupOmit<ExtArgs> | null
    /**
     * Filter, which InstanceGroup to fetch.
     */
    where: InstanceGroupWhereUniqueInput
  }

  /**
   * InstanceGroup findUniqueOrThrow
   */
  export type InstanceGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceGroup
     */
    select?: InstanceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstanceGroup
     */
    omit?: InstanceGroupOmit<ExtArgs> | null
    /**
     * Filter, which InstanceGroup to fetch.
     */
    where: InstanceGroupWhereUniqueInput
  }

  /**
   * InstanceGroup findFirst
   */
  export type InstanceGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceGroup
     */
    select?: InstanceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstanceGroup
     */
    omit?: InstanceGroupOmit<ExtArgs> | null
    /**
     * Filter, which InstanceGroup to fetch.
     */
    where?: InstanceGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstanceGroups to fetch.
     */
    orderBy?: InstanceGroupOrderByWithRelationInput | InstanceGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstanceGroups.
     */
    cursor?: InstanceGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstanceGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstanceGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstanceGroups.
     */
    distinct?: InstanceGroupScalarFieldEnum | InstanceGroupScalarFieldEnum[]
  }

  /**
   * InstanceGroup findFirstOrThrow
   */
  export type InstanceGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceGroup
     */
    select?: InstanceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstanceGroup
     */
    omit?: InstanceGroupOmit<ExtArgs> | null
    /**
     * Filter, which InstanceGroup to fetch.
     */
    where?: InstanceGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstanceGroups to fetch.
     */
    orderBy?: InstanceGroupOrderByWithRelationInput | InstanceGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstanceGroups.
     */
    cursor?: InstanceGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstanceGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstanceGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstanceGroups.
     */
    distinct?: InstanceGroupScalarFieldEnum | InstanceGroupScalarFieldEnum[]
  }

  /**
   * InstanceGroup findMany
   */
  export type InstanceGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceGroup
     */
    select?: InstanceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstanceGroup
     */
    omit?: InstanceGroupOmit<ExtArgs> | null
    /**
     * Filter, which InstanceGroups to fetch.
     */
    where?: InstanceGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstanceGroups to fetch.
     */
    orderBy?: InstanceGroupOrderByWithRelationInput | InstanceGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstanceGroups.
     */
    cursor?: InstanceGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstanceGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstanceGroups.
     */
    skip?: number
    distinct?: InstanceGroupScalarFieldEnum | InstanceGroupScalarFieldEnum[]
  }

  /**
   * InstanceGroup create
   */
  export type InstanceGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceGroup
     */
    select?: InstanceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstanceGroup
     */
    omit?: InstanceGroupOmit<ExtArgs> | null
    /**
     * The data needed to create a InstanceGroup.
     */
    data: XOR<InstanceGroupCreateInput, InstanceGroupUncheckedCreateInput>
  }

  /**
   * InstanceGroup createMany
   */
  export type InstanceGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstanceGroups.
     */
    data: InstanceGroupCreateManyInput | InstanceGroupCreateManyInput[]
  }

  /**
   * InstanceGroup createManyAndReturn
   */
  export type InstanceGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceGroup
     */
    select?: InstanceGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstanceGroup
     */
    omit?: InstanceGroupOmit<ExtArgs> | null
    /**
     * The data used to create many InstanceGroups.
     */
    data: InstanceGroupCreateManyInput | InstanceGroupCreateManyInput[]
  }

  /**
   * InstanceGroup update
   */
  export type InstanceGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceGroup
     */
    select?: InstanceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstanceGroup
     */
    omit?: InstanceGroupOmit<ExtArgs> | null
    /**
     * The data needed to update a InstanceGroup.
     */
    data: XOR<InstanceGroupUpdateInput, InstanceGroupUncheckedUpdateInput>
    /**
     * Choose, which InstanceGroup to update.
     */
    where: InstanceGroupWhereUniqueInput
  }

  /**
   * InstanceGroup updateMany
   */
  export type InstanceGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstanceGroups.
     */
    data: XOR<InstanceGroupUpdateManyMutationInput, InstanceGroupUncheckedUpdateManyInput>
    /**
     * Filter which InstanceGroups to update
     */
    where?: InstanceGroupWhereInput
    /**
     * Limit how many InstanceGroups to update.
     */
    limit?: number
  }

  /**
   * InstanceGroup updateManyAndReturn
   */
  export type InstanceGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceGroup
     */
    select?: InstanceGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstanceGroup
     */
    omit?: InstanceGroupOmit<ExtArgs> | null
    /**
     * The data used to update InstanceGroups.
     */
    data: XOR<InstanceGroupUpdateManyMutationInput, InstanceGroupUncheckedUpdateManyInput>
    /**
     * Filter which InstanceGroups to update
     */
    where?: InstanceGroupWhereInput
    /**
     * Limit how many InstanceGroups to update.
     */
    limit?: number
  }

  /**
   * InstanceGroup upsert
   */
  export type InstanceGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceGroup
     */
    select?: InstanceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstanceGroup
     */
    omit?: InstanceGroupOmit<ExtArgs> | null
    /**
     * The filter to search for the InstanceGroup to update in case it exists.
     */
    where: InstanceGroupWhereUniqueInput
    /**
     * In case the InstanceGroup found by the `where` argument doesn't exist, create a new InstanceGroup with this data.
     */
    create: XOR<InstanceGroupCreateInput, InstanceGroupUncheckedCreateInput>
    /**
     * In case the InstanceGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstanceGroupUpdateInput, InstanceGroupUncheckedUpdateInput>
  }

  /**
   * InstanceGroup delete
   */
  export type InstanceGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceGroup
     */
    select?: InstanceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstanceGroup
     */
    omit?: InstanceGroupOmit<ExtArgs> | null
    /**
     * Filter which InstanceGroup to delete.
     */
    where: InstanceGroupWhereUniqueInput
  }

  /**
   * InstanceGroup deleteMany
   */
  export type InstanceGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstanceGroups to delete
     */
    where?: InstanceGroupWhereInput
    /**
     * Limit how many InstanceGroups to delete.
     */
    limit?: number
  }

  /**
   * InstanceGroup without action
   */
  export type InstanceGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceGroup
     */
    select?: InstanceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstanceGroup
     */
    omit?: InstanceGroupOmit<ExtArgs> | null
  }


  /**
   * Model AwxEnvironment
   */

  export type AggregateAwxEnvironment = {
    _count: AwxEnvironmentCountAggregateOutputType | null
    _min: AwxEnvironmentMinAggregateOutputType | null
    _max: AwxEnvironmentMaxAggregateOutputType | null
  }

  export type AwxEnvironmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    baseUrl: string | null
    token: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AwxEnvironmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    baseUrl: string | null
    token: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AwxEnvironmentCountAggregateOutputType = {
    id: number
    name: number
    baseUrl: number
    token: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AwxEnvironmentMinAggregateInputType = {
    id?: true
    name?: true
    baseUrl?: true
    token?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AwxEnvironmentMaxAggregateInputType = {
    id?: true
    name?: true
    baseUrl?: true
    token?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AwxEnvironmentCountAggregateInputType = {
    id?: true
    name?: true
    baseUrl?: true
    token?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AwxEnvironmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AwxEnvironment to aggregate.
     */
    where?: AwxEnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwxEnvironments to fetch.
     */
    orderBy?: AwxEnvironmentOrderByWithRelationInput | AwxEnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AwxEnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwxEnvironments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwxEnvironments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AwxEnvironments
    **/
    _count?: true | AwxEnvironmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AwxEnvironmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AwxEnvironmentMaxAggregateInputType
  }

  export type GetAwxEnvironmentAggregateType<T extends AwxEnvironmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAwxEnvironment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAwxEnvironment[P]>
      : GetScalarType<T[P], AggregateAwxEnvironment[P]>
  }




  export type AwxEnvironmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AwxEnvironmentWhereInput
    orderBy?: AwxEnvironmentOrderByWithAggregationInput | AwxEnvironmentOrderByWithAggregationInput[]
    by: AwxEnvironmentScalarFieldEnum[] | AwxEnvironmentScalarFieldEnum
    having?: AwxEnvironmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AwxEnvironmentCountAggregateInputType | true
    _min?: AwxEnvironmentMinAggregateInputType
    _max?: AwxEnvironmentMaxAggregateInputType
  }

  export type AwxEnvironmentGroupByOutputType = {
    id: string
    name: string
    baseUrl: string
    token: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: AwxEnvironmentCountAggregateOutputType | null
    _min: AwxEnvironmentMinAggregateOutputType | null
    _max: AwxEnvironmentMaxAggregateOutputType | null
  }

  type GetAwxEnvironmentGroupByPayload<T extends AwxEnvironmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AwxEnvironmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AwxEnvironmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AwxEnvironmentGroupByOutputType[P]>
            : GetScalarType<T[P], AwxEnvironmentGroupByOutputType[P]>
        }
      >
    >


  export type AwxEnvironmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    baseUrl?: boolean
    token?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    catalogs?: boolean | AwxEnvironment$catalogsArgs<ExtArgs>
    _count?: boolean | AwxEnvironmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["awxEnvironment"]>

  export type AwxEnvironmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    baseUrl?: boolean
    token?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["awxEnvironment"]>

  export type AwxEnvironmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    baseUrl?: boolean
    token?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["awxEnvironment"]>

  export type AwxEnvironmentSelectScalar = {
    id?: boolean
    name?: boolean
    baseUrl?: boolean
    token?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AwxEnvironmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "baseUrl" | "token" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["awxEnvironment"]>
  export type AwxEnvironmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catalogs?: boolean | AwxEnvironment$catalogsArgs<ExtArgs>
    _count?: boolean | AwxEnvironmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AwxEnvironmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AwxEnvironmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AwxEnvironmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AwxEnvironment"
    objects: {
      catalogs: Prisma.$CatalogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      baseUrl: string
      token: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["awxEnvironment"]>
    composites: {}
  }

  type AwxEnvironmentGetPayload<S extends boolean | null | undefined | AwxEnvironmentDefaultArgs> = $Result.GetResult<Prisma.$AwxEnvironmentPayload, S>

  type AwxEnvironmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AwxEnvironmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AwxEnvironmentCountAggregateInputType | true
    }

  export interface AwxEnvironmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AwxEnvironment'], meta: { name: 'AwxEnvironment' } }
    /**
     * Find zero or one AwxEnvironment that matches the filter.
     * @param {AwxEnvironmentFindUniqueArgs} args - Arguments to find a AwxEnvironment
     * @example
     * // Get one AwxEnvironment
     * const awxEnvironment = await prisma.awxEnvironment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AwxEnvironmentFindUniqueArgs>(args: SelectSubset<T, AwxEnvironmentFindUniqueArgs<ExtArgs>>): Prisma__AwxEnvironmentClient<$Result.GetResult<Prisma.$AwxEnvironmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AwxEnvironment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AwxEnvironmentFindUniqueOrThrowArgs} args - Arguments to find a AwxEnvironment
     * @example
     * // Get one AwxEnvironment
     * const awxEnvironment = await prisma.awxEnvironment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AwxEnvironmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AwxEnvironmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AwxEnvironmentClient<$Result.GetResult<Prisma.$AwxEnvironmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AwxEnvironment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwxEnvironmentFindFirstArgs} args - Arguments to find a AwxEnvironment
     * @example
     * // Get one AwxEnvironment
     * const awxEnvironment = await prisma.awxEnvironment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AwxEnvironmentFindFirstArgs>(args?: SelectSubset<T, AwxEnvironmentFindFirstArgs<ExtArgs>>): Prisma__AwxEnvironmentClient<$Result.GetResult<Prisma.$AwxEnvironmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AwxEnvironment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwxEnvironmentFindFirstOrThrowArgs} args - Arguments to find a AwxEnvironment
     * @example
     * // Get one AwxEnvironment
     * const awxEnvironment = await prisma.awxEnvironment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AwxEnvironmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AwxEnvironmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AwxEnvironmentClient<$Result.GetResult<Prisma.$AwxEnvironmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AwxEnvironments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwxEnvironmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AwxEnvironments
     * const awxEnvironments = await prisma.awxEnvironment.findMany()
     * 
     * // Get first 10 AwxEnvironments
     * const awxEnvironments = await prisma.awxEnvironment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const awxEnvironmentWithIdOnly = await prisma.awxEnvironment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AwxEnvironmentFindManyArgs>(args?: SelectSubset<T, AwxEnvironmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwxEnvironmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AwxEnvironment.
     * @param {AwxEnvironmentCreateArgs} args - Arguments to create a AwxEnvironment.
     * @example
     * // Create one AwxEnvironment
     * const AwxEnvironment = await prisma.awxEnvironment.create({
     *   data: {
     *     // ... data to create a AwxEnvironment
     *   }
     * })
     * 
     */
    create<T extends AwxEnvironmentCreateArgs>(args: SelectSubset<T, AwxEnvironmentCreateArgs<ExtArgs>>): Prisma__AwxEnvironmentClient<$Result.GetResult<Prisma.$AwxEnvironmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AwxEnvironments.
     * @param {AwxEnvironmentCreateManyArgs} args - Arguments to create many AwxEnvironments.
     * @example
     * // Create many AwxEnvironments
     * const awxEnvironment = await prisma.awxEnvironment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AwxEnvironmentCreateManyArgs>(args?: SelectSubset<T, AwxEnvironmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AwxEnvironments and returns the data saved in the database.
     * @param {AwxEnvironmentCreateManyAndReturnArgs} args - Arguments to create many AwxEnvironments.
     * @example
     * // Create many AwxEnvironments
     * const awxEnvironment = await prisma.awxEnvironment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AwxEnvironments and only return the `id`
     * const awxEnvironmentWithIdOnly = await prisma.awxEnvironment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AwxEnvironmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AwxEnvironmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwxEnvironmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AwxEnvironment.
     * @param {AwxEnvironmentDeleteArgs} args - Arguments to delete one AwxEnvironment.
     * @example
     * // Delete one AwxEnvironment
     * const AwxEnvironment = await prisma.awxEnvironment.delete({
     *   where: {
     *     // ... filter to delete one AwxEnvironment
     *   }
     * })
     * 
     */
    delete<T extends AwxEnvironmentDeleteArgs>(args: SelectSubset<T, AwxEnvironmentDeleteArgs<ExtArgs>>): Prisma__AwxEnvironmentClient<$Result.GetResult<Prisma.$AwxEnvironmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AwxEnvironment.
     * @param {AwxEnvironmentUpdateArgs} args - Arguments to update one AwxEnvironment.
     * @example
     * // Update one AwxEnvironment
     * const awxEnvironment = await prisma.awxEnvironment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AwxEnvironmentUpdateArgs>(args: SelectSubset<T, AwxEnvironmentUpdateArgs<ExtArgs>>): Prisma__AwxEnvironmentClient<$Result.GetResult<Prisma.$AwxEnvironmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AwxEnvironments.
     * @param {AwxEnvironmentDeleteManyArgs} args - Arguments to filter AwxEnvironments to delete.
     * @example
     * // Delete a few AwxEnvironments
     * const { count } = await prisma.awxEnvironment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AwxEnvironmentDeleteManyArgs>(args?: SelectSubset<T, AwxEnvironmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AwxEnvironments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwxEnvironmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AwxEnvironments
     * const awxEnvironment = await prisma.awxEnvironment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AwxEnvironmentUpdateManyArgs>(args: SelectSubset<T, AwxEnvironmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AwxEnvironments and returns the data updated in the database.
     * @param {AwxEnvironmentUpdateManyAndReturnArgs} args - Arguments to update many AwxEnvironments.
     * @example
     * // Update many AwxEnvironments
     * const awxEnvironment = await prisma.awxEnvironment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AwxEnvironments and only return the `id`
     * const awxEnvironmentWithIdOnly = await prisma.awxEnvironment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AwxEnvironmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AwxEnvironmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwxEnvironmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AwxEnvironment.
     * @param {AwxEnvironmentUpsertArgs} args - Arguments to update or create a AwxEnvironment.
     * @example
     * // Update or create a AwxEnvironment
     * const awxEnvironment = await prisma.awxEnvironment.upsert({
     *   create: {
     *     // ... data to create a AwxEnvironment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AwxEnvironment we want to update
     *   }
     * })
     */
    upsert<T extends AwxEnvironmentUpsertArgs>(args: SelectSubset<T, AwxEnvironmentUpsertArgs<ExtArgs>>): Prisma__AwxEnvironmentClient<$Result.GetResult<Prisma.$AwxEnvironmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AwxEnvironments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwxEnvironmentCountArgs} args - Arguments to filter AwxEnvironments to count.
     * @example
     * // Count the number of AwxEnvironments
     * const count = await prisma.awxEnvironment.count({
     *   where: {
     *     // ... the filter for the AwxEnvironments we want to count
     *   }
     * })
    **/
    count<T extends AwxEnvironmentCountArgs>(
      args?: Subset<T, AwxEnvironmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AwxEnvironmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AwxEnvironment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwxEnvironmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AwxEnvironmentAggregateArgs>(args: Subset<T, AwxEnvironmentAggregateArgs>): Prisma.PrismaPromise<GetAwxEnvironmentAggregateType<T>>

    /**
     * Group by AwxEnvironment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwxEnvironmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AwxEnvironmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AwxEnvironmentGroupByArgs['orderBy'] }
        : { orderBy?: AwxEnvironmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AwxEnvironmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAwxEnvironmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AwxEnvironment model
   */
  readonly fields: AwxEnvironmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AwxEnvironment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AwxEnvironmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    catalogs<T extends AwxEnvironment$catalogsArgs<ExtArgs> = {}>(args?: Subset<T, AwxEnvironment$catalogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AwxEnvironment model
   */
  interface AwxEnvironmentFieldRefs {
    readonly id: FieldRef<"AwxEnvironment", 'String'>
    readonly name: FieldRef<"AwxEnvironment", 'String'>
    readonly baseUrl: FieldRef<"AwxEnvironment", 'String'>
    readonly token: FieldRef<"AwxEnvironment", 'String'>
    readonly description: FieldRef<"AwxEnvironment", 'String'>
    readonly createdAt: FieldRef<"AwxEnvironment", 'DateTime'>
    readonly updatedAt: FieldRef<"AwxEnvironment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AwxEnvironment findUnique
   */
  export type AwxEnvironmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwxEnvironment
     */
    select?: AwxEnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AwxEnvironment
     */
    omit?: AwxEnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwxEnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which AwxEnvironment to fetch.
     */
    where: AwxEnvironmentWhereUniqueInput
  }

  /**
   * AwxEnvironment findUniqueOrThrow
   */
  export type AwxEnvironmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwxEnvironment
     */
    select?: AwxEnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AwxEnvironment
     */
    omit?: AwxEnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwxEnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which AwxEnvironment to fetch.
     */
    where: AwxEnvironmentWhereUniqueInput
  }

  /**
   * AwxEnvironment findFirst
   */
  export type AwxEnvironmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwxEnvironment
     */
    select?: AwxEnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AwxEnvironment
     */
    omit?: AwxEnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwxEnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which AwxEnvironment to fetch.
     */
    where?: AwxEnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwxEnvironments to fetch.
     */
    orderBy?: AwxEnvironmentOrderByWithRelationInput | AwxEnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AwxEnvironments.
     */
    cursor?: AwxEnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwxEnvironments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwxEnvironments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AwxEnvironments.
     */
    distinct?: AwxEnvironmentScalarFieldEnum | AwxEnvironmentScalarFieldEnum[]
  }

  /**
   * AwxEnvironment findFirstOrThrow
   */
  export type AwxEnvironmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwxEnvironment
     */
    select?: AwxEnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AwxEnvironment
     */
    omit?: AwxEnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwxEnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which AwxEnvironment to fetch.
     */
    where?: AwxEnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwxEnvironments to fetch.
     */
    orderBy?: AwxEnvironmentOrderByWithRelationInput | AwxEnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AwxEnvironments.
     */
    cursor?: AwxEnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwxEnvironments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwxEnvironments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AwxEnvironments.
     */
    distinct?: AwxEnvironmentScalarFieldEnum | AwxEnvironmentScalarFieldEnum[]
  }

  /**
   * AwxEnvironment findMany
   */
  export type AwxEnvironmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwxEnvironment
     */
    select?: AwxEnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AwxEnvironment
     */
    omit?: AwxEnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwxEnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which AwxEnvironments to fetch.
     */
    where?: AwxEnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwxEnvironments to fetch.
     */
    orderBy?: AwxEnvironmentOrderByWithRelationInput | AwxEnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AwxEnvironments.
     */
    cursor?: AwxEnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwxEnvironments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwxEnvironments.
     */
    skip?: number
    distinct?: AwxEnvironmentScalarFieldEnum | AwxEnvironmentScalarFieldEnum[]
  }

  /**
   * AwxEnvironment create
   */
  export type AwxEnvironmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwxEnvironment
     */
    select?: AwxEnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AwxEnvironment
     */
    omit?: AwxEnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwxEnvironmentInclude<ExtArgs> | null
    /**
     * The data needed to create a AwxEnvironment.
     */
    data: XOR<AwxEnvironmentCreateInput, AwxEnvironmentUncheckedCreateInput>
  }

  /**
   * AwxEnvironment createMany
   */
  export type AwxEnvironmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AwxEnvironments.
     */
    data: AwxEnvironmentCreateManyInput | AwxEnvironmentCreateManyInput[]
  }

  /**
   * AwxEnvironment createManyAndReturn
   */
  export type AwxEnvironmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwxEnvironment
     */
    select?: AwxEnvironmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AwxEnvironment
     */
    omit?: AwxEnvironmentOmit<ExtArgs> | null
    /**
     * The data used to create many AwxEnvironments.
     */
    data: AwxEnvironmentCreateManyInput | AwxEnvironmentCreateManyInput[]
  }

  /**
   * AwxEnvironment update
   */
  export type AwxEnvironmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwxEnvironment
     */
    select?: AwxEnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AwxEnvironment
     */
    omit?: AwxEnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwxEnvironmentInclude<ExtArgs> | null
    /**
     * The data needed to update a AwxEnvironment.
     */
    data: XOR<AwxEnvironmentUpdateInput, AwxEnvironmentUncheckedUpdateInput>
    /**
     * Choose, which AwxEnvironment to update.
     */
    where: AwxEnvironmentWhereUniqueInput
  }

  /**
   * AwxEnvironment updateMany
   */
  export type AwxEnvironmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AwxEnvironments.
     */
    data: XOR<AwxEnvironmentUpdateManyMutationInput, AwxEnvironmentUncheckedUpdateManyInput>
    /**
     * Filter which AwxEnvironments to update
     */
    where?: AwxEnvironmentWhereInput
    /**
     * Limit how many AwxEnvironments to update.
     */
    limit?: number
  }

  /**
   * AwxEnvironment updateManyAndReturn
   */
  export type AwxEnvironmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwxEnvironment
     */
    select?: AwxEnvironmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AwxEnvironment
     */
    omit?: AwxEnvironmentOmit<ExtArgs> | null
    /**
     * The data used to update AwxEnvironments.
     */
    data: XOR<AwxEnvironmentUpdateManyMutationInput, AwxEnvironmentUncheckedUpdateManyInput>
    /**
     * Filter which AwxEnvironments to update
     */
    where?: AwxEnvironmentWhereInput
    /**
     * Limit how many AwxEnvironments to update.
     */
    limit?: number
  }

  /**
   * AwxEnvironment upsert
   */
  export type AwxEnvironmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwxEnvironment
     */
    select?: AwxEnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AwxEnvironment
     */
    omit?: AwxEnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwxEnvironmentInclude<ExtArgs> | null
    /**
     * The filter to search for the AwxEnvironment to update in case it exists.
     */
    where: AwxEnvironmentWhereUniqueInput
    /**
     * In case the AwxEnvironment found by the `where` argument doesn't exist, create a new AwxEnvironment with this data.
     */
    create: XOR<AwxEnvironmentCreateInput, AwxEnvironmentUncheckedCreateInput>
    /**
     * In case the AwxEnvironment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AwxEnvironmentUpdateInput, AwxEnvironmentUncheckedUpdateInput>
  }

  /**
   * AwxEnvironment delete
   */
  export type AwxEnvironmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwxEnvironment
     */
    select?: AwxEnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AwxEnvironment
     */
    omit?: AwxEnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwxEnvironmentInclude<ExtArgs> | null
    /**
     * Filter which AwxEnvironment to delete.
     */
    where: AwxEnvironmentWhereUniqueInput
  }

  /**
   * AwxEnvironment deleteMany
   */
  export type AwxEnvironmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AwxEnvironments to delete
     */
    where?: AwxEnvironmentWhereInput
    /**
     * Limit how many AwxEnvironments to delete.
     */
    limit?: number
  }

  /**
   * AwxEnvironment.catalogs
   */
  export type AwxEnvironment$catalogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    where?: CatalogWhereInput
    orderBy?: CatalogOrderByWithRelationInput | CatalogOrderByWithRelationInput[]
    cursor?: CatalogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogScalarFieldEnum | CatalogScalarFieldEnum[]
  }

  /**
   * AwxEnvironment without action
   */
  export type AwxEnvironmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwxEnvironment
     */
    select?: AwxEnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AwxEnvironment
     */
    omit?: AwxEnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwxEnvironmentInclude<ExtArgs> | null
  }


  /**
   * Model Catalog
   */

  export type AggregateCatalog = {
    _count: CatalogCountAggregateOutputType | null
    _min: CatalogMinAggregateOutputType | null
    _max: CatalogMaxAggregateOutputType | null
  }

  export type CatalogMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tags: string | null
    namespaceId: string | null
    environmentId: string | null
    templateId: string | null
    customBody: string | null
    formSchema: string | null
    isLocked: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tags: string | null
    namespaceId: string | null
    environmentId: string | null
    templateId: string | null
    customBody: string | null
    formSchema: string | null
    isLocked: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatalogCountAggregateOutputType = {
    id: number
    name: number
    description: number
    tags: number
    namespaceId: number
    environmentId: number
    templateId: number
    customBody: number
    formSchema: number
    isLocked: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CatalogMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tags?: true
    namespaceId?: true
    environmentId?: true
    templateId?: true
    customBody?: true
    formSchema?: true
    isLocked?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tags?: true
    namespaceId?: true
    environmentId?: true
    templateId?: true
    customBody?: true
    formSchema?: true
    isLocked?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatalogCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tags?: true
    namespaceId?: true
    environmentId?: true
    templateId?: true
    customBody?: true
    formSchema?: true
    isLocked?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CatalogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Catalog to aggregate.
     */
    where?: CatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Catalogs to fetch.
     */
    orderBy?: CatalogOrderByWithRelationInput | CatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Catalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Catalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Catalogs
    **/
    _count?: true | CatalogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogMaxAggregateInputType
  }

  export type GetCatalogAggregateType<T extends CatalogAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalog[P]>
      : GetScalarType<T[P], AggregateCatalog[P]>
  }




  export type CatalogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogWhereInput
    orderBy?: CatalogOrderByWithAggregationInput | CatalogOrderByWithAggregationInput[]
    by: CatalogScalarFieldEnum[] | CatalogScalarFieldEnum
    having?: CatalogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogCountAggregateInputType | true
    _min?: CatalogMinAggregateInputType
    _max?: CatalogMaxAggregateInputType
  }

  export type CatalogGroupByOutputType = {
    id: string
    name: string
    description: string | null
    tags: string | null
    namespaceId: string
    environmentId: string
    templateId: string
    customBody: string | null
    formSchema: string | null
    isLocked: boolean
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: CatalogCountAggregateOutputType | null
    _min: CatalogMinAggregateOutputType | null
    _max: CatalogMaxAggregateOutputType | null
  }

  type GetCatalogGroupByPayload<T extends CatalogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogGroupByOutputType[P]>
        }
      >
    >


  export type CatalogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tags?: boolean
    namespaceId?: boolean
    environmentId?: boolean
    templateId?: boolean
    customBody?: boolean
    formSchema?: boolean
    isLocked?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    environment?: boolean | AwxEnvironmentDefaultArgs<ExtArgs>
    executions?: boolean | Catalog$executionsArgs<ExtArgs>
    _count?: boolean | CatalogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalog"]>

  export type CatalogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tags?: boolean
    namespaceId?: boolean
    environmentId?: boolean
    templateId?: boolean
    customBody?: boolean
    formSchema?: boolean
    isLocked?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    environment?: boolean | AwxEnvironmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalog"]>

  export type CatalogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tags?: boolean
    namespaceId?: boolean
    environmentId?: boolean
    templateId?: boolean
    customBody?: boolean
    formSchema?: boolean
    isLocked?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    environment?: boolean | AwxEnvironmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalog"]>

  export type CatalogSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    tags?: boolean
    namespaceId?: boolean
    environmentId?: boolean
    templateId?: boolean
    customBody?: boolean
    formSchema?: boolean
    isLocked?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CatalogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "tags" | "namespaceId" | "environmentId" | "templateId" | "customBody" | "formSchema" | "isLocked" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["catalog"]>
  export type CatalogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | AwxEnvironmentDefaultArgs<ExtArgs>
    executions?: boolean | Catalog$executionsArgs<ExtArgs>
    _count?: boolean | CatalogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CatalogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | AwxEnvironmentDefaultArgs<ExtArgs>
  }
  export type CatalogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | AwxEnvironmentDefaultArgs<ExtArgs>
  }

  export type $CatalogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Catalog"
    objects: {
      environment: Prisma.$AwxEnvironmentPayload<ExtArgs>
      executions: Prisma.$CatalogExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      tags: string | null
      namespaceId: string
      environmentId: string
      templateId: string
      customBody: string | null
      formSchema: string | null
      isLocked: boolean
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["catalog"]>
    composites: {}
  }

  type CatalogGetPayload<S extends boolean | null | undefined | CatalogDefaultArgs> = $Result.GetResult<Prisma.$CatalogPayload, S>

  type CatalogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CatalogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CatalogCountAggregateInputType | true
    }

  export interface CatalogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Catalog'], meta: { name: 'Catalog' } }
    /**
     * Find zero or one Catalog that matches the filter.
     * @param {CatalogFindUniqueArgs} args - Arguments to find a Catalog
     * @example
     * // Get one Catalog
     * const catalog = await prisma.catalog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogFindUniqueArgs>(args: SelectSubset<T, CatalogFindUniqueArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Catalog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CatalogFindUniqueOrThrowArgs} args - Arguments to find a Catalog
     * @example
     * // Get one Catalog
     * const catalog = await prisma.catalog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Catalog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogFindFirstArgs} args - Arguments to find a Catalog
     * @example
     * // Get one Catalog
     * const catalog = await prisma.catalog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogFindFirstArgs>(args?: SelectSubset<T, CatalogFindFirstArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Catalog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogFindFirstOrThrowArgs} args - Arguments to find a Catalog
     * @example
     * // Get one Catalog
     * const catalog = await prisma.catalog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Catalogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Catalogs
     * const catalogs = await prisma.catalog.findMany()
     * 
     * // Get first 10 Catalogs
     * const catalogs = await prisma.catalog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogWithIdOnly = await prisma.catalog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatalogFindManyArgs>(args?: SelectSubset<T, CatalogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Catalog.
     * @param {CatalogCreateArgs} args - Arguments to create a Catalog.
     * @example
     * // Create one Catalog
     * const Catalog = await prisma.catalog.create({
     *   data: {
     *     // ... data to create a Catalog
     *   }
     * })
     * 
     */
    create<T extends CatalogCreateArgs>(args: SelectSubset<T, CatalogCreateArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Catalogs.
     * @param {CatalogCreateManyArgs} args - Arguments to create many Catalogs.
     * @example
     * // Create many Catalogs
     * const catalog = await prisma.catalog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogCreateManyArgs>(args?: SelectSubset<T, CatalogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Catalogs and returns the data saved in the database.
     * @param {CatalogCreateManyAndReturnArgs} args - Arguments to create many Catalogs.
     * @example
     * // Create many Catalogs
     * const catalog = await prisma.catalog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Catalogs and only return the `id`
     * const catalogWithIdOnly = await prisma.catalog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatalogCreateManyAndReturnArgs>(args?: SelectSubset<T, CatalogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Catalog.
     * @param {CatalogDeleteArgs} args - Arguments to delete one Catalog.
     * @example
     * // Delete one Catalog
     * const Catalog = await prisma.catalog.delete({
     *   where: {
     *     // ... filter to delete one Catalog
     *   }
     * })
     * 
     */
    delete<T extends CatalogDeleteArgs>(args: SelectSubset<T, CatalogDeleteArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Catalog.
     * @param {CatalogUpdateArgs} args - Arguments to update one Catalog.
     * @example
     * // Update one Catalog
     * const catalog = await prisma.catalog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogUpdateArgs>(args: SelectSubset<T, CatalogUpdateArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Catalogs.
     * @param {CatalogDeleteManyArgs} args - Arguments to filter Catalogs to delete.
     * @example
     * // Delete a few Catalogs
     * const { count } = await prisma.catalog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogDeleteManyArgs>(args?: SelectSubset<T, CatalogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Catalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Catalogs
     * const catalog = await prisma.catalog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogUpdateManyArgs>(args: SelectSubset<T, CatalogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Catalogs and returns the data updated in the database.
     * @param {CatalogUpdateManyAndReturnArgs} args - Arguments to update many Catalogs.
     * @example
     * // Update many Catalogs
     * const catalog = await prisma.catalog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Catalogs and only return the `id`
     * const catalogWithIdOnly = await prisma.catalog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CatalogUpdateManyAndReturnArgs>(args: SelectSubset<T, CatalogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Catalog.
     * @param {CatalogUpsertArgs} args - Arguments to update or create a Catalog.
     * @example
     * // Update or create a Catalog
     * const catalog = await prisma.catalog.upsert({
     *   create: {
     *     // ... data to create a Catalog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Catalog we want to update
     *   }
     * })
     */
    upsert<T extends CatalogUpsertArgs>(args: SelectSubset<T, CatalogUpsertArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Catalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogCountArgs} args - Arguments to filter Catalogs to count.
     * @example
     * // Count the number of Catalogs
     * const count = await prisma.catalog.count({
     *   where: {
     *     // ... the filter for the Catalogs we want to count
     *   }
     * })
    **/
    count<T extends CatalogCountArgs>(
      args?: Subset<T, CatalogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Catalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogAggregateArgs>(args: Subset<T, CatalogAggregateArgs>): Prisma.PrismaPromise<GetCatalogAggregateType<T>>

    /**
     * Group by Catalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogGroupByArgs['orderBy'] }
        : { orderBy?: CatalogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Catalog model
   */
  readonly fields: CatalogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Catalog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    environment<T extends AwxEnvironmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AwxEnvironmentDefaultArgs<ExtArgs>>): Prisma__AwxEnvironmentClient<$Result.GetResult<Prisma.$AwxEnvironmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    executions<T extends Catalog$executionsArgs<ExtArgs> = {}>(args?: Subset<T, Catalog$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Catalog model
   */
  interface CatalogFieldRefs {
    readonly id: FieldRef<"Catalog", 'String'>
    readonly name: FieldRef<"Catalog", 'String'>
    readonly description: FieldRef<"Catalog", 'String'>
    readonly tags: FieldRef<"Catalog", 'String'>
    readonly namespaceId: FieldRef<"Catalog", 'String'>
    readonly environmentId: FieldRef<"Catalog", 'String'>
    readonly templateId: FieldRef<"Catalog", 'String'>
    readonly customBody: FieldRef<"Catalog", 'String'>
    readonly formSchema: FieldRef<"Catalog", 'String'>
    readonly isLocked: FieldRef<"Catalog", 'Boolean'>
    readonly createdBy: FieldRef<"Catalog", 'String'>
    readonly createdAt: FieldRef<"Catalog", 'DateTime'>
    readonly updatedAt: FieldRef<"Catalog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Catalog findUnique
   */
  export type CatalogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * Filter, which Catalog to fetch.
     */
    where: CatalogWhereUniqueInput
  }

  /**
   * Catalog findUniqueOrThrow
   */
  export type CatalogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * Filter, which Catalog to fetch.
     */
    where: CatalogWhereUniqueInput
  }

  /**
   * Catalog findFirst
   */
  export type CatalogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * Filter, which Catalog to fetch.
     */
    where?: CatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Catalogs to fetch.
     */
    orderBy?: CatalogOrderByWithRelationInput | CatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Catalogs.
     */
    cursor?: CatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Catalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Catalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Catalogs.
     */
    distinct?: CatalogScalarFieldEnum | CatalogScalarFieldEnum[]
  }

  /**
   * Catalog findFirstOrThrow
   */
  export type CatalogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * Filter, which Catalog to fetch.
     */
    where?: CatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Catalogs to fetch.
     */
    orderBy?: CatalogOrderByWithRelationInput | CatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Catalogs.
     */
    cursor?: CatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Catalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Catalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Catalogs.
     */
    distinct?: CatalogScalarFieldEnum | CatalogScalarFieldEnum[]
  }

  /**
   * Catalog findMany
   */
  export type CatalogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * Filter, which Catalogs to fetch.
     */
    where?: CatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Catalogs to fetch.
     */
    orderBy?: CatalogOrderByWithRelationInput | CatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Catalogs.
     */
    cursor?: CatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Catalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Catalogs.
     */
    skip?: number
    distinct?: CatalogScalarFieldEnum | CatalogScalarFieldEnum[]
  }

  /**
   * Catalog create
   */
  export type CatalogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * The data needed to create a Catalog.
     */
    data: XOR<CatalogCreateInput, CatalogUncheckedCreateInput>
  }

  /**
   * Catalog createMany
   */
  export type CatalogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Catalogs.
     */
    data: CatalogCreateManyInput | CatalogCreateManyInput[]
  }

  /**
   * Catalog createManyAndReturn
   */
  export type CatalogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * The data used to create many Catalogs.
     */
    data: CatalogCreateManyInput | CatalogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Catalog update
   */
  export type CatalogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * The data needed to update a Catalog.
     */
    data: XOR<CatalogUpdateInput, CatalogUncheckedUpdateInput>
    /**
     * Choose, which Catalog to update.
     */
    where: CatalogWhereUniqueInput
  }

  /**
   * Catalog updateMany
   */
  export type CatalogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Catalogs.
     */
    data: XOR<CatalogUpdateManyMutationInput, CatalogUncheckedUpdateManyInput>
    /**
     * Filter which Catalogs to update
     */
    where?: CatalogWhereInput
    /**
     * Limit how many Catalogs to update.
     */
    limit?: number
  }

  /**
   * Catalog updateManyAndReturn
   */
  export type CatalogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * The data used to update Catalogs.
     */
    data: XOR<CatalogUpdateManyMutationInput, CatalogUncheckedUpdateManyInput>
    /**
     * Filter which Catalogs to update
     */
    where?: CatalogWhereInput
    /**
     * Limit how many Catalogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Catalog upsert
   */
  export type CatalogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * The filter to search for the Catalog to update in case it exists.
     */
    where: CatalogWhereUniqueInput
    /**
     * In case the Catalog found by the `where` argument doesn't exist, create a new Catalog with this data.
     */
    create: XOR<CatalogCreateInput, CatalogUncheckedCreateInput>
    /**
     * In case the Catalog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogUpdateInput, CatalogUncheckedUpdateInput>
  }

  /**
   * Catalog delete
   */
  export type CatalogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
    /**
     * Filter which Catalog to delete.
     */
    where: CatalogWhereUniqueInput
  }

  /**
   * Catalog deleteMany
   */
  export type CatalogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Catalogs to delete
     */
    where?: CatalogWhereInput
    /**
     * Limit how many Catalogs to delete.
     */
    limit?: number
  }

  /**
   * Catalog.executions
   */
  export type Catalog$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogExecution
     */
    select?: CatalogExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogExecution
     */
    omit?: CatalogExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogExecutionInclude<ExtArgs> | null
    where?: CatalogExecutionWhereInput
    orderBy?: CatalogExecutionOrderByWithRelationInput | CatalogExecutionOrderByWithRelationInput[]
    cursor?: CatalogExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogExecutionScalarFieldEnum | CatalogExecutionScalarFieldEnum[]
  }

  /**
   * Catalog without action
   */
  export type CatalogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Catalog
     */
    select?: CatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Catalog
     */
    omit?: CatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogInclude<ExtArgs> | null
  }


  /**
   * Model CatalogExecution
   */

  export type AggregateCatalogExecution = {
    _count: CatalogExecutionCountAggregateOutputType | null
    _min: CatalogExecutionMinAggregateOutputType | null
    _max: CatalogExecutionMaxAggregateOutputType | null
  }

  export type CatalogExecutionMinAggregateOutputType = {
    id: string | null
    catalogId: string | null
    status: string | null
    parameters: string | null
    consoleOutput: string | null
    artifacts: string | null
    errorMessage: string | null
    awxJobId: string | null
    executedBy: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type CatalogExecutionMaxAggregateOutputType = {
    id: string | null
    catalogId: string | null
    status: string | null
    parameters: string | null
    consoleOutput: string | null
    artifacts: string | null
    errorMessage: string | null
    awxJobId: string | null
    executedBy: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type CatalogExecutionCountAggregateOutputType = {
    id: number
    catalogId: number
    status: number
    parameters: number
    consoleOutput: number
    artifacts: number
    errorMessage: number
    awxJobId: number
    executedBy: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type CatalogExecutionMinAggregateInputType = {
    id?: true
    catalogId?: true
    status?: true
    parameters?: true
    consoleOutput?: true
    artifacts?: true
    errorMessage?: true
    awxJobId?: true
    executedBy?: true
    startedAt?: true
    completedAt?: true
  }

  export type CatalogExecutionMaxAggregateInputType = {
    id?: true
    catalogId?: true
    status?: true
    parameters?: true
    consoleOutput?: true
    artifacts?: true
    errorMessage?: true
    awxJobId?: true
    executedBy?: true
    startedAt?: true
    completedAt?: true
  }

  export type CatalogExecutionCountAggregateInputType = {
    id?: true
    catalogId?: true
    status?: true
    parameters?: true
    consoleOutput?: true
    artifacts?: true
    errorMessage?: true
    awxJobId?: true
    executedBy?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type CatalogExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogExecution to aggregate.
     */
    where?: CatalogExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogExecutions to fetch.
     */
    orderBy?: CatalogExecutionOrderByWithRelationInput | CatalogExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogExecutions
    **/
    _count?: true | CatalogExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogExecutionMaxAggregateInputType
  }

  export type GetCatalogExecutionAggregateType<T extends CatalogExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogExecution[P]>
      : GetScalarType<T[P], AggregateCatalogExecution[P]>
  }




  export type CatalogExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogExecutionWhereInput
    orderBy?: CatalogExecutionOrderByWithAggregationInput | CatalogExecutionOrderByWithAggregationInput[]
    by: CatalogExecutionScalarFieldEnum[] | CatalogExecutionScalarFieldEnum
    having?: CatalogExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogExecutionCountAggregateInputType | true
    _min?: CatalogExecutionMinAggregateInputType
    _max?: CatalogExecutionMaxAggregateInputType
  }

  export type CatalogExecutionGroupByOutputType = {
    id: string
    catalogId: string
    status: string
    parameters: string | null
    consoleOutput: string | null
    artifacts: string | null
    errorMessage: string | null
    awxJobId: string | null
    executedBy: string
    startedAt: Date
    completedAt: Date | null
    _count: CatalogExecutionCountAggregateOutputType | null
    _min: CatalogExecutionMinAggregateOutputType | null
    _max: CatalogExecutionMaxAggregateOutputType | null
  }

  type GetCatalogExecutionGroupByPayload<T extends CatalogExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogExecutionGroupByOutputType[P]>
        }
      >
    >


  export type CatalogExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    catalogId?: boolean
    status?: boolean
    parameters?: boolean
    consoleOutput?: boolean
    artifacts?: boolean
    errorMessage?: boolean
    awxJobId?: boolean
    executedBy?: boolean
    startedAt?: boolean
    completedAt?: boolean
    catalog?: boolean | CatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogExecution"]>

  export type CatalogExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    catalogId?: boolean
    status?: boolean
    parameters?: boolean
    consoleOutput?: boolean
    artifacts?: boolean
    errorMessage?: boolean
    awxJobId?: boolean
    executedBy?: boolean
    startedAt?: boolean
    completedAt?: boolean
    catalog?: boolean | CatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogExecution"]>

  export type CatalogExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    catalogId?: boolean
    status?: boolean
    parameters?: boolean
    consoleOutput?: boolean
    artifacts?: boolean
    errorMessage?: boolean
    awxJobId?: boolean
    executedBy?: boolean
    startedAt?: boolean
    completedAt?: boolean
    catalog?: boolean | CatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogExecution"]>

  export type CatalogExecutionSelectScalar = {
    id?: boolean
    catalogId?: boolean
    status?: boolean
    parameters?: boolean
    consoleOutput?: boolean
    artifacts?: boolean
    errorMessage?: boolean
    awxJobId?: boolean
    executedBy?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type CatalogExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "catalogId" | "status" | "parameters" | "consoleOutput" | "artifacts" | "errorMessage" | "awxJobId" | "executedBy" | "startedAt" | "completedAt", ExtArgs["result"]["catalogExecution"]>
  export type CatalogExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catalog?: boolean | CatalogDefaultArgs<ExtArgs>
  }
  export type CatalogExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catalog?: boolean | CatalogDefaultArgs<ExtArgs>
  }
  export type CatalogExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catalog?: boolean | CatalogDefaultArgs<ExtArgs>
  }

  export type $CatalogExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogExecution"
    objects: {
      catalog: Prisma.$CatalogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      catalogId: string
      status: string
      parameters: string | null
      consoleOutput: string | null
      artifacts: string | null
      errorMessage: string | null
      awxJobId: string | null
      executedBy: string
      startedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["catalogExecution"]>
    composites: {}
  }

  type CatalogExecutionGetPayload<S extends boolean | null | undefined | CatalogExecutionDefaultArgs> = $Result.GetResult<Prisma.$CatalogExecutionPayload, S>

  type CatalogExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CatalogExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CatalogExecutionCountAggregateInputType | true
    }

  export interface CatalogExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogExecution'], meta: { name: 'CatalogExecution' } }
    /**
     * Find zero or one CatalogExecution that matches the filter.
     * @param {CatalogExecutionFindUniqueArgs} args - Arguments to find a CatalogExecution
     * @example
     * // Get one CatalogExecution
     * const catalogExecution = await prisma.catalogExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogExecutionFindUniqueArgs>(args: SelectSubset<T, CatalogExecutionFindUniqueArgs<ExtArgs>>): Prisma__CatalogExecutionClient<$Result.GetResult<Prisma.$CatalogExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CatalogExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CatalogExecutionFindUniqueOrThrowArgs} args - Arguments to find a CatalogExecution
     * @example
     * // Get one CatalogExecution
     * const catalogExecution = await prisma.catalogExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogExecutionClient<$Result.GetResult<Prisma.$CatalogExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CatalogExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogExecutionFindFirstArgs} args - Arguments to find a CatalogExecution
     * @example
     * // Get one CatalogExecution
     * const catalogExecution = await prisma.catalogExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogExecutionFindFirstArgs>(args?: SelectSubset<T, CatalogExecutionFindFirstArgs<ExtArgs>>): Prisma__CatalogExecutionClient<$Result.GetResult<Prisma.$CatalogExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CatalogExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogExecutionFindFirstOrThrowArgs} args - Arguments to find a CatalogExecution
     * @example
     * // Get one CatalogExecution
     * const catalogExecution = await prisma.catalogExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogExecutionClient<$Result.GetResult<Prisma.$CatalogExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CatalogExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogExecutions
     * const catalogExecutions = await prisma.catalogExecution.findMany()
     * 
     * // Get first 10 CatalogExecutions
     * const catalogExecutions = await prisma.catalogExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogExecutionWithIdOnly = await prisma.catalogExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatalogExecutionFindManyArgs>(args?: SelectSubset<T, CatalogExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CatalogExecution.
     * @param {CatalogExecutionCreateArgs} args - Arguments to create a CatalogExecution.
     * @example
     * // Create one CatalogExecution
     * const CatalogExecution = await prisma.catalogExecution.create({
     *   data: {
     *     // ... data to create a CatalogExecution
     *   }
     * })
     * 
     */
    create<T extends CatalogExecutionCreateArgs>(args: SelectSubset<T, CatalogExecutionCreateArgs<ExtArgs>>): Prisma__CatalogExecutionClient<$Result.GetResult<Prisma.$CatalogExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CatalogExecutions.
     * @param {CatalogExecutionCreateManyArgs} args - Arguments to create many CatalogExecutions.
     * @example
     * // Create many CatalogExecutions
     * const catalogExecution = await prisma.catalogExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogExecutionCreateManyArgs>(args?: SelectSubset<T, CatalogExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogExecutions and returns the data saved in the database.
     * @param {CatalogExecutionCreateManyAndReturnArgs} args - Arguments to create many CatalogExecutions.
     * @example
     * // Create many CatalogExecutions
     * const catalogExecution = await prisma.catalogExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogExecutions and only return the `id`
     * const catalogExecutionWithIdOnly = await prisma.catalogExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatalogExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, CatalogExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CatalogExecution.
     * @param {CatalogExecutionDeleteArgs} args - Arguments to delete one CatalogExecution.
     * @example
     * // Delete one CatalogExecution
     * const CatalogExecution = await prisma.catalogExecution.delete({
     *   where: {
     *     // ... filter to delete one CatalogExecution
     *   }
     * })
     * 
     */
    delete<T extends CatalogExecutionDeleteArgs>(args: SelectSubset<T, CatalogExecutionDeleteArgs<ExtArgs>>): Prisma__CatalogExecutionClient<$Result.GetResult<Prisma.$CatalogExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CatalogExecution.
     * @param {CatalogExecutionUpdateArgs} args - Arguments to update one CatalogExecution.
     * @example
     * // Update one CatalogExecution
     * const catalogExecution = await prisma.catalogExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogExecutionUpdateArgs>(args: SelectSubset<T, CatalogExecutionUpdateArgs<ExtArgs>>): Prisma__CatalogExecutionClient<$Result.GetResult<Prisma.$CatalogExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CatalogExecutions.
     * @param {CatalogExecutionDeleteManyArgs} args - Arguments to filter CatalogExecutions to delete.
     * @example
     * // Delete a few CatalogExecutions
     * const { count } = await prisma.catalogExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogExecutionDeleteManyArgs>(args?: SelectSubset<T, CatalogExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogExecutions
     * const catalogExecution = await prisma.catalogExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogExecutionUpdateManyArgs>(args: SelectSubset<T, CatalogExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogExecutions and returns the data updated in the database.
     * @param {CatalogExecutionUpdateManyAndReturnArgs} args - Arguments to update many CatalogExecutions.
     * @example
     * // Update many CatalogExecutions
     * const catalogExecution = await prisma.catalogExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CatalogExecutions and only return the `id`
     * const catalogExecutionWithIdOnly = await prisma.catalogExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CatalogExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, CatalogExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CatalogExecution.
     * @param {CatalogExecutionUpsertArgs} args - Arguments to update or create a CatalogExecution.
     * @example
     * // Update or create a CatalogExecution
     * const catalogExecution = await prisma.catalogExecution.upsert({
     *   create: {
     *     // ... data to create a CatalogExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogExecution we want to update
     *   }
     * })
     */
    upsert<T extends CatalogExecutionUpsertArgs>(args: SelectSubset<T, CatalogExecutionUpsertArgs<ExtArgs>>): Prisma__CatalogExecutionClient<$Result.GetResult<Prisma.$CatalogExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CatalogExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogExecutionCountArgs} args - Arguments to filter CatalogExecutions to count.
     * @example
     * // Count the number of CatalogExecutions
     * const count = await prisma.catalogExecution.count({
     *   where: {
     *     // ... the filter for the CatalogExecutions we want to count
     *   }
     * })
    **/
    count<T extends CatalogExecutionCountArgs>(
      args?: Subset<T, CatalogExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogExecutionAggregateArgs>(args: Subset<T, CatalogExecutionAggregateArgs>): Prisma.PrismaPromise<GetCatalogExecutionAggregateType<T>>

    /**
     * Group by CatalogExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogExecutionGroupByArgs['orderBy'] }
        : { orderBy?: CatalogExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogExecution model
   */
  readonly fields: CatalogExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    catalog<T extends CatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogDefaultArgs<ExtArgs>>): Prisma__CatalogClient<$Result.GetResult<Prisma.$CatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatalogExecution model
   */
  interface CatalogExecutionFieldRefs {
    readonly id: FieldRef<"CatalogExecution", 'String'>
    readonly catalogId: FieldRef<"CatalogExecution", 'String'>
    readonly status: FieldRef<"CatalogExecution", 'String'>
    readonly parameters: FieldRef<"CatalogExecution", 'String'>
    readonly consoleOutput: FieldRef<"CatalogExecution", 'String'>
    readonly artifacts: FieldRef<"CatalogExecution", 'String'>
    readonly errorMessage: FieldRef<"CatalogExecution", 'String'>
    readonly awxJobId: FieldRef<"CatalogExecution", 'String'>
    readonly executedBy: FieldRef<"CatalogExecution", 'String'>
    readonly startedAt: FieldRef<"CatalogExecution", 'DateTime'>
    readonly completedAt: FieldRef<"CatalogExecution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatalogExecution findUnique
   */
  export type CatalogExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogExecution
     */
    select?: CatalogExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogExecution
     */
    omit?: CatalogExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogExecutionInclude<ExtArgs> | null
    /**
     * Filter, which CatalogExecution to fetch.
     */
    where: CatalogExecutionWhereUniqueInput
  }

  /**
   * CatalogExecution findUniqueOrThrow
   */
  export type CatalogExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogExecution
     */
    select?: CatalogExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogExecution
     */
    omit?: CatalogExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogExecutionInclude<ExtArgs> | null
    /**
     * Filter, which CatalogExecution to fetch.
     */
    where: CatalogExecutionWhereUniqueInput
  }

  /**
   * CatalogExecution findFirst
   */
  export type CatalogExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogExecution
     */
    select?: CatalogExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogExecution
     */
    omit?: CatalogExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogExecutionInclude<ExtArgs> | null
    /**
     * Filter, which CatalogExecution to fetch.
     */
    where?: CatalogExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogExecutions to fetch.
     */
    orderBy?: CatalogExecutionOrderByWithRelationInput | CatalogExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogExecutions.
     */
    cursor?: CatalogExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogExecutions.
     */
    distinct?: CatalogExecutionScalarFieldEnum | CatalogExecutionScalarFieldEnum[]
  }

  /**
   * CatalogExecution findFirstOrThrow
   */
  export type CatalogExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogExecution
     */
    select?: CatalogExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogExecution
     */
    omit?: CatalogExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogExecutionInclude<ExtArgs> | null
    /**
     * Filter, which CatalogExecution to fetch.
     */
    where?: CatalogExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogExecutions to fetch.
     */
    orderBy?: CatalogExecutionOrderByWithRelationInput | CatalogExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogExecutions.
     */
    cursor?: CatalogExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogExecutions.
     */
    distinct?: CatalogExecutionScalarFieldEnum | CatalogExecutionScalarFieldEnum[]
  }

  /**
   * CatalogExecution findMany
   */
  export type CatalogExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogExecution
     */
    select?: CatalogExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogExecution
     */
    omit?: CatalogExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogExecutionInclude<ExtArgs> | null
    /**
     * Filter, which CatalogExecutions to fetch.
     */
    where?: CatalogExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogExecutions to fetch.
     */
    orderBy?: CatalogExecutionOrderByWithRelationInput | CatalogExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogExecutions.
     */
    cursor?: CatalogExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogExecutions.
     */
    skip?: number
    distinct?: CatalogExecutionScalarFieldEnum | CatalogExecutionScalarFieldEnum[]
  }

  /**
   * CatalogExecution create
   */
  export type CatalogExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogExecution
     */
    select?: CatalogExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogExecution
     */
    omit?: CatalogExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogExecution.
     */
    data: XOR<CatalogExecutionCreateInput, CatalogExecutionUncheckedCreateInput>
  }

  /**
   * CatalogExecution createMany
   */
  export type CatalogExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogExecutions.
     */
    data: CatalogExecutionCreateManyInput | CatalogExecutionCreateManyInput[]
  }

  /**
   * CatalogExecution createManyAndReturn
   */
  export type CatalogExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogExecution
     */
    select?: CatalogExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogExecution
     */
    omit?: CatalogExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many CatalogExecutions.
     */
    data: CatalogExecutionCreateManyInput | CatalogExecutionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatalogExecution update
   */
  export type CatalogExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogExecution
     */
    select?: CatalogExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogExecution
     */
    omit?: CatalogExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogExecution.
     */
    data: XOR<CatalogExecutionUpdateInput, CatalogExecutionUncheckedUpdateInput>
    /**
     * Choose, which CatalogExecution to update.
     */
    where: CatalogExecutionWhereUniqueInput
  }

  /**
   * CatalogExecution updateMany
   */
  export type CatalogExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogExecutions.
     */
    data: XOR<CatalogExecutionUpdateManyMutationInput, CatalogExecutionUncheckedUpdateManyInput>
    /**
     * Filter which CatalogExecutions to update
     */
    where?: CatalogExecutionWhereInput
    /**
     * Limit how many CatalogExecutions to update.
     */
    limit?: number
  }

  /**
   * CatalogExecution updateManyAndReturn
   */
  export type CatalogExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogExecution
     */
    select?: CatalogExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogExecution
     */
    omit?: CatalogExecutionOmit<ExtArgs> | null
    /**
     * The data used to update CatalogExecutions.
     */
    data: XOR<CatalogExecutionUpdateManyMutationInput, CatalogExecutionUncheckedUpdateManyInput>
    /**
     * Filter which CatalogExecutions to update
     */
    where?: CatalogExecutionWhereInput
    /**
     * Limit how many CatalogExecutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatalogExecution upsert
   */
  export type CatalogExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogExecution
     */
    select?: CatalogExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogExecution
     */
    omit?: CatalogExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogExecution to update in case it exists.
     */
    where: CatalogExecutionWhereUniqueInput
    /**
     * In case the CatalogExecution found by the `where` argument doesn't exist, create a new CatalogExecution with this data.
     */
    create: XOR<CatalogExecutionCreateInput, CatalogExecutionUncheckedCreateInput>
    /**
     * In case the CatalogExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogExecutionUpdateInput, CatalogExecutionUncheckedUpdateInput>
  }

  /**
   * CatalogExecution delete
   */
  export type CatalogExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogExecution
     */
    select?: CatalogExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogExecution
     */
    omit?: CatalogExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogExecutionInclude<ExtArgs> | null
    /**
     * Filter which CatalogExecution to delete.
     */
    where: CatalogExecutionWhereUniqueInput
  }

  /**
   * CatalogExecution deleteMany
   */
  export type CatalogExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogExecutions to delete
     */
    where?: CatalogExecutionWhereInput
    /**
     * Limit how many CatalogExecutions to delete.
     */
    limit?: number
  }

  /**
   * CatalogExecution without action
   */
  export type CatalogExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogExecution
     */
    select?: CatalogExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatalogExecution
     */
    omit?: CatalogExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogExecutionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AutomationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    namespace: 'namespace',
    description: 'description',
    keywords: 'keywords',
    tags: 'tags',
    formSchema: 'formSchema',
    apiEndpoint: 'apiEndpoint',
    templateId: 'templateId',
    inventoryId: 'inventoryId',
    instanceGroupId: 'instanceGroupId',
    extraVars: 'extraVars',
    customBody: 'customBody',
    pinned: 'pinned',
    featured: 'featured',
    runs: 'runs',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AutomationScalarFieldEnum = (typeof AutomationScalarFieldEnum)[keyof typeof AutomationScalarFieldEnum]


  export const RunScalarFieldEnum: {
    id: 'id',
    automationId: 'automationId',
    status: 'status',
    uniqueId: 'uniqueId',
    parameters: 'parameters',
    result: 'result',
    artifacts: 'artifacts',
    errorMessage: 'errorMessage',
    executedBy: 'executedBy',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    awxJobId: 'awxJobId'
  };

  export type RunScalarFieldEnum = (typeof RunScalarFieldEnum)[keyof typeof RunScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    automationId: 'automationId',
    frequency: 'frequency',
    cron: 'cron',
    parameters: 'parameters',
    status: 'status',
    nextRun: 'nextRun',
    lastRun: 'lastRun',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    message: 'message',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ConnectivityCheckScalarFieldEnum: {
    id: 'id',
    servers: 'servers',
    ports: 'ports',
    email: 'email',
    status: 'status',
    results: 'results',
    createdAt: 'createdAt',
    completedAt: 'completedAt'
  };

  export type ConnectivityCheckScalarFieldEnum = (typeof ConnectivityCheckScalarFieldEnum)[keyof typeof ConnectivityCheckScalarFieldEnum]


  export const NamespaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    color: 'color',
    icon: 'icon',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NamespaceScalarFieldEnum = (typeof NamespaceScalarFieldEnum)[keyof typeof NamespaceScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    name: 'name',
    samAccountName: 'samAccountName',
    email: 'email',
    password: 'password',
    role: 'role',
    enabled: 'enabled',
    locked: 'locked',
    approved: 'approved',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    location: 'location',
    department: 'department',
    profilePhoto: 'profilePhoto',
    managerId: 'managerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isPredefined: 'isPredefined',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const GroupMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    groupId: 'groupId',
    createdAt: 'createdAt'
  };

  export type GroupMemberScalarFieldEnum = (typeof GroupMemberScalarFieldEnum)[keyof typeof GroupMemberScalarFieldEnum]


  export const NamespacePermissionScalarFieldEnum: {
    id: 'id',
    namespaceId: 'namespaceId',
    userId: 'userId',
    groupId: 'groupId',
    canRead: 'canRead',
    canWrite: 'canWrite',
    canExecute: 'canExecute',
    canAdmin: 'canAdmin',
    createdAt: 'createdAt'
  };

  export type NamespacePermissionScalarFieldEnum = (typeof NamespacePermissionScalarFieldEnum)[keyof typeof NamespacePermissionScalarFieldEnum]


  export const ModulePermissionScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    module: 'module',
    canRead: 'canRead',
    canWrite: 'canWrite',
    canDelete: 'canDelete',
    createdAt: 'createdAt'
  };

  export type ModulePermissionScalarFieldEnum = (typeof ModulePermissionScalarFieldEnum)[keyof typeof ModulePermissionScalarFieldEnum]


  export const CredentialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    credentialType: 'credentialType',
    username: 'username',
    password: 'password',
    sshPrivateKey: 'sshPrivateKey',
    vaultPassword: 'vaultPassword',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CredentialScalarFieldEnum = (typeof CredentialScalarFieldEnum)[keyof typeof CredentialScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    entityName: 'entityName',
    description: 'description',
    performedBy: 'performedBy',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const RunCounterScalarFieldEnum: {
    id: 'id',
    year: 'year',
    pool: 'pool',
    sequence: 'sequence',
    lastUsed: 'lastUsed'
  };

  export type RunCounterScalarFieldEnum = (typeof RunCounterScalarFieldEnum)[keyof typeof RunCounterScalarFieldEnum]


  export const InstanceGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    awxId: 'awxId',
    description: 'description',
    enabled: 'enabled',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstanceGroupScalarFieldEnum = (typeof InstanceGroupScalarFieldEnum)[keyof typeof InstanceGroupScalarFieldEnum]


  export const AwxEnvironmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    baseUrl: 'baseUrl',
    token: 'token',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AwxEnvironmentScalarFieldEnum = (typeof AwxEnvironmentScalarFieldEnum)[keyof typeof AwxEnvironmentScalarFieldEnum]


  export const CatalogScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    tags: 'tags',
    namespaceId: 'namespaceId',
    environmentId: 'environmentId',
    templateId: 'templateId',
    customBody: 'customBody',
    formSchema: 'formSchema',
    isLocked: 'isLocked',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CatalogScalarFieldEnum = (typeof CatalogScalarFieldEnum)[keyof typeof CatalogScalarFieldEnum]


  export const CatalogExecutionScalarFieldEnum: {
    id: 'id',
    catalogId: 'catalogId',
    status: 'status',
    parameters: 'parameters',
    consoleOutput: 'consoleOutput',
    artifacts: 'artifacts',
    errorMessage: 'errorMessage',
    awxJobId: 'awxJobId',
    executedBy: 'executedBy',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type CatalogExecutionScalarFieldEnum = (typeof CatalogExecutionScalarFieldEnum)[keyof typeof CatalogExecutionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type AutomationWhereInput = {
    AND?: AutomationWhereInput | AutomationWhereInput[]
    OR?: AutomationWhereInput[]
    NOT?: AutomationWhereInput | AutomationWhereInput[]
    id?: StringFilter<"Automation"> | string
    name?: StringFilter<"Automation"> | string
    namespace?: StringFilter<"Automation"> | string
    description?: StringNullableFilter<"Automation"> | string | null
    keywords?: StringNullableFilter<"Automation"> | string | null
    tags?: StringNullableFilter<"Automation"> | string | null
    formSchema?: StringFilter<"Automation"> | string
    apiEndpoint?: StringNullableFilter<"Automation"> | string | null
    templateId?: StringFilter<"Automation"> | string
    inventoryId?: StringNullableFilter<"Automation"> | string | null
    instanceGroupId?: StringNullableFilter<"Automation"> | string | null
    extraVars?: StringNullableFilter<"Automation"> | string | null
    customBody?: StringNullableFilter<"Automation"> | string | null
    pinned?: BoolFilter<"Automation"> | boolean
    featured?: BoolFilter<"Automation"> | boolean
    runs?: IntFilter<"Automation"> | number
    createdBy?: StringFilter<"Automation"> | string
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    runs_history?: RunListRelationFilter
    schedules?: ScheduleListRelationFilter
  }

  export type AutomationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    namespace?: SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    formSchema?: SortOrder
    apiEndpoint?: SortOrderInput | SortOrder
    templateId?: SortOrder
    inventoryId?: SortOrderInput | SortOrder
    instanceGroupId?: SortOrderInput | SortOrder
    extraVars?: SortOrderInput | SortOrder
    customBody?: SortOrderInput | SortOrder
    pinned?: SortOrder
    featured?: SortOrder
    runs?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    runs_history?: RunOrderByRelationAggregateInput
    schedules?: ScheduleOrderByRelationAggregateInput
  }

  export type AutomationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AutomationWhereInput | AutomationWhereInput[]
    OR?: AutomationWhereInput[]
    NOT?: AutomationWhereInput | AutomationWhereInput[]
    namespace?: StringFilter<"Automation"> | string
    description?: StringNullableFilter<"Automation"> | string | null
    keywords?: StringNullableFilter<"Automation"> | string | null
    tags?: StringNullableFilter<"Automation"> | string | null
    formSchema?: StringFilter<"Automation"> | string
    apiEndpoint?: StringNullableFilter<"Automation"> | string | null
    templateId?: StringFilter<"Automation"> | string
    inventoryId?: StringNullableFilter<"Automation"> | string | null
    instanceGroupId?: StringNullableFilter<"Automation"> | string | null
    extraVars?: StringNullableFilter<"Automation"> | string | null
    customBody?: StringNullableFilter<"Automation"> | string | null
    pinned?: BoolFilter<"Automation"> | boolean
    featured?: BoolFilter<"Automation"> | boolean
    runs?: IntFilter<"Automation"> | number
    createdBy?: StringFilter<"Automation"> | string
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    runs_history?: RunListRelationFilter
    schedules?: ScheduleListRelationFilter
  }, "id" | "name">

  export type AutomationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    namespace?: SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    formSchema?: SortOrder
    apiEndpoint?: SortOrderInput | SortOrder
    templateId?: SortOrder
    inventoryId?: SortOrderInput | SortOrder
    instanceGroupId?: SortOrderInput | SortOrder
    extraVars?: SortOrderInput | SortOrder
    customBody?: SortOrderInput | SortOrder
    pinned?: SortOrder
    featured?: SortOrder
    runs?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AutomationCountOrderByAggregateInput
    _avg?: AutomationAvgOrderByAggregateInput
    _max?: AutomationMaxOrderByAggregateInput
    _min?: AutomationMinOrderByAggregateInput
    _sum?: AutomationSumOrderByAggregateInput
  }

  export type AutomationScalarWhereWithAggregatesInput = {
    AND?: AutomationScalarWhereWithAggregatesInput | AutomationScalarWhereWithAggregatesInput[]
    OR?: AutomationScalarWhereWithAggregatesInput[]
    NOT?: AutomationScalarWhereWithAggregatesInput | AutomationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Automation"> | string
    name?: StringWithAggregatesFilter<"Automation"> | string
    namespace?: StringWithAggregatesFilter<"Automation"> | string
    description?: StringNullableWithAggregatesFilter<"Automation"> | string | null
    keywords?: StringNullableWithAggregatesFilter<"Automation"> | string | null
    tags?: StringNullableWithAggregatesFilter<"Automation"> | string | null
    formSchema?: StringWithAggregatesFilter<"Automation"> | string
    apiEndpoint?: StringNullableWithAggregatesFilter<"Automation"> | string | null
    templateId?: StringWithAggregatesFilter<"Automation"> | string
    inventoryId?: StringNullableWithAggregatesFilter<"Automation"> | string | null
    instanceGroupId?: StringNullableWithAggregatesFilter<"Automation"> | string | null
    extraVars?: StringNullableWithAggregatesFilter<"Automation"> | string | null
    customBody?: StringNullableWithAggregatesFilter<"Automation"> | string | null
    pinned?: BoolWithAggregatesFilter<"Automation"> | boolean
    featured?: BoolWithAggregatesFilter<"Automation"> | boolean
    runs?: IntWithAggregatesFilter<"Automation"> | number
    createdBy?: StringWithAggregatesFilter<"Automation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Automation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Automation"> | Date | string
  }

  export type RunWhereInput = {
    AND?: RunWhereInput | RunWhereInput[]
    OR?: RunWhereInput[]
    NOT?: RunWhereInput | RunWhereInput[]
    id?: StringFilter<"Run"> | string
    automationId?: StringFilter<"Run"> | string
    status?: StringFilter<"Run"> | string
    uniqueId?: StringNullableFilter<"Run"> | string | null
    parameters?: StringNullableFilter<"Run"> | string | null
    result?: StringNullableFilter<"Run"> | string | null
    artifacts?: StringNullableFilter<"Run"> | string | null
    errorMessage?: StringNullableFilter<"Run"> | string | null
    executedBy?: StringNullableFilter<"Run"> | string | null
    startedAt?: DateTimeFilter<"Run"> | Date | string
    completedAt?: DateTimeNullableFilter<"Run"> | Date | string | null
    awxJobId?: StringNullableFilter<"Run"> | string | null
    automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
  }

  export type RunOrderByWithRelationInput = {
    id?: SortOrder
    automationId?: SortOrder
    status?: SortOrder
    uniqueId?: SortOrderInput | SortOrder
    parameters?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    artifacts?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    executedBy?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    awxJobId?: SortOrderInput | SortOrder
    automation?: AutomationOrderByWithRelationInput
  }

  export type RunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uniqueId?: string
    AND?: RunWhereInput | RunWhereInput[]
    OR?: RunWhereInput[]
    NOT?: RunWhereInput | RunWhereInput[]
    automationId?: StringFilter<"Run"> | string
    status?: StringFilter<"Run"> | string
    parameters?: StringNullableFilter<"Run"> | string | null
    result?: StringNullableFilter<"Run"> | string | null
    artifacts?: StringNullableFilter<"Run"> | string | null
    errorMessage?: StringNullableFilter<"Run"> | string | null
    executedBy?: StringNullableFilter<"Run"> | string | null
    startedAt?: DateTimeFilter<"Run"> | Date | string
    completedAt?: DateTimeNullableFilter<"Run"> | Date | string | null
    awxJobId?: StringNullableFilter<"Run"> | string | null
    automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
  }, "id" | "uniqueId">

  export type RunOrderByWithAggregationInput = {
    id?: SortOrder
    automationId?: SortOrder
    status?: SortOrder
    uniqueId?: SortOrderInput | SortOrder
    parameters?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    artifacts?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    executedBy?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    awxJobId?: SortOrderInput | SortOrder
    _count?: RunCountOrderByAggregateInput
    _max?: RunMaxOrderByAggregateInput
    _min?: RunMinOrderByAggregateInput
  }

  export type RunScalarWhereWithAggregatesInput = {
    AND?: RunScalarWhereWithAggregatesInput | RunScalarWhereWithAggregatesInput[]
    OR?: RunScalarWhereWithAggregatesInput[]
    NOT?: RunScalarWhereWithAggregatesInput | RunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Run"> | string
    automationId?: StringWithAggregatesFilter<"Run"> | string
    status?: StringWithAggregatesFilter<"Run"> | string
    uniqueId?: StringNullableWithAggregatesFilter<"Run"> | string | null
    parameters?: StringNullableWithAggregatesFilter<"Run"> | string | null
    result?: StringNullableWithAggregatesFilter<"Run"> | string | null
    artifacts?: StringNullableWithAggregatesFilter<"Run"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"Run"> | string | null
    executedBy?: StringNullableWithAggregatesFilter<"Run"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"Run"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Run"> | Date | string | null
    awxJobId?: StringNullableWithAggregatesFilter<"Run"> | string | null
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: StringFilter<"Schedule"> | string
    name?: StringFilter<"Schedule"> | string
    automationId?: StringFilter<"Schedule"> | string
    frequency?: StringFilter<"Schedule"> | string
    cron?: StringFilter<"Schedule"> | string
    parameters?: StringNullableFilter<"Schedule"> | string | null
    status?: StringFilter<"Schedule"> | string
    nextRun?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    lastRun?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    automationId?: SortOrder
    frequency?: SortOrder
    cron?: SortOrder
    parameters?: SortOrderInput | SortOrder
    status?: SortOrder
    nextRun?: SortOrderInput | SortOrder
    lastRun?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automation?: AutomationOrderByWithRelationInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    name?: StringFilter<"Schedule"> | string
    automationId?: StringFilter<"Schedule"> | string
    frequency?: StringFilter<"Schedule"> | string
    cron?: StringFilter<"Schedule"> | string
    parameters?: StringNullableFilter<"Schedule"> | string | null
    status?: StringFilter<"Schedule"> | string
    nextRun?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    lastRun?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
  }, "id">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    automationId?: SortOrder
    frequency?: SortOrder
    cron?: SortOrder
    parameters?: SortOrderInput | SortOrder
    status?: SortOrder
    nextRun?: SortOrderInput | SortOrder
    lastRun?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Schedule"> | string
    name?: StringWithAggregatesFilter<"Schedule"> | string
    automationId?: StringWithAggregatesFilter<"Schedule"> | string
    frequency?: StringWithAggregatesFilter<"Schedule"> | string
    cron?: StringWithAggregatesFilter<"Schedule"> | string
    parameters?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    status?: StringWithAggregatesFilter<"Schedule"> | string
    nextRun?: DateTimeNullableWithAggregatesFilter<"Schedule"> | Date | string | null
    lastRun?: DateTimeNullableWithAggregatesFilter<"Schedule"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ConnectivityCheckWhereInput = {
    AND?: ConnectivityCheckWhereInput | ConnectivityCheckWhereInput[]
    OR?: ConnectivityCheckWhereInput[]
    NOT?: ConnectivityCheckWhereInput | ConnectivityCheckWhereInput[]
    id?: StringFilter<"ConnectivityCheck"> | string
    servers?: StringFilter<"ConnectivityCheck"> | string
    ports?: StringFilter<"ConnectivityCheck"> | string
    email?: StringFilter<"ConnectivityCheck"> | string
    status?: StringFilter<"ConnectivityCheck"> | string
    results?: StringNullableFilter<"ConnectivityCheck"> | string | null
    createdAt?: DateTimeFilter<"ConnectivityCheck"> | Date | string
    completedAt?: DateTimeNullableFilter<"ConnectivityCheck"> | Date | string | null
  }

  export type ConnectivityCheckOrderByWithRelationInput = {
    id?: SortOrder
    servers?: SortOrder
    ports?: SortOrder
    email?: SortOrder
    status?: SortOrder
    results?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
  }

  export type ConnectivityCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConnectivityCheckWhereInput | ConnectivityCheckWhereInput[]
    OR?: ConnectivityCheckWhereInput[]
    NOT?: ConnectivityCheckWhereInput | ConnectivityCheckWhereInput[]
    servers?: StringFilter<"ConnectivityCheck"> | string
    ports?: StringFilter<"ConnectivityCheck"> | string
    email?: StringFilter<"ConnectivityCheck"> | string
    status?: StringFilter<"ConnectivityCheck"> | string
    results?: StringNullableFilter<"ConnectivityCheck"> | string | null
    createdAt?: DateTimeFilter<"ConnectivityCheck"> | Date | string
    completedAt?: DateTimeNullableFilter<"ConnectivityCheck"> | Date | string | null
  }, "id">

  export type ConnectivityCheckOrderByWithAggregationInput = {
    id?: SortOrder
    servers?: SortOrder
    ports?: SortOrder
    email?: SortOrder
    status?: SortOrder
    results?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: ConnectivityCheckCountOrderByAggregateInput
    _max?: ConnectivityCheckMaxOrderByAggregateInput
    _min?: ConnectivityCheckMinOrderByAggregateInput
  }

  export type ConnectivityCheckScalarWhereWithAggregatesInput = {
    AND?: ConnectivityCheckScalarWhereWithAggregatesInput | ConnectivityCheckScalarWhereWithAggregatesInput[]
    OR?: ConnectivityCheckScalarWhereWithAggregatesInput[]
    NOT?: ConnectivityCheckScalarWhereWithAggregatesInput | ConnectivityCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConnectivityCheck"> | string
    servers?: StringWithAggregatesFilter<"ConnectivityCheck"> | string
    ports?: StringWithAggregatesFilter<"ConnectivityCheck"> | string
    email?: StringWithAggregatesFilter<"ConnectivityCheck"> | string
    status?: StringWithAggregatesFilter<"ConnectivityCheck"> | string
    results?: StringNullableWithAggregatesFilter<"ConnectivityCheck"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConnectivityCheck"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ConnectivityCheck"> | Date | string | null
  }

  export type NamespaceWhereInput = {
    AND?: NamespaceWhereInput | NamespaceWhereInput[]
    OR?: NamespaceWhereInput[]
    NOT?: NamespaceWhereInput | NamespaceWhereInput[]
    id?: StringFilter<"Namespace"> | string
    name?: StringFilter<"Namespace"> | string
    displayName?: StringFilter<"Namespace"> | string
    description?: StringNullableFilter<"Namespace"> | string | null
    color?: StringFilter<"Namespace"> | string
    icon?: StringNullableFilter<"Namespace"> | string | null
    createdBy?: StringFilter<"Namespace"> | string
    createdAt?: DateTimeFilter<"Namespace"> | Date | string
    updatedAt?: DateTimeFilter<"Namespace"> | Date | string
    permissions?: NamespacePermissionListRelationFilter
  }

  export type NamespaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: NamespacePermissionOrderByRelationAggregateInput
  }

  export type NamespaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: NamespaceWhereInput | NamespaceWhereInput[]
    OR?: NamespaceWhereInput[]
    NOT?: NamespaceWhereInput | NamespaceWhereInput[]
    displayName?: StringFilter<"Namespace"> | string
    description?: StringNullableFilter<"Namespace"> | string | null
    color?: StringFilter<"Namespace"> | string
    icon?: StringNullableFilter<"Namespace"> | string | null
    createdBy?: StringFilter<"Namespace"> | string
    createdAt?: DateTimeFilter<"Namespace"> | Date | string
    updatedAt?: DateTimeFilter<"Namespace"> | Date | string
    permissions?: NamespacePermissionListRelationFilter
  }, "id" | "name">

  export type NamespaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NamespaceCountOrderByAggregateInput
    _max?: NamespaceMaxOrderByAggregateInput
    _min?: NamespaceMinOrderByAggregateInput
  }

  export type NamespaceScalarWhereWithAggregatesInput = {
    AND?: NamespaceScalarWhereWithAggregatesInput | NamespaceScalarWhereWithAggregatesInput[]
    OR?: NamespaceScalarWhereWithAggregatesInput[]
    NOT?: NamespaceScalarWhereWithAggregatesInput | NamespaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Namespace"> | string
    name?: StringWithAggregatesFilter<"Namespace"> | string
    displayName?: StringWithAggregatesFilter<"Namespace"> | string
    description?: StringNullableWithAggregatesFilter<"Namespace"> | string | null
    color?: StringWithAggregatesFilter<"Namespace"> | string
    icon?: StringNullableWithAggregatesFilter<"Namespace"> | string | null
    createdBy?: StringWithAggregatesFilter<"Namespace"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Namespace"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Namespace"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    samAccountName?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    enabled?: BoolFilter<"User"> | boolean
    locked?: BoolFilter<"User"> | boolean
    approved?: BoolFilter<"User"> | boolean
    approvedBy?: StringNullableFilter<"User"> | string | null
    approvedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    location?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    profilePhoto?: StringNullableFilter<"User"> | string | null
    managerId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subordinates?: UserListRelationFilter
    groupMemberships?: GroupMemberListRelationFilter
    permissions?: NamespacePermissionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    samAccountName?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    enabled?: SortOrder
    locked?: SortOrder
    approved?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    manager?: UserOrderByWithRelationInput
    subordinates?: UserOrderByRelationAggregateInput
    groupMemberships?: GroupMemberOrderByRelationAggregateInput
    permissions?: NamespacePermissionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    samAccountName?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    enabled?: BoolFilter<"User"> | boolean
    locked?: BoolFilter<"User"> | boolean
    approved?: BoolFilter<"User"> | boolean
    approvedBy?: StringNullableFilter<"User"> | string | null
    approvedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    location?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    profilePhoto?: StringNullableFilter<"User"> | string | null
    managerId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subordinates?: UserListRelationFilter
    groupMemberships?: GroupMemberListRelationFilter
    permissions?: NamespacePermissionListRelationFilter
  }, "id" | "samAccountName" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    samAccountName?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    enabled?: SortOrder
    locked?: SortOrder
    approved?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    samAccountName?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    enabled?: BoolWithAggregatesFilter<"User"> | boolean
    locked?: BoolWithAggregatesFilter<"User"> | boolean
    approved?: BoolWithAggregatesFilter<"User"> | boolean
    approvedBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"User"> | string | null
    department?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePhoto?: StringNullableWithAggregatesFilter<"User"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    isPredefined?: BoolFilter<"Group"> | boolean
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    members?: GroupMemberListRelationFilter
    permissions?: NamespacePermissionListRelationFilter
    modulePermissions?: ModulePermissionListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isPredefined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: GroupMemberOrderByRelationAggregateInput
    permissions?: NamespacePermissionOrderByRelationAggregateInput
    modulePermissions?: ModulePermissionOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    description?: StringNullableFilter<"Group"> | string | null
    isPredefined?: BoolFilter<"Group"> | boolean
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    members?: GroupMemberListRelationFilter
    permissions?: NamespacePermissionListRelationFilter
    modulePermissions?: ModulePermissionListRelationFilter
  }, "id" | "name">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isPredefined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Group"> | string
    name?: StringWithAggregatesFilter<"Group"> | string
    description?: StringNullableWithAggregatesFilter<"Group"> | string | null
    isPredefined?: BoolWithAggregatesFilter<"Group"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type GroupMemberWhereInput = {
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    id?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    createdAt?: DateTimeFilter<"GroupMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }

  export type GroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
  }

  export type GroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_groupId?: GroupMemberUserIdGroupIdCompoundUniqueInput
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    userId?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    createdAt?: DateTimeFilter<"GroupMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }, "id" | "userId_groupId">

  export type GroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    _count?: GroupMemberCountOrderByAggregateInput
    _max?: GroupMemberMaxOrderByAggregateInput
    _min?: GroupMemberMinOrderByAggregateInput
  }

  export type GroupMemberScalarWhereWithAggregatesInput = {
    AND?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    OR?: GroupMemberScalarWhereWithAggregatesInput[]
    NOT?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupMember"> | string
    userId?: StringWithAggregatesFilter<"GroupMember"> | string
    groupId?: StringWithAggregatesFilter<"GroupMember"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GroupMember"> | Date | string
  }

  export type NamespacePermissionWhereInput = {
    AND?: NamespacePermissionWhereInput | NamespacePermissionWhereInput[]
    OR?: NamespacePermissionWhereInput[]
    NOT?: NamespacePermissionWhereInput | NamespacePermissionWhereInput[]
    id?: StringFilter<"NamespacePermission"> | string
    namespaceId?: StringFilter<"NamespacePermission"> | string
    userId?: StringNullableFilter<"NamespacePermission"> | string | null
    groupId?: StringNullableFilter<"NamespacePermission"> | string | null
    canRead?: BoolFilter<"NamespacePermission"> | boolean
    canWrite?: BoolFilter<"NamespacePermission"> | boolean
    canExecute?: BoolFilter<"NamespacePermission"> | boolean
    canAdmin?: BoolFilter<"NamespacePermission"> | boolean
    createdAt?: DateTimeFilter<"NamespacePermission"> | Date | string
    namespace?: XOR<NamespaceScalarRelationFilter, NamespaceWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    group?: XOR<GroupNullableScalarRelationFilter, GroupWhereInput> | null
  }

  export type NamespacePermissionOrderByWithRelationInput = {
    id?: SortOrder
    namespaceId?: SortOrder
    userId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    canRead?: SortOrder
    canWrite?: SortOrder
    canExecute?: SortOrder
    canAdmin?: SortOrder
    createdAt?: SortOrder
    namespace?: NamespaceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
  }

  export type NamespacePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NamespacePermissionWhereInput | NamespacePermissionWhereInput[]
    OR?: NamespacePermissionWhereInput[]
    NOT?: NamespacePermissionWhereInput | NamespacePermissionWhereInput[]
    namespaceId?: StringFilter<"NamespacePermission"> | string
    userId?: StringNullableFilter<"NamespacePermission"> | string | null
    groupId?: StringNullableFilter<"NamespacePermission"> | string | null
    canRead?: BoolFilter<"NamespacePermission"> | boolean
    canWrite?: BoolFilter<"NamespacePermission"> | boolean
    canExecute?: BoolFilter<"NamespacePermission"> | boolean
    canAdmin?: BoolFilter<"NamespacePermission"> | boolean
    createdAt?: DateTimeFilter<"NamespacePermission"> | Date | string
    namespace?: XOR<NamespaceScalarRelationFilter, NamespaceWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    group?: XOR<GroupNullableScalarRelationFilter, GroupWhereInput> | null
  }, "id">

  export type NamespacePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    namespaceId?: SortOrder
    userId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    canRead?: SortOrder
    canWrite?: SortOrder
    canExecute?: SortOrder
    canAdmin?: SortOrder
    createdAt?: SortOrder
    _count?: NamespacePermissionCountOrderByAggregateInput
    _max?: NamespacePermissionMaxOrderByAggregateInput
    _min?: NamespacePermissionMinOrderByAggregateInput
  }

  export type NamespacePermissionScalarWhereWithAggregatesInput = {
    AND?: NamespacePermissionScalarWhereWithAggregatesInput | NamespacePermissionScalarWhereWithAggregatesInput[]
    OR?: NamespacePermissionScalarWhereWithAggregatesInput[]
    NOT?: NamespacePermissionScalarWhereWithAggregatesInput | NamespacePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NamespacePermission"> | string
    namespaceId?: StringWithAggregatesFilter<"NamespacePermission"> | string
    userId?: StringNullableWithAggregatesFilter<"NamespacePermission"> | string | null
    groupId?: StringNullableWithAggregatesFilter<"NamespacePermission"> | string | null
    canRead?: BoolWithAggregatesFilter<"NamespacePermission"> | boolean
    canWrite?: BoolWithAggregatesFilter<"NamespacePermission"> | boolean
    canExecute?: BoolWithAggregatesFilter<"NamespacePermission"> | boolean
    canAdmin?: BoolWithAggregatesFilter<"NamespacePermission"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NamespacePermission"> | Date | string
  }

  export type ModulePermissionWhereInput = {
    AND?: ModulePermissionWhereInput | ModulePermissionWhereInput[]
    OR?: ModulePermissionWhereInput[]
    NOT?: ModulePermissionWhereInput | ModulePermissionWhereInput[]
    id?: StringFilter<"ModulePermission"> | string
    groupId?: StringFilter<"ModulePermission"> | string
    module?: StringFilter<"ModulePermission"> | string
    canRead?: BoolFilter<"ModulePermission"> | boolean
    canWrite?: BoolFilter<"ModulePermission"> | boolean
    canDelete?: BoolFilter<"ModulePermission"> | boolean
    createdAt?: DateTimeFilter<"ModulePermission"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }

  export type ModulePermissionOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    module?: SortOrder
    canRead?: SortOrder
    canWrite?: SortOrder
    canDelete?: SortOrder
    createdAt?: SortOrder
    group?: GroupOrderByWithRelationInput
  }

  export type ModulePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_module?: ModulePermissionGroupIdModuleCompoundUniqueInput
    AND?: ModulePermissionWhereInput | ModulePermissionWhereInput[]
    OR?: ModulePermissionWhereInput[]
    NOT?: ModulePermissionWhereInput | ModulePermissionWhereInput[]
    groupId?: StringFilter<"ModulePermission"> | string
    module?: StringFilter<"ModulePermission"> | string
    canRead?: BoolFilter<"ModulePermission"> | boolean
    canWrite?: BoolFilter<"ModulePermission"> | boolean
    canDelete?: BoolFilter<"ModulePermission"> | boolean
    createdAt?: DateTimeFilter<"ModulePermission"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }, "id" | "groupId_module">

  export type ModulePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    module?: SortOrder
    canRead?: SortOrder
    canWrite?: SortOrder
    canDelete?: SortOrder
    createdAt?: SortOrder
    _count?: ModulePermissionCountOrderByAggregateInput
    _max?: ModulePermissionMaxOrderByAggregateInput
    _min?: ModulePermissionMinOrderByAggregateInput
  }

  export type ModulePermissionScalarWhereWithAggregatesInput = {
    AND?: ModulePermissionScalarWhereWithAggregatesInput | ModulePermissionScalarWhereWithAggregatesInput[]
    OR?: ModulePermissionScalarWhereWithAggregatesInput[]
    NOT?: ModulePermissionScalarWhereWithAggregatesInput | ModulePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModulePermission"> | string
    groupId?: StringWithAggregatesFilter<"ModulePermission"> | string
    module?: StringWithAggregatesFilter<"ModulePermission"> | string
    canRead?: BoolWithAggregatesFilter<"ModulePermission"> | boolean
    canWrite?: BoolWithAggregatesFilter<"ModulePermission"> | boolean
    canDelete?: BoolWithAggregatesFilter<"ModulePermission"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ModulePermission"> | Date | string
  }

  export type CredentialWhereInput = {
    AND?: CredentialWhereInput | CredentialWhereInput[]
    OR?: CredentialWhereInput[]
    NOT?: CredentialWhereInput | CredentialWhereInput[]
    id?: StringFilter<"Credential"> | string
    name?: StringFilter<"Credential"> | string
    description?: StringNullableFilter<"Credential"> | string | null
    credentialType?: StringFilter<"Credential"> | string
    username?: StringNullableFilter<"Credential"> | string | null
    password?: StringNullableFilter<"Credential"> | string | null
    sshPrivateKey?: StringNullableFilter<"Credential"> | string | null
    vaultPassword?: StringNullableFilter<"Credential"> | string | null
    createdBy?: StringFilter<"Credential"> | string
    createdAt?: DateTimeFilter<"Credential"> | Date | string
    updatedAt?: DateTimeFilter<"Credential"> | Date | string
  }

  export type CredentialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    credentialType?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    sshPrivateKey?: SortOrderInput | SortOrder
    vaultPassword?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CredentialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CredentialWhereInput | CredentialWhereInput[]
    OR?: CredentialWhereInput[]
    NOT?: CredentialWhereInput | CredentialWhereInput[]
    description?: StringNullableFilter<"Credential"> | string | null
    credentialType?: StringFilter<"Credential"> | string
    username?: StringNullableFilter<"Credential"> | string | null
    password?: StringNullableFilter<"Credential"> | string | null
    sshPrivateKey?: StringNullableFilter<"Credential"> | string | null
    vaultPassword?: StringNullableFilter<"Credential"> | string | null
    createdBy?: StringFilter<"Credential"> | string
    createdAt?: DateTimeFilter<"Credential"> | Date | string
    updatedAt?: DateTimeFilter<"Credential"> | Date | string
  }, "id" | "name">

  export type CredentialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    credentialType?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    sshPrivateKey?: SortOrderInput | SortOrder
    vaultPassword?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CredentialCountOrderByAggregateInput
    _max?: CredentialMaxOrderByAggregateInput
    _min?: CredentialMinOrderByAggregateInput
  }

  export type CredentialScalarWhereWithAggregatesInput = {
    AND?: CredentialScalarWhereWithAggregatesInput | CredentialScalarWhereWithAggregatesInput[]
    OR?: CredentialScalarWhereWithAggregatesInput[]
    NOT?: CredentialScalarWhereWithAggregatesInput | CredentialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Credential"> | string
    name?: StringWithAggregatesFilter<"Credential"> | string
    description?: StringNullableWithAggregatesFilter<"Credential"> | string | null
    credentialType?: StringWithAggregatesFilter<"Credential"> | string
    username?: StringNullableWithAggregatesFilter<"Credential"> | string | null
    password?: StringNullableWithAggregatesFilter<"Credential"> | string | null
    sshPrivateKey?: StringNullableWithAggregatesFilter<"Credential"> | string | null
    vaultPassword?: StringNullableWithAggregatesFilter<"Credential"> | string | null
    createdBy?: StringWithAggregatesFilter<"Credential"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Credential"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Credential"> | Date | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: StringFilter<"Setting"> | string
    key?: StringFilter<"Setting"> | string
    value?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    value?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }, "id" | "key">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Setting"> | string
    key?: StringWithAggregatesFilter<"Setting"> | string
    value?: StringWithAggregatesFilter<"Setting"> | string
    description?: StringNullableWithAggregatesFilter<"Setting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    action?: StringFilter<"Activity"> | string
    entityType?: StringFilter<"Activity"> | string
    entityId?: StringFilter<"Activity"> | string
    entityName?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    performedBy?: StringFilter<"Activity"> | string
    metadata?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    entityName?: SortOrder
    description?: SortOrderInput | SortOrder
    performedBy?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    action?: StringFilter<"Activity"> | string
    entityType?: StringFilter<"Activity"> | string
    entityId?: StringFilter<"Activity"> | string
    entityName?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    performedBy?: StringFilter<"Activity"> | string
    metadata?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    entityName?: SortOrder
    description?: SortOrderInput | SortOrder
    performedBy?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    action?: StringWithAggregatesFilter<"Activity"> | string
    entityType?: StringWithAggregatesFilter<"Activity"> | string
    entityId?: StringWithAggregatesFilter<"Activity"> | string
    entityName?: StringWithAggregatesFilter<"Activity"> | string
    description?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    performedBy?: StringWithAggregatesFilter<"Activity"> | string
    metadata?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type RunCounterWhereInput = {
    AND?: RunCounterWhereInput | RunCounterWhereInput[]
    OR?: RunCounterWhereInput[]
    NOT?: RunCounterWhereInput | RunCounterWhereInput[]
    id?: StringFilter<"RunCounter"> | string
    year?: IntFilter<"RunCounter"> | number
    pool?: StringFilter<"RunCounter"> | string
    sequence?: IntFilter<"RunCounter"> | number
    lastUsed?: DateTimeFilter<"RunCounter"> | Date | string
  }

  export type RunCounterOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    pool?: SortOrder
    sequence?: SortOrder
    lastUsed?: SortOrder
  }

  export type RunCounterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    year_pool?: RunCounterYearPoolCompoundUniqueInput
    AND?: RunCounterWhereInput | RunCounterWhereInput[]
    OR?: RunCounterWhereInput[]
    NOT?: RunCounterWhereInput | RunCounterWhereInput[]
    year?: IntFilter<"RunCounter"> | number
    pool?: StringFilter<"RunCounter"> | string
    sequence?: IntFilter<"RunCounter"> | number
    lastUsed?: DateTimeFilter<"RunCounter"> | Date | string
  }, "id" | "year_pool">

  export type RunCounterOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    pool?: SortOrder
    sequence?: SortOrder
    lastUsed?: SortOrder
    _count?: RunCounterCountOrderByAggregateInput
    _avg?: RunCounterAvgOrderByAggregateInput
    _max?: RunCounterMaxOrderByAggregateInput
    _min?: RunCounterMinOrderByAggregateInput
    _sum?: RunCounterSumOrderByAggregateInput
  }

  export type RunCounterScalarWhereWithAggregatesInput = {
    AND?: RunCounterScalarWhereWithAggregatesInput | RunCounterScalarWhereWithAggregatesInput[]
    OR?: RunCounterScalarWhereWithAggregatesInput[]
    NOT?: RunCounterScalarWhereWithAggregatesInput | RunCounterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RunCounter"> | string
    year?: IntWithAggregatesFilter<"RunCounter"> | number
    pool?: StringWithAggregatesFilter<"RunCounter"> | string
    sequence?: IntWithAggregatesFilter<"RunCounter"> | number
    lastUsed?: DateTimeWithAggregatesFilter<"RunCounter"> | Date | string
  }

  export type InstanceGroupWhereInput = {
    AND?: InstanceGroupWhereInput | InstanceGroupWhereInput[]
    OR?: InstanceGroupWhereInput[]
    NOT?: InstanceGroupWhereInput | InstanceGroupWhereInput[]
    id?: StringFilter<"InstanceGroup"> | string
    name?: StringFilter<"InstanceGroup"> | string
    awxId?: StringNullableFilter<"InstanceGroup"> | string | null
    description?: StringNullableFilter<"InstanceGroup"> | string | null
    enabled?: BoolFilter<"InstanceGroup"> | boolean
    createdBy?: StringFilter<"InstanceGroup"> | string
    createdAt?: DateTimeFilter<"InstanceGroup"> | Date | string
    updatedAt?: DateTimeFilter<"InstanceGroup"> | Date | string
  }

  export type InstanceGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    awxId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    enabled?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstanceGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: InstanceGroupWhereInput | InstanceGroupWhereInput[]
    OR?: InstanceGroupWhereInput[]
    NOT?: InstanceGroupWhereInput | InstanceGroupWhereInput[]
    awxId?: StringNullableFilter<"InstanceGroup"> | string | null
    description?: StringNullableFilter<"InstanceGroup"> | string | null
    enabled?: BoolFilter<"InstanceGroup"> | boolean
    createdBy?: StringFilter<"InstanceGroup"> | string
    createdAt?: DateTimeFilter<"InstanceGroup"> | Date | string
    updatedAt?: DateTimeFilter<"InstanceGroup"> | Date | string
  }, "id" | "name">

  export type InstanceGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    awxId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    enabled?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstanceGroupCountOrderByAggregateInput
    _max?: InstanceGroupMaxOrderByAggregateInput
    _min?: InstanceGroupMinOrderByAggregateInput
  }

  export type InstanceGroupScalarWhereWithAggregatesInput = {
    AND?: InstanceGroupScalarWhereWithAggregatesInput | InstanceGroupScalarWhereWithAggregatesInput[]
    OR?: InstanceGroupScalarWhereWithAggregatesInput[]
    NOT?: InstanceGroupScalarWhereWithAggregatesInput | InstanceGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InstanceGroup"> | string
    name?: StringWithAggregatesFilter<"InstanceGroup"> | string
    awxId?: StringNullableWithAggregatesFilter<"InstanceGroup"> | string | null
    description?: StringNullableWithAggregatesFilter<"InstanceGroup"> | string | null
    enabled?: BoolWithAggregatesFilter<"InstanceGroup"> | boolean
    createdBy?: StringWithAggregatesFilter<"InstanceGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InstanceGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InstanceGroup"> | Date | string
  }

  export type AwxEnvironmentWhereInput = {
    AND?: AwxEnvironmentWhereInput | AwxEnvironmentWhereInput[]
    OR?: AwxEnvironmentWhereInput[]
    NOT?: AwxEnvironmentWhereInput | AwxEnvironmentWhereInput[]
    id?: StringFilter<"AwxEnvironment"> | string
    name?: StringFilter<"AwxEnvironment"> | string
    baseUrl?: StringFilter<"AwxEnvironment"> | string
    token?: StringNullableFilter<"AwxEnvironment"> | string | null
    description?: StringNullableFilter<"AwxEnvironment"> | string | null
    createdAt?: DateTimeFilter<"AwxEnvironment"> | Date | string
    updatedAt?: DateTimeFilter<"AwxEnvironment"> | Date | string
    catalogs?: CatalogListRelationFilter
  }

  export type AwxEnvironmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    baseUrl?: SortOrder
    token?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    catalogs?: CatalogOrderByRelationAggregateInput
  }

  export type AwxEnvironmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AwxEnvironmentWhereInput | AwxEnvironmentWhereInput[]
    OR?: AwxEnvironmentWhereInput[]
    NOT?: AwxEnvironmentWhereInput | AwxEnvironmentWhereInput[]
    baseUrl?: StringFilter<"AwxEnvironment"> | string
    token?: StringNullableFilter<"AwxEnvironment"> | string | null
    description?: StringNullableFilter<"AwxEnvironment"> | string | null
    createdAt?: DateTimeFilter<"AwxEnvironment"> | Date | string
    updatedAt?: DateTimeFilter<"AwxEnvironment"> | Date | string
    catalogs?: CatalogListRelationFilter
  }, "id" | "name">

  export type AwxEnvironmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    baseUrl?: SortOrder
    token?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AwxEnvironmentCountOrderByAggregateInput
    _max?: AwxEnvironmentMaxOrderByAggregateInput
    _min?: AwxEnvironmentMinOrderByAggregateInput
  }

  export type AwxEnvironmentScalarWhereWithAggregatesInput = {
    AND?: AwxEnvironmentScalarWhereWithAggregatesInput | AwxEnvironmentScalarWhereWithAggregatesInput[]
    OR?: AwxEnvironmentScalarWhereWithAggregatesInput[]
    NOT?: AwxEnvironmentScalarWhereWithAggregatesInput | AwxEnvironmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AwxEnvironment"> | string
    name?: StringWithAggregatesFilter<"AwxEnvironment"> | string
    baseUrl?: StringWithAggregatesFilter<"AwxEnvironment"> | string
    token?: StringNullableWithAggregatesFilter<"AwxEnvironment"> | string | null
    description?: StringNullableWithAggregatesFilter<"AwxEnvironment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AwxEnvironment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AwxEnvironment"> | Date | string
  }

  export type CatalogWhereInput = {
    AND?: CatalogWhereInput | CatalogWhereInput[]
    OR?: CatalogWhereInput[]
    NOT?: CatalogWhereInput | CatalogWhereInput[]
    id?: StringFilter<"Catalog"> | string
    name?: StringFilter<"Catalog"> | string
    description?: StringNullableFilter<"Catalog"> | string | null
    tags?: StringNullableFilter<"Catalog"> | string | null
    namespaceId?: StringFilter<"Catalog"> | string
    environmentId?: StringFilter<"Catalog"> | string
    templateId?: StringFilter<"Catalog"> | string
    customBody?: StringNullableFilter<"Catalog"> | string | null
    formSchema?: StringNullableFilter<"Catalog"> | string | null
    isLocked?: BoolFilter<"Catalog"> | boolean
    createdBy?: StringFilter<"Catalog"> | string
    createdAt?: DateTimeFilter<"Catalog"> | Date | string
    updatedAt?: DateTimeFilter<"Catalog"> | Date | string
    environment?: XOR<AwxEnvironmentScalarRelationFilter, AwxEnvironmentWhereInput>
    executions?: CatalogExecutionListRelationFilter
  }

  export type CatalogOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    namespaceId?: SortOrder
    environmentId?: SortOrder
    templateId?: SortOrder
    customBody?: SortOrderInput | SortOrder
    formSchema?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    environment?: AwxEnvironmentOrderByWithRelationInput
    executions?: CatalogExecutionOrderByRelationAggregateInput
  }

  export type CatalogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CatalogWhereInput | CatalogWhereInput[]
    OR?: CatalogWhereInput[]
    NOT?: CatalogWhereInput | CatalogWhereInput[]
    description?: StringNullableFilter<"Catalog"> | string | null
    tags?: StringNullableFilter<"Catalog"> | string | null
    namespaceId?: StringFilter<"Catalog"> | string
    environmentId?: StringFilter<"Catalog"> | string
    templateId?: StringFilter<"Catalog"> | string
    customBody?: StringNullableFilter<"Catalog"> | string | null
    formSchema?: StringNullableFilter<"Catalog"> | string | null
    isLocked?: BoolFilter<"Catalog"> | boolean
    createdBy?: StringFilter<"Catalog"> | string
    createdAt?: DateTimeFilter<"Catalog"> | Date | string
    updatedAt?: DateTimeFilter<"Catalog"> | Date | string
    environment?: XOR<AwxEnvironmentScalarRelationFilter, AwxEnvironmentWhereInput>
    executions?: CatalogExecutionListRelationFilter
  }, "id" | "name">

  export type CatalogOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    namespaceId?: SortOrder
    environmentId?: SortOrder
    templateId?: SortOrder
    customBody?: SortOrderInput | SortOrder
    formSchema?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CatalogCountOrderByAggregateInput
    _max?: CatalogMaxOrderByAggregateInput
    _min?: CatalogMinOrderByAggregateInput
  }

  export type CatalogScalarWhereWithAggregatesInput = {
    AND?: CatalogScalarWhereWithAggregatesInput | CatalogScalarWhereWithAggregatesInput[]
    OR?: CatalogScalarWhereWithAggregatesInput[]
    NOT?: CatalogScalarWhereWithAggregatesInput | CatalogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Catalog"> | string
    name?: StringWithAggregatesFilter<"Catalog"> | string
    description?: StringNullableWithAggregatesFilter<"Catalog"> | string | null
    tags?: StringNullableWithAggregatesFilter<"Catalog"> | string | null
    namespaceId?: StringWithAggregatesFilter<"Catalog"> | string
    environmentId?: StringWithAggregatesFilter<"Catalog"> | string
    templateId?: StringWithAggregatesFilter<"Catalog"> | string
    customBody?: StringNullableWithAggregatesFilter<"Catalog"> | string | null
    formSchema?: StringNullableWithAggregatesFilter<"Catalog"> | string | null
    isLocked?: BoolWithAggregatesFilter<"Catalog"> | boolean
    createdBy?: StringWithAggregatesFilter<"Catalog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Catalog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Catalog"> | Date | string
  }

  export type CatalogExecutionWhereInput = {
    AND?: CatalogExecutionWhereInput | CatalogExecutionWhereInput[]
    OR?: CatalogExecutionWhereInput[]
    NOT?: CatalogExecutionWhereInput | CatalogExecutionWhereInput[]
    id?: StringFilter<"CatalogExecution"> | string
    catalogId?: StringFilter<"CatalogExecution"> | string
    status?: StringFilter<"CatalogExecution"> | string
    parameters?: StringNullableFilter<"CatalogExecution"> | string | null
    consoleOutput?: StringNullableFilter<"CatalogExecution"> | string | null
    artifacts?: StringNullableFilter<"CatalogExecution"> | string | null
    errorMessage?: StringNullableFilter<"CatalogExecution"> | string | null
    awxJobId?: StringNullableFilter<"CatalogExecution"> | string | null
    executedBy?: StringFilter<"CatalogExecution"> | string
    startedAt?: DateTimeFilter<"CatalogExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"CatalogExecution"> | Date | string | null
    catalog?: XOR<CatalogScalarRelationFilter, CatalogWhereInput>
  }

  export type CatalogExecutionOrderByWithRelationInput = {
    id?: SortOrder
    catalogId?: SortOrder
    status?: SortOrder
    parameters?: SortOrderInput | SortOrder
    consoleOutput?: SortOrderInput | SortOrder
    artifacts?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    awxJobId?: SortOrderInput | SortOrder
    executedBy?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    catalog?: CatalogOrderByWithRelationInput
  }

  export type CatalogExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatalogExecutionWhereInput | CatalogExecutionWhereInput[]
    OR?: CatalogExecutionWhereInput[]
    NOT?: CatalogExecutionWhereInput | CatalogExecutionWhereInput[]
    catalogId?: StringFilter<"CatalogExecution"> | string
    status?: StringFilter<"CatalogExecution"> | string
    parameters?: StringNullableFilter<"CatalogExecution"> | string | null
    consoleOutput?: StringNullableFilter<"CatalogExecution"> | string | null
    artifacts?: StringNullableFilter<"CatalogExecution"> | string | null
    errorMessage?: StringNullableFilter<"CatalogExecution"> | string | null
    awxJobId?: StringNullableFilter<"CatalogExecution"> | string | null
    executedBy?: StringFilter<"CatalogExecution"> | string
    startedAt?: DateTimeFilter<"CatalogExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"CatalogExecution"> | Date | string | null
    catalog?: XOR<CatalogScalarRelationFilter, CatalogWhereInput>
  }, "id">

  export type CatalogExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    catalogId?: SortOrder
    status?: SortOrder
    parameters?: SortOrderInput | SortOrder
    consoleOutput?: SortOrderInput | SortOrder
    artifacts?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    awxJobId?: SortOrderInput | SortOrder
    executedBy?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: CatalogExecutionCountOrderByAggregateInput
    _max?: CatalogExecutionMaxOrderByAggregateInput
    _min?: CatalogExecutionMinOrderByAggregateInput
  }

  export type CatalogExecutionScalarWhereWithAggregatesInput = {
    AND?: CatalogExecutionScalarWhereWithAggregatesInput | CatalogExecutionScalarWhereWithAggregatesInput[]
    OR?: CatalogExecutionScalarWhereWithAggregatesInput[]
    NOT?: CatalogExecutionScalarWhereWithAggregatesInput | CatalogExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogExecution"> | string
    catalogId?: StringWithAggregatesFilter<"CatalogExecution"> | string
    status?: StringWithAggregatesFilter<"CatalogExecution"> | string
    parameters?: StringNullableWithAggregatesFilter<"CatalogExecution"> | string | null
    consoleOutput?: StringNullableWithAggregatesFilter<"CatalogExecution"> | string | null
    artifacts?: StringNullableWithAggregatesFilter<"CatalogExecution"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"CatalogExecution"> | string | null
    awxJobId?: StringNullableWithAggregatesFilter<"CatalogExecution"> | string | null
    executedBy?: StringWithAggregatesFilter<"CatalogExecution"> | string
    startedAt?: DateTimeWithAggregatesFilter<"CatalogExecution"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"CatalogExecution"> | Date | string | null
  }

  export type AutomationCreateInput = {
    id?: string
    name: string
    namespace: string
    description?: string | null
    keywords?: string | null
    tags?: string | null
    formSchema: string
    apiEndpoint?: string | null
    templateId: string
    inventoryId?: string | null
    instanceGroupId?: string | null
    extraVars?: string | null
    customBody?: string | null
    pinned?: boolean
    featured?: boolean
    runs?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    runs_history?: RunCreateNestedManyWithoutAutomationInput
    schedules?: ScheduleCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateInput = {
    id?: string
    name: string
    namespace: string
    description?: string | null
    keywords?: string | null
    tags?: string | null
    formSchema: string
    apiEndpoint?: string | null
    templateId: string
    inventoryId?: string | null
    instanceGroupId?: string | null
    extraVars?: string | null
    customBody?: string | null
    pinned?: boolean
    featured?: boolean
    runs?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    runs_history?: RunUncheckedCreateNestedManyWithoutAutomationInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: StringFieldUpdateOperationsInput | string
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    instanceGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    extraVars?: NullableStringFieldUpdateOperationsInput | string | null
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    runs?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runs_history?: RunUpdateManyWithoutAutomationNestedInput
    schedules?: ScheduleUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: StringFieldUpdateOperationsInput | string
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    instanceGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    extraVars?: NullableStringFieldUpdateOperationsInput | string | null
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    runs?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runs_history?: RunUncheckedUpdateManyWithoutAutomationNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationCreateManyInput = {
    id?: string
    name: string
    namespace: string
    description?: string | null
    keywords?: string | null
    tags?: string | null
    formSchema: string
    apiEndpoint?: string | null
    templateId: string
    inventoryId?: string | null
    instanceGroupId?: string | null
    extraVars?: string | null
    customBody?: string | null
    pinned?: boolean
    featured?: boolean
    runs?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: StringFieldUpdateOperationsInput | string
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    instanceGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    extraVars?: NullableStringFieldUpdateOperationsInput | string | null
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    runs?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: StringFieldUpdateOperationsInput | string
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    instanceGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    extraVars?: NullableStringFieldUpdateOperationsInput | string | null
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    runs?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCreateInput = {
    id?: string
    status: string
    uniqueId?: string | null
    parameters?: string | null
    result?: string | null
    artifacts?: string | null
    errorMessage?: string | null
    executedBy?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    awxJobId?: string | null
    automation: AutomationCreateNestedOneWithoutRuns_historyInput
  }

  export type RunUncheckedCreateInput = {
    id?: string
    automationId: string
    status: string
    uniqueId?: string | null
    parameters?: string | null
    result?: string | null
    artifacts?: string | null
    errorMessage?: string | null
    executedBy?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    awxJobId?: string | null
  }

  export type RunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    uniqueId?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    awxJobId?: NullableStringFieldUpdateOperationsInput | string | null
    automation?: AutomationUpdateOneRequiredWithoutRuns_historyNestedInput
  }

  export type RunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    uniqueId?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    awxJobId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RunCreateManyInput = {
    id?: string
    automationId: string
    status: string
    uniqueId?: string | null
    parameters?: string | null
    result?: string | null
    artifacts?: string | null
    errorMessage?: string | null
    executedBy?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    awxJobId?: string | null
  }

  export type RunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    uniqueId?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    awxJobId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    uniqueId?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    awxJobId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleCreateInput = {
    id?: string
    name: string
    frequency: string
    cron: string
    parameters?: string | null
    status?: string
    nextRun?: Date | string | null
    lastRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    automation: AutomationCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: string
    name: string
    automationId: string
    frequency: string
    cron: string
    parameters?: string | null
    status?: string
    nextRun?: Date | string | null
    lastRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    cron?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    automation?: AutomationUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    cron?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateManyInput = {
    id?: string
    name: string
    automationId: string
    frequency: string
    cron: string
    parameters?: string | null
    status?: string
    nextRun?: Date | string | null
    lastRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    cron?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    cron?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectivityCheckCreateInput = {
    id?: string
    servers: string
    ports: string
    email: string
    status?: string
    results?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ConnectivityCheckUncheckedCreateInput = {
    id?: string
    servers: string
    ports: string
    email: string
    status?: string
    results?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ConnectivityCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    servers?: StringFieldUpdateOperationsInput | string
    ports?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    results?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConnectivityCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    servers?: StringFieldUpdateOperationsInput | string
    ports?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    results?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConnectivityCheckCreateManyInput = {
    id?: string
    servers: string
    ports: string
    email: string
    status?: string
    results?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ConnectivityCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    servers?: StringFieldUpdateOperationsInput | string
    ports?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    results?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConnectivityCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    servers?: StringFieldUpdateOperationsInput | string
    ports?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    results?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NamespaceCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    color?: string
    icon?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NamespacePermissionCreateNestedManyWithoutNamespaceInput
  }

  export type NamespaceUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    color?: string
    icon?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NamespacePermissionUncheckedCreateNestedManyWithoutNamespaceInput
  }

  export type NamespaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NamespacePermissionUpdateManyWithoutNamespaceNestedInput
  }

  export type NamespaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NamespacePermissionUncheckedUpdateManyWithoutNamespaceNestedInput
  }

  export type NamespaceCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    color?: string
    icon?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NamespaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NamespaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    firstName: string
    lastName: string
    name: string
    samAccountName?: string | null
    email: string
    password?: string
    role?: string
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    location?: string | null
    department?: string | null
    profilePhoto?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    permissions?: NamespacePermissionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    name: string
    samAccountName?: string | null
    email: string
    password?: string
    role?: string
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    location?: string | null
    department?: string | null
    profilePhoto?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    permissions?: NamespacePermissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    samAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    permissions?: NamespacePermissionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    samAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    permissions?: NamespacePermissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    name: string
    samAccountName?: string | null
    email: string
    password?: string
    role?: string
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    location?: string | null
    department?: string | null
    profilePhoto?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    samAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    samAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateInput = {
    id?: string
    name: string
    description?: string | null
    isPredefined?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    permissions?: NamespacePermissionCreateNestedManyWithoutGroupInput
    modulePermissions?: ModulePermissionCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isPredefined?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    permissions?: NamespacePermissionUncheckedCreateNestedManyWithoutGroupInput
    modulePermissions?: ModulePermissionUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPredefined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    permissions?: NamespacePermissionUpdateManyWithoutGroupNestedInput
    modulePermissions?: ModulePermissionUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPredefined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    permissions?: NamespacePermissionUncheckedUpdateManyWithoutGroupNestedInput
    modulePermissions?: ModulePermissionUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isPredefined?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPredefined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPredefined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutGroupMembershipsInput
    group: GroupCreateNestedOneWithoutMembersInput
  }

  export type GroupMemberUncheckedCreateInput = {
    id?: string
    userId: string
    groupId: string
    createdAt?: Date | string
  }

  export type GroupMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type GroupMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyInput = {
    id?: string
    userId: string
    groupId: string
    createdAt?: Date | string
  }

  export type GroupMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NamespacePermissionCreateInput = {
    id?: string
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: Date | string
    namespace: NamespaceCreateNestedOneWithoutPermissionsInput
    user?: UserCreateNestedOneWithoutPermissionsInput
    group?: GroupCreateNestedOneWithoutPermissionsInput
  }

  export type NamespacePermissionUncheckedCreateInput = {
    id?: string
    namespaceId: string
    userId?: string | null
    groupId?: string | null
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: Date | string
  }

  export type NamespacePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    namespace?: NamespaceUpdateOneRequiredWithoutPermissionsNestedInput
    user?: UserUpdateOneWithoutPermissionsNestedInput
    group?: GroupUpdateOneWithoutPermissionsNestedInput
  }

  export type NamespacePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    namespaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NamespacePermissionCreateManyInput = {
    id?: string
    namespaceId: string
    userId?: string | null
    groupId?: string | null
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: Date | string
  }

  export type NamespacePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NamespacePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    namespaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModulePermissionCreateInput = {
    id?: string
    module: string
    canRead?: boolean
    canWrite?: boolean
    canDelete?: boolean
    createdAt?: Date | string
    group: GroupCreateNestedOneWithoutModulePermissionsInput
  }

  export type ModulePermissionUncheckedCreateInput = {
    id?: string
    groupId: string
    module: string
    canRead?: boolean
    canWrite?: boolean
    canDelete?: boolean
    createdAt?: Date | string
  }

  export type ModulePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutModulePermissionsNestedInput
  }

  export type ModulePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModulePermissionCreateManyInput = {
    id?: string
    groupId: string
    module: string
    canRead?: boolean
    canWrite?: boolean
    canDelete?: boolean
    createdAt?: Date | string
  }

  export type ModulePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModulePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialCreateInput = {
    id?: string
    name: string
    description?: string | null
    credentialType: string
    username?: string | null
    password?: string | null
    sshPrivateKey?: string | null
    vaultPassword?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CredentialUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    credentialType: string
    username?: string | null
    password?: string | null
    sshPrivateKey?: string | null
    vaultPassword?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credentialType?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    sshPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    vaultPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credentialType?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    sshPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    vaultPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    credentialType: string
    username?: string | null
    password?: string | null
    sshPrivateKey?: string | null
    vaultPassword?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credentialType?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    sshPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    vaultPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credentialType?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    sshPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    vaultPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateManyInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    entityName: string
    description?: string | null
    performedBy: string
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    entityName: string
    description?: string | null
    performedBy: string
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    entityName: string
    description?: string | null
    performedBy: string
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCounterCreateInput = {
    id?: string
    year: number
    pool: string
    sequence?: number
    lastUsed?: Date | string
  }

  export type RunCounterUncheckedCreateInput = {
    id?: string
    year: number
    pool: string
    sequence?: number
    lastUsed?: Date | string
  }

  export type RunCounterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    pool?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCounterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    pool?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCounterCreateManyInput = {
    id?: string
    year: number
    pool: string
    sequence?: number
    lastUsed?: Date | string
  }

  export type RunCounterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    pool?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCounterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    pool?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstanceGroupCreateInput = {
    id?: string
    name: string
    awxId?: string | null
    description?: string | null
    enabled?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstanceGroupUncheckedCreateInput = {
    id?: string
    name: string
    awxId?: string | null
    description?: string | null
    enabled?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstanceGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    awxId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstanceGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    awxId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstanceGroupCreateManyInput = {
    id?: string
    name: string
    awxId?: string | null
    description?: string | null
    enabled?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstanceGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    awxId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstanceGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    awxId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AwxEnvironmentCreateInput = {
    id?: string
    name: string
    baseUrl: string
    token?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    catalogs?: CatalogCreateNestedManyWithoutEnvironmentInput
  }

  export type AwxEnvironmentUncheckedCreateInput = {
    id?: string
    name: string
    baseUrl: string
    token?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    catalogs?: CatalogUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type AwxEnvironmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    catalogs?: CatalogUpdateManyWithoutEnvironmentNestedInput
  }

  export type AwxEnvironmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    catalogs?: CatalogUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type AwxEnvironmentCreateManyInput = {
    id?: string
    name: string
    baseUrl: string
    token?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AwxEnvironmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AwxEnvironmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCreateInput = {
    id?: string
    name: string
    description?: string | null
    tags?: string | null
    namespaceId: string
    templateId: string
    customBody?: string | null
    formSchema?: string | null
    isLocked?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    environment: AwxEnvironmentCreateNestedOneWithoutCatalogsInput
    executions?: CatalogExecutionCreateNestedManyWithoutCatalogInput
  }

  export type CatalogUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    tags?: string | null
    namespaceId: string
    environmentId: string
    templateId: string
    customBody?: string | null
    formSchema?: string | null
    isLocked?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: CatalogExecutionUncheckedCreateNestedManyWithoutCatalogInput
  }

  export type CatalogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    namespaceId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: AwxEnvironmentUpdateOneRequiredWithoutCatalogsNestedInput
    executions?: CatalogExecutionUpdateManyWithoutCatalogNestedInput
  }

  export type CatalogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    namespaceId?: StringFieldUpdateOperationsInput | string
    environmentId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: CatalogExecutionUncheckedUpdateManyWithoutCatalogNestedInput
  }

  export type CatalogCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    tags?: string | null
    namespaceId: string
    environmentId: string
    templateId: string
    customBody?: string | null
    formSchema?: string | null
    isLocked?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    namespaceId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    namespaceId?: StringFieldUpdateOperationsInput | string
    environmentId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogExecutionCreateInput = {
    id?: string
    status: string
    parameters?: string | null
    consoleOutput?: string | null
    artifacts?: string | null
    errorMessage?: string | null
    awxJobId?: string | null
    executedBy: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    catalog: CatalogCreateNestedOneWithoutExecutionsInput
  }

  export type CatalogExecutionUncheckedCreateInput = {
    id?: string
    catalogId: string
    status: string
    parameters?: string | null
    consoleOutput?: string | null
    artifacts?: string | null
    errorMessage?: string | null
    awxJobId?: string | null
    executedBy: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CatalogExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    consoleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    awxJobId?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalog?: CatalogUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type CatalogExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    catalogId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    consoleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    awxJobId?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CatalogExecutionCreateManyInput = {
    id?: string
    catalogId: string
    status: string
    parameters?: string | null
    consoleOutput?: string | null
    artifacts?: string | null
    errorMessage?: string | null
    awxJobId?: string | null
    executedBy: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CatalogExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    consoleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    awxJobId?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CatalogExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    catalogId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    consoleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    awxJobId?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RunListRelationFilter = {
    every?: RunWhereInput
    some?: RunWhereInput
    none?: RunWhereInput
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    namespace?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    tags?: SortOrder
    formSchema?: SortOrder
    apiEndpoint?: SortOrder
    templateId?: SortOrder
    inventoryId?: SortOrder
    instanceGroupId?: SortOrder
    extraVars?: SortOrder
    customBody?: SortOrder
    pinned?: SortOrder
    featured?: SortOrder
    runs?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationAvgOrderByAggregateInput = {
    runs?: SortOrder
  }

  export type AutomationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    namespace?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    tags?: SortOrder
    formSchema?: SortOrder
    apiEndpoint?: SortOrder
    templateId?: SortOrder
    inventoryId?: SortOrder
    instanceGroupId?: SortOrder
    extraVars?: SortOrder
    customBody?: SortOrder
    pinned?: SortOrder
    featured?: SortOrder
    runs?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    namespace?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    tags?: SortOrder
    formSchema?: SortOrder
    apiEndpoint?: SortOrder
    templateId?: SortOrder
    inventoryId?: SortOrder
    instanceGroupId?: SortOrder
    extraVars?: SortOrder
    customBody?: SortOrder
    pinned?: SortOrder
    featured?: SortOrder
    runs?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationSumOrderByAggregateInput = {
    runs?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AutomationScalarRelationFilter = {
    is?: AutomationWhereInput
    isNot?: AutomationWhereInput
  }

  export type RunCountOrderByAggregateInput = {
    id?: SortOrder
    automationId?: SortOrder
    status?: SortOrder
    uniqueId?: SortOrder
    parameters?: SortOrder
    result?: SortOrder
    artifacts?: SortOrder
    errorMessage?: SortOrder
    executedBy?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    awxJobId?: SortOrder
  }

  export type RunMaxOrderByAggregateInput = {
    id?: SortOrder
    automationId?: SortOrder
    status?: SortOrder
    uniqueId?: SortOrder
    parameters?: SortOrder
    result?: SortOrder
    artifacts?: SortOrder
    errorMessage?: SortOrder
    executedBy?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    awxJobId?: SortOrder
  }

  export type RunMinOrderByAggregateInput = {
    id?: SortOrder
    automationId?: SortOrder
    status?: SortOrder
    uniqueId?: SortOrder
    parameters?: SortOrder
    result?: SortOrder
    artifacts?: SortOrder
    errorMessage?: SortOrder
    executedBy?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    awxJobId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    automationId?: SortOrder
    frequency?: SortOrder
    cron?: SortOrder
    parameters?: SortOrder
    status?: SortOrder
    nextRun?: SortOrder
    lastRun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    automationId?: SortOrder
    frequency?: SortOrder
    cron?: SortOrder
    parameters?: SortOrder
    status?: SortOrder
    nextRun?: SortOrder
    lastRun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    automationId?: SortOrder
    frequency?: SortOrder
    cron?: SortOrder
    parameters?: SortOrder
    status?: SortOrder
    nextRun?: SortOrder
    lastRun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type ConnectivityCheckCountOrderByAggregateInput = {
    id?: SortOrder
    servers?: SortOrder
    ports?: SortOrder
    email?: SortOrder
    status?: SortOrder
    results?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ConnectivityCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    servers?: SortOrder
    ports?: SortOrder
    email?: SortOrder
    status?: SortOrder
    results?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ConnectivityCheckMinOrderByAggregateInput = {
    id?: SortOrder
    servers?: SortOrder
    ports?: SortOrder
    email?: SortOrder
    status?: SortOrder
    results?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type NamespacePermissionListRelationFilter = {
    every?: NamespacePermissionWhereInput
    some?: NamespacePermissionWhereInput
    none?: NamespacePermissionWhereInput
  }

  export type NamespacePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NamespaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NamespaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NamespaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type GroupMemberListRelationFilter = {
    every?: GroupMemberWhereInput
    some?: GroupMemberWhereInput
    none?: GroupMemberWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    samAccountName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    enabled?: SortOrder
    locked?: SortOrder
    approved?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    location?: SortOrder
    department?: SortOrder
    profilePhoto?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    samAccountName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    enabled?: SortOrder
    locked?: SortOrder
    approved?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    location?: SortOrder
    department?: SortOrder
    profilePhoto?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    samAccountName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    enabled?: SortOrder
    locked?: SortOrder
    approved?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    location?: SortOrder
    department?: SortOrder
    profilePhoto?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModulePermissionListRelationFilter = {
    every?: ModulePermissionWhereInput
    some?: ModulePermissionWhereInput
    none?: ModulePermissionWhereInput
  }

  export type ModulePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPredefined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPredefined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPredefined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type GroupScalarRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type GroupMemberUserIdGroupIdCompoundUniqueInput = {
    userId: string
    groupId: string
  }

  export type GroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
  }

  export type NamespaceScalarRelationFilter = {
    is?: NamespaceWhereInput
    isNot?: NamespaceWhereInput
  }

  export type GroupNullableScalarRelationFilter = {
    is?: GroupWhereInput | null
    isNot?: GroupWhereInput | null
  }

  export type NamespacePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    namespaceId?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    canRead?: SortOrder
    canWrite?: SortOrder
    canExecute?: SortOrder
    canAdmin?: SortOrder
    createdAt?: SortOrder
  }

  export type NamespacePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    namespaceId?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    canRead?: SortOrder
    canWrite?: SortOrder
    canExecute?: SortOrder
    canAdmin?: SortOrder
    createdAt?: SortOrder
  }

  export type NamespacePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    namespaceId?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    canRead?: SortOrder
    canWrite?: SortOrder
    canExecute?: SortOrder
    canAdmin?: SortOrder
    createdAt?: SortOrder
  }

  export type ModulePermissionGroupIdModuleCompoundUniqueInput = {
    groupId: string
    module: string
  }

  export type ModulePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    module?: SortOrder
    canRead?: SortOrder
    canWrite?: SortOrder
    canDelete?: SortOrder
    createdAt?: SortOrder
  }

  export type ModulePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    module?: SortOrder
    canRead?: SortOrder
    canWrite?: SortOrder
    canDelete?: SortOrder
    createdAt?: SortOrder
  }

  export type ModulePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    module?: SortOrder
    canRead?: SortOrder
    canWrite?: SortOrder
    canDelete?: SortOrder
    createdAt?: SortOrder
  }

  export type CredentialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    credentialType?: SortOrder
    username?: SortOrder
    password?: SortOrder
    sshPrivateKey?: SortOrder
    vaultPassword?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    credentialType?: SortOrder
    username?: SortOrder
    password?: SortOrder
    sshPrivateKey?: SortOrder
    vaultPassword?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CredentialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    credentialType?: SortOrder
    username?: SortOrder
    password?: SortOrder
    sshPrivateKey?: SortOrder
    vaultPassword?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    entityName?: SortOrder
    description?: SortOrder
    performedBy?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    entityName?: SortOrder
    description?: SortOrder
    performedBy?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    entityName?: SortOrder
    description?: SortOrder
    performedBy?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type RunCounterYearPoolCompoundUniqueInput = {
    year: number
    pool: string
  }

  export type RunCounterCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    pool?: SortOrder
    sequence?: SortOrder
    lastUsed?: SortOrder
  }

  export type RunCounterAvgOrderByAggregateInput = {
    year?: SortOrder
    sequence?: SortOrder
  }

  export type RunCounterMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    pool?: SortOrder
    sequence?: SortOrder
    lastUsed?: SortOrder
  }

  export type RunCounterMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    pool?: SortOrder
    sequence?: SortOrder
    lastUsed?: SortOrder
  }

  export type RunCounterSumOrderByAggregateInput = {
    year?: SortOrder
    sequence?: SortOrder
  }

  export type InstanceGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    awxId?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstanceGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    awxId?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstanceGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    awxId?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogListRelationFilter = {
    every?: CatalogWhereInput
    some?: CatalogWhereInput
    none?: CatalogWhereInput
  }

  export type CatalogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AwxEnvironmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseUrl?: SortOrder
    token?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AwxEnvironmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseUrl?: SortOrder
    token?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AwxEnvironmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseUrl?: SortOrder
    token?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AwxEnvironmentScalarRelationFilter = {
    is?: AwxEnvironmentWhereInput
    isNot?: AwxEnvironmentWhereInput
  }

  export type CatalogExecutionListRelationFilter = {
    every?: CatalogExecutionWhereInput
    some?: CatalogExecutionWhereInput
    none?: CatalogExecutionWhereInput
  }

  export type CatalogExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    namespaceId?: SortOrder
    environmentId?: SortOrder
    templateId?: SortOrder
    customBody?: SortOrder
    formSchema?: SortOrder
    isLocked?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    namespaceId?: SortOrder
    environmentId?: SortOrder
    templateId?: SortOrder
    customBody?: SortOrder
    formSchema?: SortOrder
    isLocked?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    namespaceId?: SortOrder
    environmentId?: SortOrder
    templateId?: SortOrder
    customBody?: SortOrder
    formSchema?: SortOrder
    isLocked?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatalogScalarRelationFilter = {
    is?: CatalogWhereInput
    isNot?: CatalogWhereInput
  }

  export type CatalogExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    catalogId?: SortOrder
    status?: SortOrder
    parameters?: SortOrder
    consoleOutput?: SortOrder
    artifacts?: SortOrder
    errorMessage?: SortOrder
    awxJobId?: SortOrder
    executedBy?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CatalogExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    catalogId?: SortOrder
    status?: SortOrder
    parameters?: SortOrder
    consoleOutput?: SortOrder
    artifacts?: SortOrder
    errorMessage?: SortOrder
    awxJobId?: SortOrder
    executedBy?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CatalogExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    catalogId?: SortOrder
    status?: SortOrder
    parameters?: SortOrder
    consoleOutput?: SortOrder
    artifacts?: SortOrder
    errorMessage?: SortOrder
    awxJobId?: SortOrder
    executedBy?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type RunCreateNestedManyWithoutAutomationInput = {
    create?: XOR<RunCreateWithoutAutomationInput, RunUncheckedCreateWithoutAutomationInput> | RunCreateWithoutAutomationInput[] | RunUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: RunCreateOrConnectWithoutAutomationInput | RunCreateOrConnectWithoutAutomationInput[]
    createMany?: RunCreateManyAutomationInputEnvelope
    connect?: RunWhereUniqueInput | RunWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutAutomationInput = {
    create?: XOR<ScheduleCreateWithoutAutomationInput, ScheduleUncheckedCreateWithoutAutomationInput> | ScheduleCreateWithoutAutomationInput[] | ScheduleUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutAutomationInput | ScheduleCreateOrConnectWithoutAutomationInput[]
    createMany?: ScheduleCreateManyAutomationInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type RunUncheckedCreateNestedManyWithoutAutomationInput = {
    create?: XOR<RunCreateWithoutAutomationInput, RunUncheckedCreateWithoutAutomationInput> | RunCreateWithoutAutomationInput[] | RunUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: RunCreateOrConnectWithoutAutomationInput | RunCreateOrConnectWithoutAutomationInput[]
    createMany?: RunCreateManyAutomationInputEnvelope
    connect?: RunWhereUniqueInput | RunWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutAutomationInput = {
    create?: XOR<ScheduleCreateWithoutAutomationInput, ScheduleUncheckedCreateWithoutAutomationInput> | ScheduleCreateWithoutAutomationInput[] | ScheduleUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutAutomationInput | ScheduleCreateOrConnectWithoutAutomationInput[]
    createMany?: ScheduleCreateManyAutomationInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RunUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<RunCreateWithoutAutomationInput, RunUncheckedCreateWithoutAutomationInput> | RunCreateWithoutAutomationInput[] | RunUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: RunCreateOrConnectWithoutAutomationInput | RunCreateOrConnectWithoutAutomationInput[]
    upsert?: RunUpsertWithWhereUniqueWithoutAutomationInput | RunUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: RunCreateManyAutomationInputEnvelope
    set?: RunWhereUniqueInput | RunWhereUniqueInput[]
    disconnect?: RunWhereUniqueInput | RunWhereUniqueInput[]
    delete?: RunWhereUniqueInput | RunWhereUniqueInput[]
    connect?: RunWhereUniqueInput | RunWhereUniqueInput[]
    update?: RunUpdateWithWhereUniqueWithoutAutomationInput | RunUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: RunUpdateManyWithWhereWithoutAutomationInput | RunUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: RunScalarWhereInput | RunScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<ScheduleCreateWithoutAutomationInput, ScheduleUncheckedCreateWithoutAutomationInput> | ScheduleCreateWithoutAutomationInput[] | ScheduleUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutAutomationInput | ScheduleCreateOrConnectWithoutAutomationInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutAutomationInput | ScheduleUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: ScheduleCreateManyAutomationInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutAutomationInput | ScheduleUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutAutomationInput | ScheduleUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type RunUncheckedUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<RunCreateWithoutAutomationInput, RunUncheckedCreateWithoutAutomationInput> | RunCreateWithoutAutomationInput[] | RunUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: RunCreateOrConnectWithoutAutomationInput | RunCreateOrConnectWithoutAutomationInput[]
    upsert?: RunUpsertWithWhereUniqueWithoutAutomationInput | RunUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: RunCreateManyAutomationInputEnvelope
    set?: RunWhereUniqueInput | RunWhereUniqueInput[]
    disconnect?: RunWhereUniqueInput | RunWhereUniqueInput[]
    delete?: RunWhereUniqueInput | RunWhereUniqueInput[]
    connect?: RunWhereUniqueInput | RunWhereUniqueInput[]
    update?: RunUpdateWithWhereUniqueWithoutAutomationInput | RunUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: RunUpdateManyWithWhereWithoutAutomationInput | RunUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: RunScalarWhereInput | RunScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<ScheduleCreateWithoutAutomationInput, ScheduleUncheckedCreateWithoutAutomationInput> | ScheduleCreateWithoutAutomationInput[] | ScheduleUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutAutomationInput | ScheduleCreateOrConnectWithoutAutomationInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutAutomationInput | ScheduleUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: ScheduleCreateManyAutomationInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutAutomationInput | ScheduleUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutAutomationInput | ScheduleUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type AutomationCreateNestedOneWithoutRuns_historyInput = {
    create?: XOR<AutomationCreateWithoutRuns_historyInput, AutomationUncheckedCreateWithoutRuns_historyInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutRuns_historyInput
    connect?: AutomationWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AutomationUpdateOneRequiredWithoutRuns_historyNestedInput = {
    create?: XOR<AutomationCreateWithoutRuns_historyInput, AutomationUncheckedCreateWithoutRuns_historyInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutRuns_historyInput
    upsert?: AutomationUpsertWithoutRuns_historyInput
    connect?: AutomationWhereUniqueInput
    update?: XOR<XOR<AutomationUpdateToOneWithWhereWithoutRuns_historyInput, AutomationUpdateWithoutRuns_historyInput>, AutomationUncheckedUpdateWithoutRuns_historyInput>
  }

  export type AutomationCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<AutomationCreateWithoutSchedulesInput, AutomationUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutSchedulesInput
    connect?: AutomationWhereUniqueInput
  }

  export type AutomationUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<AutomationCreateWithoutSchedulesInput, AutomationUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutSchedulesInput
    upsert?: AutomationUpsertWithoutSchedulesInput
    connect?: AutomationWhereUniqueInput
    update?: XOR<XOR<AutomationUpdateToOneWithWhereWithoutSchedulesInput, AutomationUpdateWithoutSchedulesInput>, AutomationUncheckedUpdateWithoutSchedulesInput>
  }

  export type NamespacePermissionCreateNestedManyWithoutNamespaceInput = {
    create?: XOR<NamespacePermissionCreateWithoutNamespaceInput, NamespacePermissionUncheckedCreateWithoutNamespaceInput> | NamespacePermissionCreateWithoutNamespaceInput[] | NamespacePermissionUncheckedCreateWithoutNamespaceInput[]
    connectOrCreate?: NamespacePermissionCreateOrConnectWithoutNamespaceInput | NamespacePermissionCreateOrConnectWithoutNamespaceInput[]
    createMany?: NamespacePermissionCreateManyNamespaceInputEnvelope
    connect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
  }

  export type NamespacePermissionUncheckedCreateNestedManyWithoutNamespaceInput = {
    create?: XOR<NamespacePermissionCreateWithoutNamespaceInput, NamespacePermissionUncheckedCreateWithoutNamespaceInput> | NamespacePermissionCreateWithoutNamespaceInput[] | NamespacePermissionUncheckedCreateWithoutNamespaceInput[]
    connectOrCreate?: NamespacePermissionCreateOrConnectWithoutNamespaceInput | NamespacePermissionCreateOrConnectWithoutNamespaceInput[]
    createMany?: NamespacePermissionCreateManyNamespaceInputEnvelope
    connect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
  }

  export type NamespacePermissionUpdateManyWithoutNamespaceNestedInput = {
    create?: XOR<NamespacePermissionCreateWithoutNamespaceInput, NamespacePermissionUncheckedCreateWithoutNamespaceInput> | NamespacePermissionCreateWithoutNamespaceInput[] | NamespacePermissionUncheckedCreateWithoutNamespaceInput[]
    connectOrCreate?: NamespacePermissionCreateOrConnectWithoutNamespaceInput | NamespacePermissionCreateOrConnectWithoutNamespaceInput[]
    upsert?: NamespacePermissionUpsertWithWhereUniqueWithoutNamespaceInput | NamespacePermissionUpsertWithWhereUniqueWithoutNamespaceInput[]
    createMany?: NamespacePermissionCreateManyNamespaceInputEnvelope
    set?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    disconnect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    delete?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    connect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    update?: NamespacePermissionUpdateWithWhereUniqueWithoutNamespaceInput | NamespacePermissionUpdateWithWhereUniqueWithoutNamespaceInput[]
    updateMany?: NamespacePermissionUpdateManyWithWhereWithoutNamespaceInput | NamespacePermissionUpdateManyWithWhereWithoutNamespaceInput[]
    deleteMany?: NamespacePermissionScalarWhereInput | NamespacePermissionScalarWhereInput[]
  }

  export type NamespacePermissionUncheckedUpdateManyWithoutNamespaceNestedInput = {
    create?: XOR<NamespacePermissionCreateWithoutNamespaceInput, NamespacePermissionUncheckedCreateWithoutNamespaceInput> | NamespacePermissionCreateWithoutNamespaceInput[] | NamespacePermissionUncheckedCreateWithoutNamespaceInput[]
    connectOrCreate?: NamespacePermissionCreateOrConnectWithoutNamespaceInput | NamespacePermissionCreateOrConnectWithoutNamespaceInput[]
    upsert?: NamespacePermissionUpsertWithWhereUniqueWithoutNamespaceInput | NamespacePermissionUpsertWithWhereUniqueWithoutNamespaceInput[]
    createMany?: NamespacePermissionCreateManyNamespaceInputEnvelope
    set?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    disconnect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    delete?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    connect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    update?: NamespacePermissionUpdateWithWhereUniqueWithoutNamespaceInput | NamespacePermissionUpdateWithWhereUniqueWithoutNamespaceInput[]
    updateMany?: NamespacePermissionUpdateManyWithWhereWithoutNamespaceInput | NamespacePermissionUpdateManyWithWhereWithoutNamespaceInput[]
    deleteMany?: NamespacePermissionScalarWhereInput | NamespacePermissionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSubordinatesInput = {
    create?: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubordinatesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type GroupMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type NamespacePermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<NamespacePermissionCreateWithoutUserInput, NamespacePermissionUncheckedCreateWithoutUserInput> | NamespacePermissionCreateWithoutUserInput[] | NamespacePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NamespacePermissionCreateOrConnectWithoutUserInput | NamespacePermissionCreateOrConnectWithoutUserInput[]
    createMany?: NamespacePermissionCreateManyUserInputEnvelope
    connect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type NamespacePermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NamespacePermissionCreateWithoutUserInput, NamespacePermissionUncheckedCreateWithoutUserInput> | NamespacePermissionCreateWithoutUserInput[] | NamespacePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NamespacePermissionCreateOrConnectWithoutUserInput | NamespacePermissionCreateOrConnectWithoutUserInput[]
    createMany?: NamespacePermissionCreateManyUserInputEnvelope
    connect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutSubordinatesNestedInput = {
    create?: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubordinatesInput
    upsert?: UserUpsertWithoutSubordinatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubordinatesInput, UserUpdateWithoutSubordinatesInput>, UserUncheckedUpdateWithoutSubordinatesInput>
  }

  export type UserUpdateManyWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagerInput | UserUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagerInput | UserUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagerInput | UserUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GroupMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type NamespacePermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<NamespacePermissionCreateWithoutUserInput, NamespacePermissionUncheckedCreateWithoutUserInput> | NamespacePermissionCreateWithoutUserInput[] | NamespacePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NamespacePermissionCreateOrConnectWithoutUserInput | NamespacePermissionCreateOrConnectWithoutUserInput[]
    upsert?: NamespacePermissionUpsertWithWhereUniqueWithoutUserInput | NamespacePermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NamespacePermissionCreateManyUserInputEnvelope
    set?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    disconnect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    delete?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    connect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    update?: NamespacePermissionUpdateWithWhereUniqueWithoutUserInput | NamespacePermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NamespacePermissionUpdateManyWithWhereWithoutUserInput | NamespacePermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NamespacePermissionScalarWhereInput | NamespacePermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagerInput | UserUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagerInput | UserUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagerInput | UserUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type NamespacePermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NamespacePermissionCreateWithoutUserInput, NamespacePermissionUncheckedCreateWithoutUserInput> | NamespacePermissionCreateWithoutUserInput[] | NamespacePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NamespacePermissionCreateOrConnectWithoutUserInput | NamespacePermissionCreateOrConnectWithoutUserInput[]
    upsert?: NamespacePermissionUpsertWithWhereUniqueWithoutUserInput | NamespacePermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NamespacePermissionCreateManyUserInputEnvelope
    set?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    disconnect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    delete?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    connect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    update?: NamespacePermissionUpdateWithWhereUniqueWithoutUserInput | NamespacePermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NamespacePermissionUpdateManyWithWhereWithoutUserInput | NamespacePermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NamespacePermissionScalarWhereInput | NamespacePermissionScalarWhereInput[]
  }

  export type GroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type NamespacePermissionCreateNestedManyWithoutGroupInput = {
    create?: XOR<NamespacePermissionCreateWithoutGroupInput, NamespacePermissionUncheckedCreateWithoutGroupInput> | NamespacePermissionCreateWithoutGroupInput[] | NamespacePermissionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: NamespacePermissionCreateOrConnectWithoutGroupInput | NamespacePermissionCreateOrConnectWithoutGroupInput[]
    createMany?: NamespacePermissionCreateManyGroupInputEnvelope
    connect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
  }

  export type ModulePermissionCreateNestedManyWithoutGroupInput = {
    create?: XOR<ModulePermissionCreateWithoutGroupInput, ModulePermissionUncheckedCreateWithoutGroupInput> | ModulePermissionCreateWithoutGroupInput[] | ModulePermissionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ModulePermissionCreateOrConnectWithoutGroupInput | ModulePermissionCreateOrConnectWithoutGroupInput[]
    createMany?: ModulePermissionCreateManyGroupInputEnvelope
    connect?: ModulePermissionWhereUniqueInput | ModulePermissionWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type NamespacePermissionUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<NamespacePermissionCreateWithoutGroupInput, NamespacePermissionUncheckedCreateWithoutGroupInput> | NamespacePermissionCreateWithoutGroupInput[] | NamespacePermissionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: NamespacePermissionCreateOrConnectWithoutGroupInput | NamespacePermissionCreateOrConnectWithoutGroupInput[]
    createMany?: NamespacePermissionCreateManyGroupInputEnvelope
    connect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
  }

  export type ModulePermissionUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<ModulePermissionCreateWithoutGroupInput, ModulePermissionUncheckedCreateWithoutGroupInput> | ModulePermissionCreateWithoutGroupInput[] | ModulePermissionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ModulePermissionCreateOrConnectWithoutGroupInput | ModulePermissionCreateOrConnectWithoutGroupInput[]
    createMany?: ModulePermissionCreateManyGroupInputEnvelope
    connect?: ModulePermissionWhereUniqueInput | ModulePermissionWhereUniqueInput[]
  }

  export type GroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type NamespacePermissionUpdateManyWithoutGroupNestedInput = {
    create?: XOR<NamespacePermissionCreateWithoutGroupInput, NamespacePermissionUncheckedCreateWithoutGroupInput> | NamespacePermissionCreateWithoutGroupInput[] | NamespacePermissionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: NamespacePermissionCreateOrConnectWithoutGroupInput | NamespacePermissionCreateOrConnectWithoutGroupInput[]
    upsert?: NamespacePermissionUpsertWithWhereUniqueWithoutGroupInput | NamespacePermissionUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: NamespacePermissionCreateManyGroupInputEnvelope
    set?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    disconnect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    delete?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    connect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    update?: NamespacePermissionUpdateWithWhereUniqueWithoutGroupInput | NamespacePermissionUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: NamespacePermissionUpdateManyWithWhereWithoutGroupInput | NamespacePermissionUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: NamespacePermissionScalarWhereInput | NamespacePermissionScalarWhereInput[]
  }

  export type ModulePermissionUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ModulePermissionCreateWithoutGroupInput, ModulePermissionUncheckedCreateWithoutGroupInput> | ModulePermissionCreateWithoutGroupInput[] | ModulePermissionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ModulePermissionCreateOrConnectWithoutGroupInput | ModulePermissionCreateOrConnectWithoutGroupInput[]
    upsert?: ModulePermissionUpsertWithWhereUniqueWithoutGroupInput | ModulePermissionUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ModulePermissionCreateManyGroupInputEnvelope
    set?: ModulePermissionWhereUniqueInput | ModulePermissionWhereUniqueInput[]
    disconnect?: ModulePermissionWhereUniqueInput | ModulePermissionWhereUniqueInput[]
    delete?: ModulePermissionWhereUniqueInput | ModulePermissionWhereUniqueInput[]
    connect?: ModulePermissionWhereUniqueInput | ModulePermissionWhereUniqueInput[]
    update?: ModulePermissionUpdateWithWhereUniqueWithoutGroupInput | ModulePermissionUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ModulePermissionUpdateManyWithWhereWithoutGroupInput | ModulePermissionUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ModulePermissionScalarWhereInput | ModulePermissionScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type NamespacePermissionUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<NamespacePermissionCreateWithoutGroupInput, NamespacePermissionUncheckedCreateWithoutGroupInput> | NamespacePermissionCreateWithoutGroupInput[] | NamespacePermissionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: NamespacePermissionCreateOrConnectWithoutGroupInput | NamespacePermissionCreateOrConnectWithoutGroupInput[]
    upsert?: NamespacePermissionUpsertWithWhereUniqueWithoutGroupInput | NamespacePermissionUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: NamespacePermissionCreateManyGroupInputEnvelope
    set?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    disconnect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    delete?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    connect?: NamespacePermissionWhereUniqueInput | NamespacePermissionWhereUniqueInput[]
    update?: NamespacePermissionUpdateWithWhereUniqueWithoutGroupInput | NamespacePermissionUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: NamespacePermissionUpdateManyWithWhereWithoutGroupInput | NamespacePermissionUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: NamespacePermissionScalarWhereInput | NamespacePermissionScalarWhereInput[]
  }

  export type ModulePermissionUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ModulePermissionCreateWithoutGroupInput, ModulePermissionUncheckedCreateWithoutGroupInput> | ModulePermissionCreateWithoutGroupInput[] | ModulePermissionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ModulePermissionCreateOrConnectWithoutGroupInput | ModulePermissionCreateOrConnectWithoutGroupInput[]
    upsert?: ModulePermissionUpsertWithWhereUniqueWithoutGroupInput | ModulePermissionUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ModulePermissionCreateManyGroupInputEnvelope
    set?: ModulePermissionWhereUniqueInput | ModulePermissionWhereUniqueInput[]
    disconnect?: ModulePermissionWhereUniqueInput | ModulePermissionWhereUniqueInput[]
    delete?: ModulePermissionWhereUniqueInput | ModulePermissionWhereUniqueInput[]
    connect?: ModulePermissionWhereUniqueInput | ModulePermissionWhereUniqueInput[]
    update?: ModulePermissionUpdateWithWhereUniqueWithoutGroupInput | ModulePermissionUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ModulePermissionUpdateManyWithWhereWithoutGroupInput | ModulePermissionUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ModulePermissionScalarWhereInput | ModulePermissionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutGroupMembershipsInput = {
    create?: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    connect?: GroupWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGroupMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembershipsInput
    upsert?: UserUpsertWithoutGroupMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupMembershipsInput, UserUpdateWithoutGroupMembershipsInput>, UserUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type GroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    upsert?: GroupUpsertWithoutMembersInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutMembersInput, GroupUpdateWithoutMembersInput>, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type NamespaceCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<NamespaceCreateWithoutPermissionsInput, NamespaceUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: NamespaceCreateOrConnectWithoutPermissionsInput
    connect?: NamespaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<GroupCreateWithoutPermissionsInput, GroupUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutPermissionsInput
    connect?: GroupWhereUniqueInput
  }

  export type NamespaceUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<NamespaceCreateWithoutPermissionsInput, NamespaceUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: NamespaceCreateOrConnectWithoutPermissionsInput
    upsert?: NamespaceUpsertWithoutPermissionsInput
    connect?: NamespaceWhereUniqueInput
    update?: XOR<XOR<NamespaceUpdateToOneWithWhereWithoutPermissionsInput, NamespaceUpdateWithoutPermissionsInput>, NamespaceUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserUpdateOneWithoutPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    upsert?: UserUpsertWithoutPermissionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPermissionsInput, UserUpdateWithoutPermissionsInput>, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type GroupUpdateOneWithoutPermissionsNestedInput = {
    create?: XOR<GroupCreateWithoutPermissionsInput, GroupUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutPermissionsInput
    upsert?: GroupUpsertWithoutPermissionsInput
    disconnect?: GroupWhereInput | boolean
    delete?: GroupWhereInput | boolean
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutPermissionsInput, GroupUpdateWithoutPermissionsInput>, GroupUncheckedUpdateWithoutPermissionsInput>
  }

  export type GroupCreateNestedOneWithoutModulePermissionsInput = {
    create?: XOR<GroupCreateWithoutModulePermissionsInput, GroupUncheckedCreateWithoutModulePermissionsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutModulePermissionsInput
    connect?: GroupWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutModulePermissionsNestedInput = {
    create?: XOR<GroupCreateWithoutModulePermissionsInput, GroupUncheckedCreateWithoutModulePermissionsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutModulePermissionsInput
    upsert?: GroupUpsertWithoutModulePermissionsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutModulePermissionsInput, GroupUpdateWithoutModulePermissionsInput>, GroupUncheckedUpdateWithoutModulePermissionsInput>
  }

  export type CatalogCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<CatalogCreateWithoutEnvironmentInput, CatalogUncheckedCreateWithoutEnvironmentInput> | CatalogCreateWithoutEnvironmentInput[] | CatalogUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: CatalogCreateOrConnectWithoutEnvironmentInput | CatalogCreateOrConnectWithoutEnvironmentInput[]
    createMany?: CatalogCreateManyEnvironmentInputEnvelope
    connect?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
  }

  export type CatalogUncheckedCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<CatalogCreateWithoutEnvironmentInput, CatalogUncheckedCreateWithoutEnvironmentInput> | CatalogCreateWithoutEnvironmentInput[] | CatalogUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: CatalogCreateOrConnectWithoutEnvironmentInput | CatalogCreateOrConnectWithoutEnvironmentInput[]
    createMany?: CatalogCreateManyEnvironmentInputEnvelope
    connect?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
  }

  export type CatalogUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<CatalogCreateWithoutEnvironmentInput, CatalogUncheckedCreateWithoutEnvironmentInput> | CatalogCreateWithoutEnvironmentInput[] | CatalogUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: CatalogCreateOrConnectWithoutEnvironmentInput | CatalogCreateOrConnectWithoutEnvironmentInput[]
    upsert?: CatalogUpsertWithWhereUniqueWithoutEnvironmentInput | CatalogUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: CatalogCreateManyEnvironmentInputEnvelope
    set?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    disconnect?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    delete?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    connect?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    update?: CatalogUpdateWithWhereUniqueWithoutEnvironmentInput | CatalogUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: CatalogUpdateManyWithWhereWithoutEnvironmentInput | CatalogUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: CatalogScalarWhereInput | CatalogScalarWhereInput[]
  }

  export type CatalogUncheckedUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<CatalogCreateWithoutEnvironmentInput, CatalogUncheckedCreateWithoutEnvironmentInput> | CatalogCreateWithoutEnvironmentInput[] | CatalogUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: CatalogCreateOrConnectWithoutEnvironmentInput | CatalogCreateOrConnectWithoutEnvironmentInput[]
    upsert?: CatalogUpsertWithWhereUniqueWithoutEnvironmentInput | CatalogUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: CatalogCreateManyEnvironmentInputEnvelope
    set?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    disconnect?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    delete?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    connect?: CatalogWhereUniqueInput | CatalogWhereUniqueInput[]
    update?: CatalogUpdateWithWhereUniqueWithoutEnvironmentInput | CatalogUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: CatalogUpdateManyWithWhereWithoutEnvironmentInput | CatalogUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: CatalogScalarWhereInput | CatalogScalarWhereInput[]
  }

  export type AwxEnvironmentCreateNestedOneWithoutCatalogsInput = {
    create?: XOR<AwxEnvironmentCreateWithoutCatalogsInput, AwxEnvironmentUncheckedCreateWithoutCatalogsInput>
    connectOrCreate?: AwxEnvironmentCreateOrConnectWithoutCatalogsInput
    connect?: AwxEnvironmentWhereUniqueInput
  }

  export type CatalogExecutionCreateNestedManyWithoutCatalogInput = {
    create?: XOR<CatalogExecutionCreateWithoutCatalogInput, CatalogExecutionUncheckedCreateWithoutCatalogInput> | CatalogExecutionCreateWithoutCatalogInput[] | CatalogExecutionUncheckedCreateWithoutCatalogInput[]
    connectOrCreate?: CatalogExecutionCreateOrConnectWithoutCatalogInput | CatalogExecutionCreateOrConnectWithoutCatalogInput[]
    createMany?: CatalogExecutionCreateManyCatalogInputEnvelope
    connect?: CatalogExecutionWhereUniqueInput | CatalogExecutionWhereUniqueInput[]
  }

  export type CatalogExecutionUncheckedCreateNestedManyWithoutCatalogInput = {
    create?: XOR<CatalogExecutionCreateWithoutCatalogInput, CatalogExecutionUncheckedCreateWithoutCatalogInput> | CatalogExecutionCreateWithoutCatalogInput[] | CatalogExecutionUncheckedCreateWithoutCatalogInput[]
    connectOrCreate?: CatalogExecutionCreateOrConnectWithoutCatalogInput | CatalogExecutionCreateOrConnectWithoutCatalogInput[]
    createMany?: CatalogExecutionCreateManyCatalogInputEnvelope
    connect?: CatalogExecutionWhereUniqueInput | CatalogExecutionWhereUniqueInput[]
  }

  export type AwxEnvironmentUpdateOneRequiredWithoutCatalogsNestedInput = {
    create?: XOR<AwxEnvironmentCreateWithoutCatalogsInput, AwxEnvironmentUncheckedCreateWithoutCatalogsInput>
    connectOrCreate?: AwxEnvironmentCreateOrConnectWithoutCatalogsInput
    upsert?: AwxEnvironmentUpsertWithoutCatalogsInput
    connect?: AwxEnvironmentWhereUniqueInput
    update?: XOR<XOR<AwxEnvironmentUpdateToOneWithWhereWithoutCatalogsInput, AwxEnvironmentUpdateWithoutCatalogsInput>, AwxEnvironmentUncheckedUpdateWithoutCatalogsInput>
  }

  export type CatalogExecutionUpdateManyWithoutCatalogNestedInput = {
    create?: XOR<CatalogExecutionCreateWithoutCatalogInput, CatalogExecutionUncheckedCreateWithoutCatalogInput> | CatalogExecutionCreateWithoutCatalogInput[] | CatalogExecutionUncheckedCreateWithoutCatalogInput[]
    connectOrCreate?: CatalogExecutionCreateOrConnectWithoutCatalogInput | CatalogExecutionCreateOrConnectWithoutCatalogInput[]
    upsert?: CatalogExecutionUpsertWithWhereUniqueWithoutCatalogInput | CatalogExecutionUpsertWithWhereUniqueWithoutCatalogInput[]
    createMany?: CatalogExecutionCreateManyCatalogInputEnvelope
    set?: CatalogExecutionWhereUniqueInput | CatalogExecutionWhereUniqueInput[]
    disconnect?: CatalogExecutionWhereUniqueInput | CatalogExecutionWhereUniqueInput[]
    delete?: CatalogExecutionWhereUniqueInput | CatalogExecutionWhereUniqueInput[]
    connect?: CatalogExecutionWhereUniqueInput | CatalogExecutionWhereUniqueInput[]
    update?: CatalogExecutionUpdateWithWhereUniqueWithoutCatalogInput | CatalogExecutionUpdateWithWhereUniqueWithoutCatalogInput[]
    updateMany?: CatalogExecutionUpdateManyWithWhereWithoutCatalogInput | CatalogExecutionUpdateManyWithWhereWithoutCatalogInput[]
    deleteMany?: CatalogExecutionScalarWhereInput | CatalogExecutionScalarWhereInput[]
  }

  export type CatalogExecutionUncheckedUpdateManyWithoutCatalogNestedInput = {
    create?: XOR<CatalogExecutionCreateWithoutCatalogInput, CatalogExecutionUncheckedCreateWithoutCatalogInput> | CatalogExecutionCreateWithoutCatalogInput[] | CatalogExecutionUncheckedCreateWithoutCatalogInput[]
    connectOrCreate?: CatalogExecutionCreateOrConnectWithoutCatalogInput | CatalogExecutionCreateOrConnectWithoutCatalogInput[]
    upsert?: CatalogExecutionUpsertWithWhereUniqueWithoutCatalogInput | CatalogExecutionUpsertWithWhereUniqueWithoutCatalogInput[]
    createMany?: CatalogExecutionCreateManyCatalogInputEnvelope
    set?: CatalogExecutionWhereUniqueInput | CatalogExecutionWhereUniqueInput[]
    disconnect?: CatalogExecutionWhereUniqueInput | CatalogExecutionWhereUniqueInput[]
    delete?: CatalogExecutionWhereUniqueInput | CatalogExecutionWhereUniqueInput[]
    connect?: CatalogExecutionWhereUniqueInput | CatalogExecutionWhereUniqueInput[]
    update?: CatalogExecutionUpdateWithWhereUniqueWithoutCatalogInput | CatalogExecutionUpdateWithWhereUniqueWithoutCatalogInput[]
    updateMany?: CatalogExecutionUpdateManyWithWhereWithoutCatalogInput | CatalogExecutionUpdateManyWithWhereWithoutCatalogInput[]
    deleteMany?: CatalogExecutionScalarWhereInput | CatalogExecutionScalarWhereInput[]
  }

  export type CatalogCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<CatalogCreateWithoutExecutionsInput, CatalogUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: CatalogCreateOrConnectWithoutExecutionsInput
    connect?: CatalogWhereUniqueInput
  }

  export type CatalogUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<CatalogCreateWithoutExecutionsInput, CatalogUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: CatalogCreateOrConnectWithoutExecutionsInput
    upsert?: CatalogUpsertWithoutExecutionsInput
    connect?: CatalogWhereUniqueInput
    update?: XOR<XOR<CatalogUpdateToOneWithWhereWithoutExecutionsInput, CatalogUpdateWithoutExecutionsInput>, CatalogUncheckedUpdateWithoutExecutionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type RunCreateWithoutAutomationInput = {
    id?: string
    status: string
    uniqueId?: string | null
    parameters?: string | null
    result?: string | null
    artifacts?: string | null
    errorMessage?: string | null
    executedBy?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    awxJobId?: string | null
  }

  export type RunUncheckedCreateWithoutAutomationInput = {
    id?: string
    status: string
    uniqueId?: string | null
    parameters?: string | null
    result?: string | null
    artifacts?: string | null
    errorMessage?: string | null
    executedBy?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    awxJobId?: string | null
  }

  export type RunCreateOrConnectWithoutAutomationInput = {
    where: RunWhereUniqueInput
    create: XOR<RunCreateWithoutAutomationInput, RunUncheckedCreateWithoutAutomationInput>
  }

  export type RunCreateManyAutomationInputEnvelope = {
    data: RunCreateManyAutomationInput | RunCreateManyAutomationInput[]
  }

  export type ScheduleCreateWithoutAutomationInput = {
    id?: string
    name: string
    frequency: string
    cron: string
    parameters?: string | null
    status?: string
    nextRun?: Date | string | null
    lastRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUncheckedCreateWithoutAutomationInput = {
    id?: string
    name: string
    frequency: string
    cron: string
    parameters?: string | null
    status?: string
    nextRun?: Date | string | null
    lastRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutAutomationInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutAutomationInput, ScheduleUncheckedCreateWithoutAutomationInput>
  }

  export type ScheduleCreateManyAutomationInputEnvelope = {
    data: ScheduleCreateManyAutomationInput | ScheduleCreateManyAutomationInput[]
  }

  export type RunUpsertWithWhereUniqueWithoutAutomationInput = {
    where: RunWhereUniqueInput
    update: XOR<RunUpdateWithoutAutomationInput, RunUncheckedUpdateWithoutAutomationInput>
    create: XOR<RunCreateWithoutAutomationInput, RunUncheckedCreateWithoutAutomationInput>
  }

  export type RunUpdateWithWhereUniqueWithoutAutomationInput = {
    where: RunWhereUniqueInput
    data: XOR<RunUpdateWithoutAutomationInput, RunUncheckedUpdateWithoutAutomationInput>
  }

  export type RunUpdateManyWithWhereWithoutAutomationInput = {
    where: RunScalarWhereInput
    data: XOR<RunUpdateManyMutationInput, RunUncheckedUpdateManyWithoutAutomationInput>
  }

  export type RunScalarWhereInput = {
    AND?: RunScalarWhereInput | RunScalarWhereInput[]
    OR?: RunScalarWhereInput[]
    NOT?: RunScalarWhereInput | RunScalarWhereInput[]
    id?: StringFilter<"Run"> | string
    automationId?: StringFilter<"Run"> | string
    status?: StringFilter<"Run"> | string
    uniqueId?: StringNullableFilter<"Run"> | string | null
    parameters?: StringNullableFilter<"Run"> | string | null
    result?: StringNullableFilter<"Run"> | string | null
    artifacts?: StringNullableFilter<"Run"> | string | null
    errorMessage?: StringNullableFilter<"Run"> | string | null
    executedBy?: StringNullableFilter<"Run"> | string | null
    startedAt?: DateTimeFilter<"Run"> | Date | string
    completedAt?: DateTimeNullableFilter<"Run"> | Date | string | null
    awxJobId?: StringNullableFilter<"Run"> | string | null
  }

  export type ScheduleUpsertWithWhereUniqueWithoutAutomationInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutAutomationInput, ScheduleUncheckedUpdateWithoutAutomationInput>
    create: XOR<ScheduleCreateWithoutAutomationInput, ScheduleUncheckedCreateWithoutAutomationInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutAutomationInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutAutomationInput, ScheduleUncheckedUpdateWithoutAutomationInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutAutomationInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutAutomationInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    OR?: ScheduleScalarWhereInput[]
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    id?: StringFilter<"Schedule"> | string
    name?: StringFilter<"Schedule"> | string
    automationId?: StringFilter<"Schedule"> | string
    frequency?: StringFilter<"Schedule"> | string
    cron?: StringFilter<"Schedule"> | string
    parameters?: StringNullableFilter<"Schedule"> | string | null
    status?: StringFilter<"Schedule"> | string
    nextRun?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    lastRun?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
  }

  export type AutomationCreateWithoutRuns_historyInput = {
    id?: string
    name: string
    namespace: string
    description?: string | null
    keywords?: string | null
    tags?: string | null
    formSchema: string
    apiEndpoint?: string | null
    templateId: string
    inventoryId?: string | null
    instanceGroupId?: string | null
    extraVars?: string | null
    customBody?: string | null
    pinned?: boolean
    featured?: boolean
    runs?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateWithoutRuns_historyInput = {
    id?: string
    name: string
    namespace: string
    description?: string | null
    keywords?: string | null
    tags?: string | null
    formSchema: string
    apiEndpoint?: string | null
    templateId: string
    inventoryId?: string | null
    instanceGroupId?: string | null
    extraVars?: string | null
    customBody?: string | null
    pinned?: boolean
    featured?: boolean
    runs?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationCreateOrConnectWithoutRuns_historyInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutRuns_historyInput, AutomationUncheckedCreateWithoutRuns_historyInput>
  }

  export type AutomationUpsertWithoutRuns_historyInput = {
    update: XOR<AutomationUpdateWithoutRuns_historyInput, AutomationUncheckedUpdateWithoutRuns_historyInput>
    create: XOR<AutomationCreateWithoutRuns_historyInput, AutomationUncheckedCreateWithoutRuns_historyInput>
    where?: AutomationWhereInput
  }

  export type AutomationUpdateToOneWithWhereWithoutRuns_historyInput = {
    where?: AutomationWhereInput
    data: XOR<AutomationUpdateWithoutRuns_historyInput, AutomationUncheckedUpdateWithoutRuns_historyInput>
  }

  export type AutomationUpdateWithoutRuns_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: StringFieldUpdateOperationsInput | string
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    instanceGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    extraVars?: NullableStringFieldUpdateOperationsInput | string | null
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    runs?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateWithoutRuns_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: StringFieldUpdateOperationsInput | string
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    instanceGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    extraVars?: NullableStringFieldUpdateOperationsInput | string | null
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    runs?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationCreateWithoutSchedulesInput = {
    id?: string
    name: string
    namespace: string
    description?: string | null
    keywords?: string | null
    tags?: string | null
    formSchema: string
    apiEndpoint?: string | null
    templateId: string
    inventoryId?: string | null
    instanceGroupId?: string | null
    extraVars?: string | null
    customBody?: string | null
    pinned?: boolean
    featured?: boolean
    runs?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    runs_history?: RunCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateWithoutSchedulesInput = {
    id?: string
    name: string
    namespace: string
    description?: string | null
    keywords?: string | null
    tags?: string | null
    formSchema: string
    apiEndpoint?: string | null
    templateId: string
    inventoryId?: string | null
    instanceGroupId?: string | null
    extraVars?: string | null
    customBody?: string | null
    pinned?: boolean
    featured?: boolean
    runs?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    runs_history?: RunUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationCreateOrConnectWithoutSchedulesInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutSchedulesInput, AutomationUncheckedCreateWithoutSchedulesInput>
  }

  export type AutomationUpsertWithoutSchedulesInput = {
    update: XOR<AutomationUpdateWithoutSchedulesInput, AutomationUncheckedUpdateWithoutSchedulesInput>
    create: XOR<AutomationCreateWithoutSchedulesInput, AutomationUncheckedCreateWithoutSchedulesInput>
    where?: AutomationWhereInput
  }

  export type AutomationUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: AutomationWhereInput
    data: XOR<AutomationUpdateWithoutSchedulesInput, AutomationUncheckedUpdateWithoutSchedulesInput>
  }

  export type AutomationUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: StringFieldUpdateOperationsInput | string
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    instanceGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    extraVars?: NullableStringFieldUpdateOperationsInput | string | null
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    runs?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runs_history?: RunUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: StringFieldUpdateOperationsInput | string
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    instanceGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    extraVars?: NullableStringFieldUpdateOperationsInput | string | null
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    runs?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runs_history?: RunUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type NamespacePermissionCreateWithoutNamespaceInput = {
    id?: string
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutPermissionsInput
    group?: GroupCreateNestedOneWithoutPermissionsInput
  }

  export type NamespacePermissionUncheckedCreateWithoutNamespaceInput = {
    id?: string
    userId?: string | null
    groupId?: string | null
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: Date | string
  }

  export type NamespacePermissionCreateOrConnectWithoutNamespaceInput = {
    where: NamespacePermissionWhereUniqueInput
    create: XOR<NamespacePermissionCreateWithoutNamespaceInput, NamespacePermissionUncheckedCreateWithoutNamespaceInput>
  }

  export type NamespacePermissionCreateManyNamespaceInputEnvelope = {
    data: NamespacePermissionCreateManyNamespaceInput | NamespacePermissionCreateManyNamespaceInput[]
  }

  export type NamespacePermissionUpsertWithWhereUniqueWithoutNamespaceInput = {
    where: NamespacePermissionWhereUniqueInput
    update: XOR<NamespacePermissionUpdateWithoutNamespaceInput, NamespacePermissionUncheckedUpdateWithoutNamespaceInput>
    create: XOR<NamespacePermissionCreateWithoutNamespaceInput, NamespacePermissionUncheckedCreateWithoutNamespaceInput>
  }

  export type NamespacePermissionUpdateWithWhereUniqueWithoutNamespaceInput = {
    where: NamespacePermissionWhereUniqueInput
    data: XOR<NamespacePermissionUpdateWithoutNamespaceInput, NamespacePermissionUncheckedUpdateWithoutNamespaceInput>
  }

  export type NamespacePermissionUpdateManyWithWhereWithoutNamespaceInput = {
    where: NamespacePermissionScalarWhereInput
    data: XOR<NamespacePermissionUpdateManyMutationInput, NamespacePermissionUncheckedUpdateManyWithoutNamespaceInput>
  }

  export type NamespacePermissionScalarWhereInput = {
    AND?: NamespacePermissionScalarWhereInput | NamespacePermissionScalarWhereInput[]
    OR?: NamespacePermissionScalarWhereInput[]
    NOT?: NamespacePermissionScalarWhereInput | NamespacePermissionScalarWhereInput[]
    id?: StringFilter<"NamespacePermission"> | string
    namespaceId?: StringFilter<"NamespacePermission"> | string
    userId?: StringNullableFilter<"NamespacePermission"> | string | null
    groupId?: StringNullableFilter<"NamespacePermission"> | string | null
    canRead?: BoolFilter<"NamespacePermission"> | boolean
    canWrite?: BoolFilter<"NamespacePermission"> | boolean
    canExecute?: BoolFilter<"NamespacePermission"> | boolean
    canAdmin?: BoolFilter<"NamespacePermission"> | boolean
    createdAt?: DateTimeFilter<"NamespacePermission"> | Date | string
  }

  export type UserCreateWithoutSubordinatesInput = {
    id?: string
    firstName: string
    lastName: string
    name: string
    samAccountName?: string | null
    email: string
    password?: string
    role?: string
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    location?: string | null
    department?: string | null
    profilePhoto?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    permissions?: NamespacePermissionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubordinatesInput = {
    id?: string
    firstName: string
    lastName: string
    name: string
    samAccountName?: string | null
    email: string
    password?: string
    role?: string
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    location?: string | null
    department?: string | null
    profilePhoto?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    permissions?: NamespacePermissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubordinatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
  }

  export type UserCreateWithoutManagerInput = {
    id?: string
    firstName: string
    lastName: string
    name: string
    samAccountName?: string | null
    email: string
    password?: string
    role?: string
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    location?: string | null
    department?: string | null
    profilePhoto?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserCreateNestedManyWithoutManagerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    permissions?: NamespacePermissionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutManagerInput = {
    id?: string
    firstName: string
    lastName: string
    name: string
    samAccountName?: string | null
    email: string
    password?: string
    role?: string
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    location?: string | null
    department?: string | null
    profilePhoto?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    permissions?: NamespacePermissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutManagerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type UserCreateManyManagerInputEnvelope = {
    data: UserCreateManyManagerInput | UserCreateManyManagerInput[]
  }

  export type GroupMemberCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    group: GroupCreateNestedOneWithoutMembersInput
  }

  export type GroupMemberUncheckedCreateWithoutUserInput = {
    id?: string
    groupId: string
    createdAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberCreateManyUserInputEnvelope = {
    data: GroupMemberCreateManyUserInput | GroupMemberCreateManyUserInput[]
  }

  export type NamespacePermissionCreateWithoutUserInput = {
    id?: string
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: Date | string
    namespace: NamespaceCreateNestedOneWithoutPermissionsInput
    group?: GroupCreateNestedOneWithoutPermissionsInput
  }

  export type NamespacePermissionUncheckedCreateWithoutUserInput = {
    id?: string
    namespaceId: string
    groupId?: string | null
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: Date | string
  }

  export type NamespacePermissionCreateOrConnectWithoutUserInput = {
    where: NamespacePermissionWhereUniqueInput
    create: XOR<NamespacePermissionCreateWithoutUserInput, NamespacePermissionUncheckedCreateWithoutUserInput>
  }

  export type NamespacePermissionCreateManyUserInputEnvelope = {
    data: NamespacePermissionCreateManyUserInput | NamespacePermissionCreateManyUserInput[]
  }

  export type UserUpsertWithoutSubordinatesInput = {
    update: XOR<UserUpdateWithoutSubordinatesInput, UserUncheckedUpdateWithoutSubordinatesInput>
    create: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubordinatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubordinatesInput, UserUncheckedUpdateWithoutSubordinatesInput>
  }

  export type UserUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    samAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    permissions?: NamespacePermissionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    samAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    permissions?: NamespacePermissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutManagerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutManagerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
  }

  export type UserUpdateManyWithWhereWithoutManagerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutManagerInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    samAccountName?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    enabled?: BoolFilter<"User"> | boolean
    locked?: BoolFilter<"User"> | boolean
    approved?: BoolFilter<"User"> | boolean
    approvedBy?: StringNullableFilter<"User"> | string | null
    approvedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    location?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    profilePhoto?: StringNullableFilter<"User"> | string | null
    managerId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutUserInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type GroupMemberScalarWhereInput = {
    AND?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    OR?: GroupMemberScalarWhereInput[]
    NOT?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    id?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    createdAt?: DateTimeFilter<"GroupMember"> | Date | string
  }

  export type NamespacePermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: NamespacePermissionWhereUniqueInput
    update: XOR<NamespacePermissionUpdateWithoutUserInput, NamespacePermissionUncheckedUpdateWithoutUserInput>
    create: XOR<NamespacePermissionCreateWithoutUserInput, NamespacePermissionUncheckedCreateWithoutUserInput>
  }

  export type NamespacePermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: NamespacePermissionWhereUniqueInput
    data: XOR<NamespacePermissionUpdateWithoutUserInput, NamespacePermissionUncheckedUpdateWithoutUserInput>
  }

  export type NamespacePermissionUpdateManyWithWhereWithoutUserInput = {
    where: NamespacePermissionScalarWhereInput
    data: XOR<NamespacePermissionUpdateManyMutationInput, NamespacePermissionUncheckedUpdateManyWithoutUserInput>
  }

  export type GroupMemberCreateWithoutGroupInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutGroupMembershipsInput
  }

  export type GroupMemberUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberCreateManyGroupInputEnvelope = {
    data: GroupMemberCreateManyGroupInput | GroupMemberCreateManyGroupInput[]
  }

  export type NamespacePermissionCreateWithoutGroupInput = {
    id?: string
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: Date | string
    namespace: NamespaceCreateNestedOneWithoutPermissionsInput
    user?: UserCreateNestedOneWithoutPermissionsInput
  }

  export type NamespacePermissionUncheckedCreateWithoutGroupInput = {
    id?: string
    namespaceId: string
    userId?: string | null
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: Date | string
  }

  export type NamespacePermissionCreateOrConnectWithoutGroupInput = {
    where: NamespacePermissionWhereUniqueInput
    create: XOR<NamespacePermissionCreateWithoutGroupInput, NamespacePermissionUncheckedCreateWithoutGroupInput>
  }

  export type NamespacePermissionCreateManyGroupInputEnvelope = {
    data: NamespacePermissionCreateManyGroupInput | NamespacePermissionCreateManyGroupInput[]
  }

  export type ModulePermissionCreateWithoutGroupInput = {
    id?: string
    module: string
    canRead?: boolean
    canWrite?: boolean
    canDelete?: boolean
    createdAt?: Date | string
  }

  export type ModulePermissionUncheckedCreateWithoutGroupInput = {
    id?: string
    module: string
    canRead?: boolean
    canWrite?: boolean
    canDelete?: boolean
    createdAt?: Date | string
  }

  export type ModulePermissionCreateOrConnectWithoutGroupInput = {
    where: ModulePermissionWhereUniqueInput
    create: XOR<ModulePermissionCreateWithoutGroupInput, ModulePermissionUncheckedCreateWithoutGroupInput>
  }

  export type ModulePermissionCreateManyGroupInputEnvelope = {
    data: ModulePermissionCreateManyGroupInput | ModulePermissionCreateManyGroupInput[]
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type NamespacePermissionUpsertWithWhereUniqueWithoutGroupInput = {
    where: NamespacePermissionWhereUniqueInput
    update: XOR<NamespacePermissionUpdateWithoutGroupInput, NamespacePermissionUncheckedUpdateWithoutGroupInput>
    create: XOR<NamespacePermissionCreateWithoutGroupInput, NamespacePermissionUncheckedCreateWithoutGroupInput>
  }

  export type NamespacePermissionUpdateWithWhereUniqueWithoutGroupInput = {
    where: NamespacePermissionWhereUniqueInput
    data: XOR<NamespacePermissionUpdateWithoutGroupInput, NamespacePermissionUncheckedUpdateWithoutGroupInput>
  }

  export type NamespacePermissionUpdateManyWithWhereWithoutGroupInput = {
    where: NamespacePermissionScalarWhereInput
    data: XOR<NamespacePermissionUpdateManyMutationInput, NamespacePermissionUncheckedUpdateManyWithoutGroupInput>
  }

  export type ModulePermissionUpsertWithWhereUniqueWithoutGroupInput = {
    where: ModulePermissionWhereUniqueInput
    update: XOR<ModulePermissionUpdateWithoutGroupInput, ModulePermissionUncheckedUpdateWithoutGroupInput>
    create: XOR<ModulePermissionCreateWithoutGroupInput, ModulePermissionUncheckedCreateWithoutGroupInput>
  }

  export type ModulePermissionUpdateWithWhereUniqueWithoutGroupInput = {
    where: ModulePermissionWhereUniqueInput
    data: XOR<ModulePermissionUpdateWithoutGroupInput, ModulePermissionUncheckedUpdateWithoutGroupInput>
  }

  export type ModulePermissionUpdateManyWithWhereWithoutGroupInput = {
    where: ModulePermissionScalarWhereInput
    data: XOR<ModulePermissionUpdateManyMutationInput, ModulePermissionUncheckedUpdateManyWithoutGroupInput>
  }

  export type ModulePermissionScalarWhereInput = {
    AND?: ModulePermissionScalarWhereInput | ModulePermissionScalarWhereInput[]
    OR?: ModulePermissionScalarWhereInput[]
    NOT?: ModulePermissionScalarWhereInput | ModulePermissionScalarWhereInput[]
    id?: StringFilter<"ModulePermission"> | string
    groupId?: StringFilter<"ModulePermission"> | string
    module?: StringFilter<"ModulePermission"> | string
    canRead?: BoolFilter<"ModulePermission"> | boolean
    canWrite?: BoolFilter<"ModulePermission"> | boolean
    canDelete?: BoolFilter<"ModulePermission"> | boolean
    createdAt?: DateTimeFilter<"ModulePermission"> | Date | string
  }

  export type UserCreateWithoutGroupMembershipsInput = {
    id?: string
    firstName: string
    lastName: string
    name: string
    samAccountName?: string | null
    email: string
    password?: string
    role?: string
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    location?: string | null
    department?: string | null
    profilePhoto?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    permissions?: NamespacePermissionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGroupMembershipsInput = {
    id?: string
    firstName: string
    lastName: string
    name: string
    samAccountName?: string | null
    email: string
    password?: string
    role?: string
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    location?: string | null
    department?: string | null
    profilePhoto?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    permissions?: NamespacePermissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGroupMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
  }

  export type GroupCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    isPredefined?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NamespacePermissionCreateNestedManyWithoutGroupInput
    modulePermissions?: ModulePermissionCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    isPredefined?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NamespacePermissionUncheckedCreateNestedManyWithoutGroupInput
    modulePermissions?: ModulePermissionUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutMembersInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutGroupMembershipsInput = {
    update: XOR<UserUpdateWithoutGroupMembershipsInput, UserUncheckedUpdateWithoutGroupMembershipsInput>
    create: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupMembershipsInput, UserUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type UserUpdateWithoutGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    samAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    permissions?: NamespacePermissionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    samAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    permissions?: NamespacePermissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GroupUpsertWithoutMembersInput = {
    update: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type GroupUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPredefined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NamespacePermissionUpdateManyWithoutGroupNestedInput
    modulePermissions?: ModulePermissionUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPredefined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NamespacePermissionUncheckedUpdateManyWithoutGroupNestedInput
    modulePermissions?: ModulePermissionUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type NamespaceCreateWithoutPermissionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    color?: string
    icon?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NamespaceUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    color?: string
    icon?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NamespaceCreateOrConnectWithoutPermissionsInput = {
    where: NamespaceWhereUniqueInput
    create: XOR<NamespaceCreateWithoutPermissionsInput, NamespaceUncheckedCreateWithoutPermissionsInput>
  }

  export type UserCreateWithoutPermissionsInput = {
    id?: string
    firstName: string
    lastName: string
    name: string
    samAccountName?: string | null
    email: string
    password?: string
    role?: string
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    location?: string | null
    department?: string | null
    profilePhoto?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPermissionsInput = {
    id?: string
    firstName: string
    lastName: string
    name: string
    samAccountName?: string | null
    email: string
    password?: string
    role?: string
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    location?: string | null
    department?: string | null
    profilePhoto?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
  }

  export type GroupCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    isPredefined?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    modulePermissions?: ModulePermissionCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    isPredefined?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    modulePermissions?: ModulePermissionUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutPermissionsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutPermissionsInput, GroupUncheckedCreateWithoutPermissionsInput>
  }

  export type NamespaceUpsertWithoutPermissionsInput = {
    update: XOR<NamespaceUpdateWithoutPermissionsInput, NamespaceUncheckedUpdateWithoutPermissionsInput>
    create: XOR<NamespaceCreateWithoutPermissionsInput, NamespaceUncheckedCreateWithoutPermissionsInput>
    where?: NamespaceWhereInput
  }

  export type NamespaceUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: NamespaceWhereInput
    data: XOR<NamespaceUpdateWithoutPermissionsInput, NamespaceUncheckedUpdateWithoutPermissionsInput>
  }

  export type NamespaceUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NamespaceUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutPermissionsInput = {
    update: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    samAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    samAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GroupUpsertWithoutPermissionsInput = {
    update: XOR<GroupUpdateWithoutPermissionsInput, GroupUncheckedUpdateWithoutPermissionsInput>
    create: XOR<GroupCreateWithoutPermissionsInput, GroupUncheckedCreateWithoutPermissionsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutPermissionsInput, GroupUncheckedUpdateWithoutPermissionsInput>
  }

  export type GroupUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPredefined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    modulePermissions?: ModulePermissionUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPredefined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    modulePermissions?: ModulePermissionUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateWithoutModulePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    isPredefined?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    permissions?: NamespacePermissionCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutModulePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    isPredefined?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    permissions?: NamespacePermissionUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutModulePermissionsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutModulePermissionsInput, GroupUncheckedCreateWithoutModulePermissionsInput>
  }

  export type GroupUpsertWithoutModulePermissionsInput = {
    update: XOR<GroupUpdateWithoutModulePermissionsInput, GroupUncheckedUpdateWithoutModulePermissionsInput>
    create: XOR<GroupCreateWithoutModulePermissionsInput, GroupUncheckedCreateWithoutModulePermissionsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutModulePermissionsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutModulePermissionsInput, GroupUncheckedUpdateWithoutModulePermissionsInput>
  }

  export type GroupUpdateWithoutModulePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPredefined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    permissions?: NamespacePermissionUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutModulePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPredefined?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    permissions?: NamespacePermissionUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type CatalogCreateWithoutEnvironmentInput = {
    id?: string
    name: string
    description?: string | null
    tags?: string | null
    namespaceId: string
    templateId: string
    customBody?: string | null
    formSchema?: string | null
    isLocked?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: CatalogExecutionCreateNestedManyWithoutCatalogInput
  }

  export type CatalogUncheckedCreateWithoutEnvironmentInput = {
    id?: string
    name: string
    description?: string | null
    tags?: string | null
    namespaceId: string
    templateId: string
    customBody?: string | null
    formSchema?: string | null
    isLocked?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: CatalogExecutionUncheckedCreateNestedManyWithoutCatalogInput
  }

  export type CatalogCreateOrConnectWithoutEnvironmentInput = {
    where: CatalogWhereUniqueInput
    create: XOR<CatalogCreateWithoutEnvironmentInput, CatalogUncheckedCreateWithoutEnvironmentInput>
  }

  export type CatalogCreateManyEnvironmentInputEnvelope = {
    data: CatalogCreateManyEnvironmentInput | CatalogCreateManyEnvironmentInput[]
  }

  export type CatalogUpsertWithWhereUniqueWithoutEnvironmentInput = {
    where: CatalogWhereUniqueInput
    update: XOR<CatalogUpdateWithoutEnvironmentInput, CatalogUncheckedUpdateWithoutEnvironmentInput>
    create: XOR<CatalogCreateWithoutEnvironmentInput, CatalogUncheckedCreateWithoutEnvironmentInput>
  }

  export type CatalogUpdateWithWhereUniqueWithoutEnvironmentInput = {
    where: CatalogWhereUniqueInput
    data: XOR<CatalogUpdateWithoutEnvironmentInput, CatalogUncheckedUpdateWithoutEnvironmentInput>
  }

  export type CatalogUpdateManyWithWhereWithoutEnvironmentInput = {
    where: CatalogScalarWhereInput
    data: XOR<CatalogUpdateManyMutationInput, CatalogUncheckedUpdateManyWithoutEnvironmentInput>
  }

  export type CatalogScalarWhereInput = {
    AND?: CatalogScalarWhereInput | CatalogScalarWhereInput[]
    OR?: CatalogScalarWhereInput[]
    NOT?: CatalogScalarWhereInput | CatalogScalarWhereInput[]
    id?: StringFilter<"Catalog"> | string
    name?: StringFilter<"Catalog"> | string
    description?: StringNullableFilter<"Catalog"> | string | null
    tags?: StringNullableFilter<"Catalog"> | string | null
    namespaceId?: StringFilter<"Catalog"> | string
    environmentId?: StringFilter<"Catalog"> | string
    templateId?: StringFilter<"Catalog"> | string
    customBody?: StringNullableFilter<"Catalog"> | string | null
    formSchema?: StringNullableFilter<"Catalog"> | string | null
    isLocked?: BoolFilter<"Catalog"> | boolean
    createdBy?: StringFilter<"Catalog"> | string
    createdAt?: DateTimeFilter<"Catalog"> | Date | string
    updatedAt?: DateTimeFilter<"Catalog"> | Date | string
  }

  export type AwxEnvironmentCreateWithoutCatalogsInput = {
    id?: string
    name: string
    baseUrl: string
    token?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AwxEnvironmentUncheckedCreateWithoutCatalogsInput = {
    id?: string
    name: string
    baseUrl: string
    token?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AwxEnvironmentCreateOrConnectWithoutCatalogsInput = {
    where: AwxEnvironmentWhereUniqueInput
    create: XOR<AwxEnvironmentCreateWithoutCatalogsInput, AwxEnvironmentUncheckedCreateWithoutCatalogsInput>
  }

  export type CatalogExecutionCreateWithoutCatalogInput = {
    id?: string
    status: string
    parameters?: string | null
    consoleOutput?: string | null
    artifacts?: string | null
    errorMessage?: string | null
    awxJobId?: string | null
    executedBy: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CatalogExecutionUncheckedCreateWithoutCatalogInput = {
    id?: string
    status: string
    parameters?: string | null
    consoleOutput?: string | null
    artifacts?: string | null
    errorMessage?: string | null
    awxJobId?: string | null
    executedBy: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CatalogExecutionCreateOrConnectWithoutCatalogInput = {
    where: CatalogExecutionWhereUniqueInput
    create: XOR<CatalogExecutionCreateWithoutCatalogInput, CatalogExecutionUncheckedCreateWithoutCatalogInput>
  }

  export type CatalogExecutionCreateManyCatalogInputEnvelope = {
    data: CatalogExecutionCreateManyCatalogInput | CatalogExecutionCreateManyCatalogInput[]
  }

  export type AwxEnvironmentUpsertWithoutCatalogsInput = {
    update: XOR<AwxEnvironmentUpdateWithoutCatalogsInput, AwxEnvironmentUncheckedUpdateWithoutCatalogsInput>
    create: XOR<AwxEnvironmentCreateWithoutCatalogsInput, AwxEnvironmentUncheckedCreateWithoutCatalogsInput>
    where?: AwxEnvironmentWhereInput
  }

  export type AwxEnvironmentUpdateToOneWithWhereWithoutCatalogsInput = {
    where?: AwxEnvironmentWhereInput
    data: XOR<AwxEnvironmentUpdateWithoutCatalogsInput, AwxEnvironmentUncheckedUpdateWithoutCatalogsInput>
  }

  export type AwxEnvironmentUpdateWithoutCatalogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AwxEnvironmentUncheckedUpdateWithoutCatalogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogExecutionUpsertWithWhereUniqueWithoutCatalogInput = {
    where: CatalogExecutionWhereUniqueInput
    update: XOR<CatalogExecutionUpdateWithoutCatalogInput, CatalogExecutionUncheckedUpdateWithoutCatalogInput>
    create: XOR<CatalogExecutionCreateWithoutCatalogInput, CatalogExecutionUncheckedCreateWithoutCatalogInput>
  }

  export type CatalogExecutionUpdateWithWhereUniqueWithoutCatalogInput = {
    where: CatalogExecutionWhereUniqueInput
    data: XOR<CatalogExecutionUpdateWithoutCatalogInput, CatalogExecutionUncheckedUpdateWithoutCatalogInput>
  }

  export type CatalogExecutionUpdateManyWithWhereWithoutCatalogInput = {
    where: CatalogExecutionScalarWhereInput
    data: XOR<CatalogExecutionUpdateManyMutationInput, CatalogExecutionUncheckedUpdateManyWithoutCatalogInput>
  }

  export type CatalogExecutionScalarWhereInput = {
    AND?: CatalogExecutionScalarWhereInput | CatalogExecutionScalarWhereInput[]
    OR?: CatalogExecutionScalarWhereInput[]
    NOT?: CatalogExecutionScalarWhereInput | CatalogExecutionScalarWhereInput[]
    id?: StringFilter<"CatalogExecution"> | string
    catalogId?: StringFilter<"CatalogExecution"> | string
    status?: StringFilter<"CatalogExecution"> | string
    parameters?: StringNullableFilter<"CatalogExecution"> | string | null
    consoleOutput?: StringNullableFilter<"CatalogExecution"> | string | null
    artifacts?: StringNullableFilter<"CatalogExecution"> | string | null
    errorMessage?: StringNullableFilter<"CatalogExecution"> | string | null
    awxJobId?: StringNullableFilter<"CatalogExecution"> | string | null
    executedBy?: StringFilter<"CatalogExecution"> | string
    startedAt?: DateTimeFilter<"CatalogExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"CatalogExecution"> | Date | string | null
  }

  export type CatalogCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    tags?: string | null
    namespaceId: string
    templateId: string
    customBody?: string | null
    formSchema?: string | null
    isLocked?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    environment: AwxEnvironmentCreateNestedOneWithoutCatalogsInput
  }

  export type CatalogUncheckedCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    tags?: string | null
    namespaceId: string
    environmentId: string
    templateId: string
    customBody?: string | null
    formSchema?: string | null
    isLocked?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogCreateOrConnectWithoutExecutionsInput = {
    where: CatalogWhereUniqueInput
    create: XOR<CatalogCreateWithoutExecutionsInput, CatalogUncheckedCreateWithoutExecutionsInput>
  }

  export type CatalogUpsertWithoutExecutionsInput = {
    update: XOR<CatalogUpdateWithoutExecutionsInput, CatalogUncheckedUpdateWithoutExecutionsInput>
    create: XOR<CatalogCreateWithoutExecutionsInput, CatalogUncheckedCreateWithoutExecutionsInput>
    where?: CatalogWhereInput
  }

  export type CatalogUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: CatalogWhereInput
    data: XOR<CatalogUpdateWithoutExecutionsInput, CatalogUncheckedUpdateWithoutExecutionsInput>
  }

  export type CatalogUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    namespaceId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: AwxEnvironmentUpdateOneRequiredWithoutCatalogsNestedInput
  }

  export type CatalogUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    namespaceId?: StringFieldUpdateOperationsInput | string
    environmentId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RunCreateManyAutomationInput = {
    id?: string
    status: string
    uniqueId?: string | null
    parameters?: string | null
    result?: string | null
    artifacts?: string | null
    errorMessage?: string | null
    executedBy?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    awxJobId?: string | null
  }

  export type ScheduleCreateManyAutomationInput = {
    id?: string
    name: string
    frequency: string
    cron: string
    parameters?: string | null
    status?: string
    nextRun?: Date | string | null
    lastRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RunUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    uniqueId?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    awxJobId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RunUncheckedUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    uniqueId?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    awxJobId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RunUncheckedUpdateManyWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    uniqueId?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    awxJobId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    cron?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    cron?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    cron?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NamespacePermissionCreateManyNamespaceInput = {
    id?: string
    userId?: string | null
    groupId?: string | null
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: Date | string
  }

  export type NamespacePermissionUpdateWithoutNamespaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPermissionsNestedInput
    group?: GroupUpdateOneWithoutPermissionsNestedInput
  }

  export type NamespacePermissionUncheckedUpdateWithoutNamespaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NamespacePermissionUncheckedUpdateManyWithoutNamespaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyManagerInput = {
    id?: string
    firstName: string
    lastName: string
    name: string
    samAccountName?: string | null
    email: string
    password?: string
    role?: string
    enabled?: boolean
    locked?: boolean
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    location?: string | null
    department?: string | null
    profilePhoto?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupMemberCreateManyUserInput = {
    id?: string
    groupId: string
    createdAt?: Date | string
  }

  export type NamespacePermissionCreateManyUserInput = {
    id?: string
    namespaceId: string
    groupId?: string | null
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: Date | string
  }

  export type UserUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    samAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUpdateManyWithoutManagerNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    permissions?: NamespacePermissionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    samAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    permissions?: NamespacePermissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    samAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NamespacePermissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    namespace?: NamespaceUpdateOneRequiredWithoutPermissionsNestedInput
    group?: GroupUpdateOneWithoutPermissionsNestedInput
  }

  export type NamespacePermissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    namespaceId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NamespacePermissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    namespaceId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyGroupInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type NamespacePermissionCreateManyGroupInput = {
    id?: string
    namespaceId: string
    userId?: string | null
    canRead?: boolean
    canWrite?: boolean
    canExecute?: boolean
    canAdmin?: boolean
    createdAt?: Date | string
  }

  export type ModulePermissionCreateManyGroupInput = {
    id?: string
    module: string
    canRead?: boolean
    canWrite?: boolean
    canDelete?: boolean
    createdAt?: Date | string
  }

  export type GroupMemberUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NamespacePermissionUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    namespace?: NamespaceUpdateOneRequiredWithoutPermissionsNestedInput
    user?: UserUpdateOneWithoutPermissionsNestedInput
  }

  export type NamespacePermissionUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    namespaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NamespacePermissionUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    namespaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canExecute?: BoolFieldUpdateOperationsInput | boolean
    canAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModulePermissionUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModulePermissionUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModulePermissionUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    canRead?: BoolFieldUpdateOperationsInput | boolean
    canWrite?: BoolFieldUpdateOperationsInput | boolean
    canDelete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogCreateManyEnvironmentInput = {
    id?: string
    name: string
    description?: string | null
    tags?: string | null
    namespaceId: string
    templateId: string
    customBody?: string | null
    formSchema?: string | null
    isLocked?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatalogUpdateWithoutEnvironmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    namespaceId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: CatalogExecutionUpdateManyWithoutCatalogNestedInput
  }

  export type CatalogUncheckedUpdateWithoutEnvironmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    namespaceId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: CatalogExecutionUncheckedUpdateManyWithoutCatalogNestedInput
  }

  export type CatalogUncheckedUpdateManyWithoutEnvironmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    namespaceId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    customBody?: NullableStringFieldUpdateOperationsInput | string | null
    formSchema?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogExecutionCreateManyCatalogInput = {
    id?: string
    status: string
    parameters?: string | null
    consoleOutput?: string | null
    artifacts?: string | null
    errorMessage?: string | null
    awxJobId?: string | null
    executedBy: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CatalogExecutionUpdateWithoutCatalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    consoleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    awxJobId?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CatalogExecutionUncheckedUpdateWithoutCatalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    consoleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    awxJobId?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CatalogExecutionUncheckedUpdateManyWithoutCatalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    consoleOutput?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    awxJobId?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}